<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>區塊鏈到底在幹嘛 - 30天系列</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">區塊鏈到底在幹嘛 - 30天系列</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day01前言區塊鏈的誕生"><a class="header" href="#day01前言區塊鏈的誕生">Day01|前言：區塊鏈的誕生</a></h1>
<h1 id="用共識來信任"><a class="header" href="#用共識來信任">用共識來信任</a></h1>
<p>區塊鏈簡而言之是透過共識來解決信任的問題，不只有區塊鏈如此，共識實質上決定現實中許多東西，比方說公眾人物的風評或是市場上的<strong>價值</strong> ：股票或黃金的價值就是透過共識決定出來的，如果世界上有一群人覺得黃金目前的價格被嚴重低估，為了追求利潤他們就會買入黃金同時使價格被拉高到一定的水準，但如果有另一群人覺得黃金目前的價格被嚴重高估，他們就會賣出手上的黃金避險，也連帶使價格拉低，如此反覆直到價格維持在大眾的共識上下進行動態平衡，這也是市場經濟的原理。</p>
<h1 id="共識如何被形塑"><a class="header" href="#共識如何被形塑">共識如何被形塑</a></h1>
<p>但說的簡單，共識的形塑往往並非那麼單純與透明，過程也不全然完全由大眾掌握，以剛剛的交易過程為例，現實中的交易我們是透過中間人(銀行或券商)來知道所有人願意出的價格，這個過程中我們信賴券商所提供的資訊並藉此做出反應，但券商有沒有可能造假或是透過資訊的優先來營利？另一個常見的例子是貨幣，貨幣由政府發行，我們基於信賴政府的公信力或強制力而願意收受政府發行的法定貨幣，並且在大部分的時間裡我們信任政府會維持貨幣的穩定發行與價值。但政府有沒有可能失信？當然有，而且濫發鈔票造成的惡性通膨在歷史上屢見不鮮。</p>
<h1 id="你的錢不是你的錢"><a class="header" href="#你的錢不是你的錢">你的錢不是你的錢</a></h1>
<p>2008年的金融風暴讓人們開始認知到銀行不一定可以被信任，銀行收走我們的錢後並沒有有效的管控，而貨幣持續的通貨膨脹，在過去120年來讓貨幣的購買力下跌了30倍，截至今天也還在下跌中。</p>
<p><img src="images/day01_91158.jpg" alt="Purchasing Power of US Dollar" /><br />
圖片來源：<a href="https://observationsandnotes.blogspot.com/">Observations</a></p>
<p>貨幣購買力下降的主因除了經濟成長外，也與政府不斷發行新貨幣進入市場有相關，小幅的通貨膨脹是正常的經濟活動，但貨幣流通量增加的速度實際上遠遠超出你我的想像，下圖是美金流通量的歷史。</p>
<p><img src="https://goldsilverworlds.com/wp-content/uploads/2014/04/US_Currency_circulation_1920_2014.jpg" alt="US Currency in Circulation" /><br />
圖片來源：<a href="https://goldsilverworlds.com/">Gold Silver Worlds</a></p>
<p>所以問題來了，要怎麼信任你手中的貨幣在未來是有價值的？但除了政府之外，又能相信誰具有公信力可以發行大家都能接受的貨幣？又怎能保證發行者在未來不會繼續超發呢？除了被政府法規管制與規範的銀行外，誰又有能力幫大眾保管資產或交易？<br />
<img src="images/day01_37201.jpg" alt="USD – Purchasing Power &amp; Currency in Circulation" /><br />
圖片來源：<a href="https://bmg-group.com/">BMG Group Inc.</a></p>
<h1 id="be-your-own-bank"><a class="header" href="#be-your-own-bank">Be your own bank.</a></h1>
<p>Bitcoin一開始便是為了解決誰可以是有公信力的發行者、誰又可以是公正的保管者的問題。中本聰提供的解決方案就是把貨幣的發行與詮釋權發還給大眾，並搭配密碼學來確保大眾手上的資料難以被竄改(這也是為什麼有時候會被叫成加密貨幣)，也就是人人手上都可以有帳本、每個人都是銀行來保證了共識的公正與執行，也因此Bitcoin的最初願景便是<code>"Be your own bank."</code>。值得一提的是區塊鏈並不是非常新的概念，銀行間很早就以類似分散式帳本的技術在做資料的交換與溝通，但狹義的公鏈與傳統分散式帳本最大的不同就是<code>Permissionless</code>，也就是你若有意願加入並分享帳本的話並不需要任何人的允許，透過成員間的自由的加入與退出來達成去中心化與社群共治的目標。</p>
<p>值得一提的是，數位資產的概念早在區塊鍊之前就已經出現，那時候已經能夠以非對稱加密的數位簽章(之後會再提)來核可與發送交易，而中本聰的貢獻則是嘗試以P2P網路的形式解決了同一筆資產可能會重複被花用的狀況(雙花攻擊，之後也會再提及)。下面這行字是來自於Bitcoin白皮書的原文：</p>
<blockquote>
<p>Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network.</p>
</blockquote>
<h1 id="系列文的架構"><a class="header" href="#系列文的架構">系列文的架構</a></h1>
<p>區塊鏈日新月異，至今也在不斷改變與成長中，為了瞭解區塊鍊的架構，明天開始會先探討如何利用密碼學與python建立一個最基礎簡單的區塊鏈，並從中了解到區塊鏈運行過程中需要哪些領域的基礎知識，再分別細談這些基礎知識中的密碼學、P2P網路、共識後，最後看看這些東西是如何出現在現實中的區塊鏈(以Bitcoin、Ethereum為主)。</p>
<p>區塊鏈每年都在變，但基礎架構與科學是不變的，期望透過簡單復刻→基礎理論解說→實際例子的過程中掌握區塊鏈的核心概念，即便有下一世代的區塊鏈出現，也可以很快掌握住。</p>
<h1 id="ref"><a class="header" href="#ref">Ref:</a></h1>
<ul>
<li><a href="https://bmg-group.com/usd-purchasing-power-currency-in-circulation/">USD – Purchasing Power – Currency in Circulation</a></li>
<li><a href="https://observationsandnotes.blogspot.com/2011/04/100-year-declining-value-of-us-dollar.html">The Decrease in Purchasing Power of the U.S. Dollar Since 1900</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day02打造一個簡易的區塊鏈1定義格式"><a class="header" href="#day02打造一個簡易的區塊鏈1定義格式">Day02|打造一個簡易的區塊鏈(1)：定義格式</a></h1>
<h1 id="區塊鏈的架構"><a class="header" href="#區塊鏈的架構">區塊鏈的架構</a></h1>
<h2 id="transaction"><a class="header" href="#transaction">Transaction</a></h2>
<p>打造一個簡單的區塊鏈之前，先來了解區塊鏈的架構與裏頭具備哪些要點。就像我們平常習慣用的銀行轉帳一樣，每筆交易都會產生一筆交易明細，詳細記錄了這筆交易的發送人、接收者、金額、手續費與備註，交易明細的功能除了作為憑證外，同時在銀行端也可以拿來核對，也就是俗稱的"軋帳"，這裡的每一筆交易明細我們先稱之為<code>Transaction</code>。<br />
<img src="https://www.lkm543.site/it_iron_man/day2_1.jpg" alt="Transaction" /></p>
<h2 id="blocks-of-transactions"><a class="header" href="#blocks-of-transactions">Blocks of transactions</a></h2>
<p>所有的<code>Transaction</code>會根據時間順序被放置到一個個區塊(<code>Block</code>)內，就像是把銀行把每個工作日早上九點到下午三點半前的所有交易紀錄都存在同一天的帳本裡一樣，如此周而復始，當有新的區塊正在產出，新生成的所有交易紀錄都會被放置在該區塊之下。<br />
<img src="https://www.lkm543.site/it_iron_man/day2_2.jpg" alt="Blockchain" /></p>
<p>你可能會有疑問說為什麼要這樣設計？為什麼不把所有的交易紀錄通通放在同一個區塊就好？</p>
<p>一旦我們把所有的交易紀錄都存放在同一個區塊或陣列之中，那麼即便其中某一筆資料被竄改我們也無從得知，也無法確認是哪一筆交易/區塊遭到竄改。另一個好處是我們可以透過這種方式把交易區分成<code>"已經被確認"</code>(置入區塊內)與<code>"等待中"</code>(尚未致入區塊)，這樣使用者便可以得知自己的匯款是否已經完成。</p>
<p>也因為透過區塊的切割與依次加密，就好比是我們在區塊與區塊中加了獨立鎖鍊一般，一旦有人意圖不軌試圖竄改過去的資料，則他必須要付出的代價是：必須層層把鎖鍊解開，否則資料鍊就會從此斷開而輕易地被人抓包。</p>
<p>不過依次加密這其中牽涉到複雜的密碼學，因此在寫完一個簡易的區塊鏈後我們會進到下一個章節，也是區塊鏈不可或缺的個重點：密碼學。</p>
<h2 id="今天的目標"><a class="header" href="#今天的目標">今天的目標</a></h2>
<ol>
<li>定義出交易格式</li>
<li>定義出區塊格式</li>
<li>建出區塊鍊的架構</li>
</ol>
<h3 id="交易格式"><a class="header" href="#交易格式">交易格式</a></h3>
<p>根據最上面我們談交易明細，一筆交易裏頭應該要有這些資訊：</p>
<ol>
<li>發送方(<code>sender</code>)：誰發起這筆交易的？同時也要確認是發送方底下餘額否足夠</li>
<li>收款方(<code>receiver</code>)：誰接收這筆交易的款項？</li>
<li>金額大小(<code>amounts</code>)：這筆交易的數目</li>
<li>手續費(<code>fee</code>)：支付的手續費多寡</li>
<li>訊息(<code>message</code>)：就像是轉帳的備註一般，可以留下資訊，通常是給收款方看</li>
</ol>
<pre><code>class Transaction:
    def __init__(self, sender, receiver, amounts, fee, message):
        self.sender = sender
        self.receiver = receiver
        self.amounts = amounts
        self.fee = fee
        self.message = message
</code></pre>
<h3 id="區塊格式"><a class="header" href="#區塊格式">區塊格式</a></h3>
<p>每一個區塊包含了許多筆交易(<code>Transaction</code>)，就像是帳本的內頁儲存了許多交易紀錄，值得一提的是這裡為了加密的需求會記錄前後一個區塊的哈希(<code>hash</code>)值，也就是每一塊之間的哈希值是環環相扣的，也可以把哈希值看做是每個區塊上的鎖頭，而礦工挖掘出的<code>nonce</code>則代表了能夠匹配這個鎖頭的鑰匙(或另一把鎖)，而且下一個區塊的哈希值又根據這個<code>nonce</code>值而產生，如此一來只要其中任何一個交易紀錄、區塊被竄改，則整個鍊上的<code>nonce</code>跟<code>hash</code>都需要修正，並且需要在新的區塊產生前計算/修正完畢，這需要擁有異常龐大的計算量，也因此竄改區塊鏈是幾近不可能的事情。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day2_3.jpg" alt="Hash and Nonce" /></p>
<p>至於甚麼是hash、區塊間如何加密的細節我們之後會再來探討。</p>
<p>所以</p>
<ol>
<li>前個區塊的哈希值(<code>previous_hash</code>)：為了加密需要我們會使用到前一個區塊的哈希值</li>
<li>這個區塊的哈希值(<code>hash</code>)：這個區塊計算後的哈希值</li>
<li><code>nonce</code>：礦工找到能夠解開鎖的鑰匙</li>
<li>當前難度(<code>difficulty</code>)：指挖出這個區塊時所使用的困難度，之後會再詳述</li>
<li>該區塊產生時的時間戳(<code>timestamp</code>)：紀錄了這是該區塊是在何時產生，之後調整挖礦難度會使用到</li>
<li>交易紀錄(<code>transactions</code>)：紀錄了這個區塊中所有的交易紀錄</li>
<li>挖掘礦工(<code>miner</code>)：紀錄了這個區塊中是由誰挖掘出來的</li>
<li>礦工獎勵(<code>miner_rewards</code>)：紀錄了這個區塊中所有給礦工的獎勵</li>
</ol>
<pre><code>class Block:
    def __init__(self, previous_hash, difficulty, miner, miner_rewards):
        self.previous_hash = previous_hash
        self.hash = ''
        self.difficulty = difficulty
        self.nonce = 0
        self.timestamp = int(time.time())
        self.transactions = []
        self.miner = miner
        self.miner_rewards = miner_rewards
</code></pre>
<h3 id="區塊鏈架構"><a class="header" href="#區塊鏈架構">區塊鏈架構</a></h3>
<ol>
<li>難度調節區塊數(<code>adjust_difficulty_blocks</code>)：每多少個區塊調節一次難度</li>
<li>目前難度(<code>difficulty</code>)：希望每個區塊的產出時間盡量保持一致，也因此隨著挖掘Nonce的機器數目與效能變動，挖掘難度也必須隨之調整以讓產出時間維持在動態平衡上，這個欄位代表了區塊鏈當下的難度</li>
<li>出塊時間(<code>block_time</code>)：理想上多久能夠出一個區塊，當實際出塊時間塊於設定的理想值時，代表運算效能優於實際需要，因此必須將難度做相對應的提升，以維持出塊時間的動態平衡，反之亦然，詳情在之後的教學中會有進一步的說明。</li>
<li>挖礦獎勵(<code>miner_rewards</code>)：獎勵挖礦者的金額多寡，挖出新區塊的礦工可以得到獎勵，藉此鼓勵礦工參與區塊鏈營運</li>
<li>區塊容量(<code>block_limitation</code>)：每一個區塊能夠容納的交易上限，上限的存在是因為當礦工挖掘出新的<code>nonce</code>時，他需要把所有被接受的交易連同區塊資料一併廣播給其他人知悉，因此如果容量過大會導致傳播過慢或是讓礦工需要的網速增加到不符合經濟效益的地步。</li>
<li>區塊鏈(<code>chain</code>)：目前區塊鏈中儲存的所有區塊</li>
<li>等待中的交易(<code>pending_pranscations</code>)：當使用者發送交易時，因為區塊鏈能夠吞吐的交易量有限，交易會先處在pending的狀況，當交易量過大時，礦工會首先選擇手續費高的交易先處理。</li>
</ol>
<pre><code>class BlockChain:
    def __init__(self):
        self.adjust_difficulty_blocks = 10
        self.difficulty = 1
        self.block_time = 30
        self.mining_rewards = 10
        self.block_limitation = 32
        self.chain = []
        self.pending_transactions = []
</code></pre>
<p>今天先到此為止，明天我們再來研究怎麼樣讓區塊能夠被挖掘！</p>
<p>到目前為止的文章都會放置到<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，程式碼可則以參考<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day02.py">這裡</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day03打造一個簡易的區塊鏈2產生創世塊與挖掘新區塊"><a class="header" href="#day03打造一個簡易的區塊鏈2產生創世塊與挖掘新區塊">Day03|打造一個簡易的區塊鏈(2)：產生創世塊與挖掘新區塊</a></h1>
<p>我們在昨天已經定義完交易、區塊、區塊鏈的主要格式與資料，今天的目標是架構起我們的簡易區塊鏈，並且能夠做到下面這四件事情</p>
<ol>
<li>產生哈希/湊雜數(Hash)</li>
<li>產生創世塊</li>
<li>放置交易明細至新區塊中</li>
<li>挖掘新區塊</li>
</ol>
<h1 id="產生哈希數hash"><a class="header" href="#產生哈希數hash">產生哈希數(Hash)</a></h1>
<p>哈希/湊雜數可以想做是一種轉換方式，可以把<strong>任意長度的輸入轉換成固定長度的輸出</strong> ，以SHA-1為例，它能夠把輸入值轉換成固定20個位元組的輸出。</p>
<p>哈希函數(<code>hash function</code>)必須同時滿足兩個條件：</p>
<blockquote>
<ol>
<li>同樣的輸入值必定得到相同的輸出值</li>
<li>得到的哈希數無法反推回原本的資料</li>
</ol>
</blockquote>
<p>以下面為例，<code>Hello World!</code>的字串能夠透過<code>SHA-1</code>的哈希函數轉換成：</p>
<blockquote>
<p>2ef7bde608ce5404e97d5f042f95f89f1c232871</p>
</blockquote>
<p>但同時產生的<code>2ef7bde608ce5404e97d5f042f95f89f1c232871</code>無法反推回原本的<code>Hello World!</code>。由於輸入資料的不同，往往我們可以把哈希數視作幾近隨機的位元組所構成(但仍然會因為哈希函數的不同而有所變異)</p>
<p><img src="https://www.lkm543.site/it_iron_man/day3_1.jpg" alt="hash" /><br />
<a href="https://www.fileformat.info/tool/hash.htm">這個網址</a>有更多的哈希函式的轉換可以試玩看看，以<code>Hello World!</code>這個字串為例，各種轉換法輸出的哈希值也不相同。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day3_2.jpg" alt="Hello World!" /></p>
<p>在這裡我們先把下面這些資料連接後作為哈希函式的輸入：</p>
<ol>
<li>前一個區塊的哈希值(<code>previous_hash</code>)</li>
<li>區塊產生當下的時間戳(<code>timestamp</code>)</li>
<li>所有的交易明細(<code>transactions</code>)</li>
<li>挖掘中的<code>nonce</code>值</li>
</ol>
<p><img src="https://www.lkm543.site/it_iron_man/day3_3.jpg" alt="Our Hash" /></p>
<p>下面是我們今天的程式碼，其中<code>transaction_to_string</code>負責把交易明細轉換成字串、<code>get_transactions_string</code>負責把區塊紀錄的所有交易明細轉換成一個字串、<code>get_hash</code>負責依據這四筆資料產生相對應的哈希數。</p>
<pre><code>import hashlib

def transaction_to_string(self, transaction):
    transaction_dict = {
        'sender': str(transaction.sender),
        'receiver': str(transaction.receiver),
        'amounts': transaction.amounts,
        'fee': transaction.fee,
        'message': transaction.message
    }
    return str(transaction_dict)

def get_transactions_string(self, block):
    transaction_str = ''
    for transaction in block.transactions:
        transaction_str += self.transaction_to_string(transaction)
    return transaction_str

def get_hash(self, block, nonce):
    s = hashlib.sha1()
    s.update(
        (
            block.previous_hash
            + str(block.timestamp)
            + self.get_transactions_string(block)
            + str(nonce)
        ).encode("utf-8")
    )
    h = s.hexdigest()
    return h
</code></pre>
<h1 id="產生創世塊genesis-block"><a class="header" href="#產生創世塊genesis-block">產生創世塊(genesis block)</a></h1>
<p>創世塊就是開始部署區塊鏈時所產生的第一個區塊，創世塊通常具有劃時代的意義，雖然以第一個區塊的角度而言它不需要帶有任何交易紀錄、是個空區塊，但創造鏈的人可以把精神或是象徵性的東西寫入創世塊中藉此提醒後人(?)，並以比特幣來說，比特幣的創世塊可以在<a href="https://sourceforge.net/p/bitcoin/code/133/tree/trunk/main.cpp#l1630">這個網址</a>查詢到。</p>
<pre><code>const char* pszTimestamp = "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks";
</code></pre>
<blockquote>
<p>The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.</p>
</blockquote>
<p>是中本聰寫入創世塊中的一句話，這也是2009/01/03英國《泰晤士報》的頭版標題，這時候的世界還陷在2008金融風暴的危機中，這篇報導敘述了當時的英國正考慮進行財務紓困，或許中本聰只是單純想證明這區塊確實是當天寫入的，又或許透過《泰晤士報》的頭版標題又對政府與中心化金融機構進行一次諷刺。</p>
<p><img src="https://image1.thenewslens.com/2018/1/56z78h9i5pg5erdou6gjbgmmfejc15.jpg" alt="The Times" /><br />
圖片來源：<a href="https://hk.thenewslens.com/">The News Lens</a></p>
<p>由於這是我們的第一個區塊鏈，所以我們就在<code>previous_hash</code>的欄位給...........<code>Hello World!</code> 藉此紀念一下 ，並且難度與挖礦獎勵設定成區塊鏈的預設值，礦工這裡就直接填入我們的姓名，產生創世塊後就直接把創世塊加入到<code>chain</code>之中</p>
<pre><code>def create_genesis_block(self):
    print("Create genesis block...")
    new_block = Block('Hello World!', self.difficulty, 'lkm543', self.miner_rewards)
    new_block.hash = self.get_hash(new_block, 0)
    self.chain.append(new_block)
</code></pre>
<h1 id="放置交易紀錄至新區塊中"><a class="header" href="#放置交易紀錄至新區塊中">放置交易紀錄至新區塊中</a></h1>
<p>區塊過大會導致在網路傳播上的不易與耗時，也因此每個區塊的承載量是有容量大小的上限，那礦工如何選擇哪幾筆交易應該被優先處理呢？礦工通常會根據自身的利益選擇手續費高的交易優先被處理，因此在這裡我們選擇手續費最高的幾筆交易優先加入區塊中。但如果等待中的交易(<code>pending_transactions</code>)數目沒有到區塊的承載量上限的話，那麼自然我們可以全部處理了！</p>
<p>而大家所熟知的Bitcoin的區塊容量上限是<code>1MB</code>，在1MB的容量下平均可以接受<code>3.3-7 TPS</code>(Transaction per Seconds，每秒幾筆交易)(<a href="https://en.wikipedia.org/wiki/Bitcoin_scalability_problem">來源</a>)，這數字大家可能沒甚麼概念，但與大家常使用的Visa做個比較─Visa的平均處理速度為<code>1700 TPS</code>(<a href="https://hackernoon.com/the-blockchain-scalability-problem-the-race-for-visa-like-transaction-speed-5cce48f9d44">來源</a>)，因此在bitcoin大規模被應用之前如何改進與增大TPS為社群熱門的研究題目，中本聰原先給的解決方案是增加區塊的容量，也就是提升原先設定的1MB區塊容量大小限制即可應對，增加TPS的路線與方法的不同甚至導致了社群的分裂，甚至產生了分岔(Fork)而生成了新的貨幣Bitcoin Cash(BCH)，關於BTC與BCH的路線之爭與差異有興趣繼續深入研究的人可以參考<a href="https://cointelegraph.com/bitcoin-cash-for-beginners/btc-bch-differences">這裡</a>，關於分岔的議題之後我們會再探討。</p>
<p>而Ethereum的區塊容量則是根據耗用資源的多寡以<code>Gas</code>為單位，每個區塊有<code>800萬Gas</code>的限制，關於Ethereum耗用Gas的機制因為較為複雜，我們之後也會另外說明，它們都有區塊容量的上限以確保挖角到新區塊後廣播過程的順利。</p>
<pre><code>def add_transaction_to_block(self, block):
    # Get the transaction with highest fee by block_limitation
    self.pending_transactions.sort(key=lambda x: x.fee, reverse=True)
    if len(self.pending_transactions) &gt; self.block_limitation:
        transcation_accepted = self.pending_transactions[:self.block_limitation]
        self.pending_transactions = self.pending_transactions[self.block_limitation:]
    else:
        transcation_accepted = self.pending_transactions
        self.pending_transactions = []
    block.transactions = transcation_accepted
</code></pre>
<h1 id="挖掘新區塊"><a class="header" href="#挖掘新區塊">挖掘新區塊</a></h1>
<p>接著我們就可以來挖掘產生新區塊了，挖掘的步驟是透過改變<code>nonce</code>值(從0,1,2,3....直到找到符合的<code>nonce</code>)而得到新的哈希數，在這裡我們把難度定義為"開頭有幾個0"，也就是每次改變<code>nonce</code>、產生一個新的<code>hash</code>數後來確認有沒有符合要求(開頭有幾個0)，如果符合就代表我們找到一個合規<code>nonce</code>值了！但如果沒有，就只好持續的往下找了。也因為運算量越大能夠找到合規的<code>nonce</code>值的機率也越大，也因此這個方法又被稱為<code>Proof of Work(POW)</code>。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day3_4.jpg" alt="Mine" /></p>
<p>但透過這個方式區塊的產生時間會非常地不穩定，你可以到<a href="https://www.blockchain.com/explorer">bitcoin的區塊瀏覽器</a>看看產出的時間，bitcoin預設是每十分鐘應該要產出一個區塊，但也可以發現實際上每個區塊的產生時間會跟十分鐘有點落差，這是POW的必然結果。</p>
<p>在這裡的實作中，我們生成一個區塊後不停計算不一樣的<code>nonce</code>值，直到我們能夠找到合規的<code>nonce</code>為止，直到發現(挖掘)合規的<code>nonce</code>之後，就可以把挖出來的區塊置入鏈裡頭。</p>
<pre><code>def mine_block(self, miner):
    start = time.process_time()

    last_block = self.chain[-1]
    new_block = Block(last_block.hash, self.difficulty, miner, self.miner_rewards)

    self.add_transaction_to_block(new_block)
    new_block.previous_hash = last_block.hash
    new_block.difficulty = self.difficulty
    new_block.hash = self.get_hash(new_block, new_block.nonce)

    while new_block.hash[0: self.difficulty] != '0' * self.difficulty:
        new_block.nonce += 1
        new_block.hash = self.get_hash(new_block, new_block.nonce)

    time_consumed = round(time.process_time() - start, 5)
    print(f"Hash found: {new_block.hash} @ difficulty {self.difficulty}, time cost: {time_consumed}s")
    self.chain.append(new_block)
</code></pre>
<h1 id="今天的問題"><a class="header" href="#今天的問題">今天的問題</a></h1>
<p>問題來了：如果參與挖掘的人越來越多，那麼區塊不是一下就會被挖掘出來了嗎？是的，所以明天我們會來談談怎麼根據實際情形改變挖掘的難度！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，至於程式碼則放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day03.py">這裡</a>。</p>
<h1 id="ref-1"><a class="header" href="#ref-1">Ref</a></h1>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">維基百科-雜湊函式</a></li>
<li><a href="https://www.tsnien.idv.tw/Security_WebBook/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E9%9B%9C%E6%B9%8A%E8%88%87%E4%BA%82%E6%95%B8%E6%BC%94%E7%AE%97%E6%B3%95.html">資訊與網路安全概論-粘添壽</a></li>
<li><a href="https://bigdatafinance.tw/index.php/finance/fintech/465-2017-10-07-15-08-09">區塊鏈原理最清晰最直觀的解釋</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day04打造一個簡易的區塊鏈3難度調整與確認哈希鏈"><a class="header" href="#day04打造一個簡易的區塊鏈3難度調整與確認哈希鏈">Day04|打造一個簡易的區塊鏈(3)：難度調整與確認哈希鏈</a></h1>
<p>昨天我們已經有能力產生出新區塊，但區塊的產生時間會根據運算力的多寡而浮動，因此今天我們要處理的第一件事便是根據現在運算力多寡調整挖礦的難度，除此之外我們在處理交易前也必須事先確認該帳戶的餘額是否足夠，最後是確認我們的區塊鏈是不是有被竄改過。</p>
<p>總結今天的三件事情：</p>
<ol>
<li>調整哈希難度</li>
<li>計算帳戶餘額</li>
<li>確認哈希值是否正確</li>
</ol>
<h1 id="調整哈希難度"><a class="header" href="#調整哈希難度">調整哈希難度</a></h1>
<p>由於每區塊裏頭都記錄著區塊被挖掘出的當下時間戳(<code>timestamp</code>)，因此我們可以知道每個區塊的產出時間(也就是找出符合的<code>nonce</code>所耗費的時間)，如果難度是固定的，那麼參與挖礦的運算力如果成長十倍，區塊的平均產出時間也會連帶變成十分之一，因此順應運算力的多寡而調整難度對區塊鏈的長久運行是很重要的。</p>
<p>那怎麼去評估區塊的產生時間呢？如果單純採用前一個區塊的產出時間很明顯的是不可行，因為<code>POW</code>的核心精神是利用隨機數去猜到可能可以符合的<code>nonce</code>，因此每一個區塊的產出時間會變動相當大：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day4_1.jpg" alt="Block time diversity" /></p>
<p>根據上圖看到我們的區塊鏈在難度5的狀況下，連續十塊的出塊時間從0.47秒到39.44秒都有可能，昨天提到的<a href="https://www.blockchain.com/explorer">區塊鍊瀏覽器</a>裏頭也可以發現出塊時間會不斷跳動，因此根據單個區塊的出塊時間決定難度是萬萬不可行的，取而代之的方法便是取多個區塊的出塊時間再取平均，有點像是訊號處理中的均值濾波器。</p>
<p>在這裡我們設定如果平均出塊時間小於設定的出塊時間，就把難度加1，如果平均出塊時間大於設定的出塊時間，就把難度減1。這裡難度的定義是挖到的<code>nonce</code>值必須要滿足讓Hash的頭幾個Bytes為0，因此難度每加1，實際上的運算量會增加16倍(位元組是兩兩16進位構成的)，也因為調整幅度太大，所以其實這裡設計的並不是很好的難度調整算法。</p>
<pre><code>def adjust_difficulty(self):
    if len(self.chain) % self.adjust_difficulty_blocks != 1:
        return self.difficulty
    elif len(self.chain) &lt;= self.adjust_difficulty_blocks:
        return self.difficulty
    else:
        start = self.chain[-1*self.adjust_difficulty_blocks-1].timestamp
        finish = self.chain[-1].timestamp
        average_time_consumed = round((finish - start) / (self.adjust_difficulty_blocks), 2)
        if average_time_consumed &gt; self.block_time:
            print(f"Average block time:{average_time_consumed}s. Lower the difficulty")
            self.difficulty -= 1
        else:
            print(f"Average block time:{average_time_consumed}s. High up the difficulty")
            self.difficulty += 1
</code></pre>
<p>實際上比特幣每過2016個區塊，會根據前面2016個區塊的平均出塊時間調整難度，如果前面2016個區塊的平均出塊時間大於十分鐘，代表現在的運算力過少、挖礦難度偏高使出塊時間變長，因此需要降低挖礦難度；反之如果這2016個區塊的平均出塊時間小於十分鐘，代表現在的運算力過多、挖礦難度偏低使出塊時間變短，因此需要提升挖礦難度。這2016個區塊所需的時間大概是：</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=2016(Blocks)*10(Minutes%20per%20Block)%2F1440(Minutes%20per%20Day)%3D14(Days)" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=2016(Blocks)*10(Minutes%20per%20Block)%2F1440(Minutes%20per%20Day)%3D14(Days))" />)</p>
<p>也就是平均大約兩個禮拜Bitcoin會調整一次難度。你也可以在<a href="https://bitinfocharts.com/comparison/bitcoin-difficulty.html">這個網站</a>上看到歷史Bitcoin/Ethereum的挖礦難度。如果真的點開那個網站，應該可以很快發現難度往往是不斷增加而很少下降的，造成難度不斷上漲的主要原因有兩點：</p>
<ol>
<li>幣價上漲導致更多人參與挖礦以獲取Bitcoin</li>
<li>硬體效能的進步使運算能力飛速成長</li>
</ol>
<p>特別是第二點的硬體能力，BTC使用的<code>SHA-256</code>挖礦演算法目前已經被特殊應用積體電路（Application-specific integrated circuit，ASIC）所主宰，個人PC的硬體效能已經無力跟ASIC競爭。非但如此，ASIC的推陳出新也逐步刷新效能的上限，<a href="https://en.bitcoin.it/wiki/Mining_hardware_comparison">這裡</a>可以看到各ASIC主要型號的運算力，從運算力中可以發現比特大陸的Antminer S1出到S9的過程中，運算力整整增加了快80倍(180,000Mh/s→14,000,000Mh/s)，如果難度保持不便，即使在機台數都沒有增加的狀況下，出塊的時間也會縮短成1/80，多麼可怕的數據。</p>
<p>關於挖礦相關的技術細節，我們在之後的挖礦實戰會細談這件事情。</p>
<h1 id="計算帳戶餘額"><a class="header" href="#計算帳戶餘額">計算帳戶餘額</a></h1>
<p>除了難度調整，在發起交易當下也必須檢查匯款人的餘額是否足夠，同時也限制不能匯出超過自己帳戶的餘額，而帳戶餘額總共只有三種來源：</p>
<ul>
<li>區塊獎勵：挖出區塊的礦工能得到區塊的獎勵</li>
<li>手續費收入：挖出區塊的礦工能得到該比區塊內所有交易的手續費</li>
<li>匯款收入：收到別人匯款的款項</li>
</ul>
<p>因此我們寫一個簡單的函式，從第一個區塊的第一筆交易開始檢查，一路檢查到最後一筆後便可以得到該帳戶的餘額。</p>
<pre><code>def get_balance(self, account):
    balance = 0
    for block in self.chain:
        # Check miner reward
        miner = False
        if block.miner == account:
            miner = True
            balance += block.miner_rewards
        for transaction in block.transactions:
            if miner:
                balance += transaction.fee
            if transaction.sender == account:
                balance -= transaction.amounts
                balance -= transaction.fee
            elif transaction.receiver == account:
                balance += transaction.amounts
    return balance
</code></pre>
<h1 id="確認哈希值是否正確"><a class="header" href="#確認哈希值是否正確">確認哈希值是否正確</a></h1>
<p>為了避免我們的資料被竄改，也必須時常檢查資料的正確性。還記得我們每個區塊的哈希數都是環環相扣的吧?在昨天每個哈希數都由下面這四筆資料計算出來：</p>
<ol>
<li>前一個區塊的hash(<code>previous_hash</code>)</li>
<li>區塊產生的時間戳</li>
<li>所有的交易紀錄</li>
<li><code>nonce</code></li>
</ol>
<p>所以檢查的方式就是從第一個區塊的哈希數一路算到最後一個，一旦中間開始的某個哈希數算完之後對不起來，那麼就代表其中的某筆交易紀錄被竄改過。</p>
<pre><code>def verify_blockchain(self):
    previous_hash = ''
    for idx,block in enumerate(self.chain):
        if self.get_hash(block, block.nonce) != block.hash:
            print("Error:Hash not matched!")
            return False
        elif previous_hash != block.previous_hash and idx:
            print("Error:Hash not matched to previous_hash")
            return False
        previous_hash = block.hash
    print("Hash correct!")
    return True
</code></pre>
<h2 id="測試一下"><a class="header" href="#測試一下">測試一下：</a></h2>
<p>如果我們在其中一個區塊插入了一筆偽造的交易，那麼透過一連串哈希的確認與計算，我們便可以發現hash數是對不起來的！</p>
<pre><code>if __name__ == '__main__':
    block = BlockChain()
    block.create_genesis_block()
    block.mine_block('lkm543')

    block.verify_blockchain()
    
    print("Insert fake transaction.")
    fake_transaction = Transaction('test123', address, 100, 1, 'Test')    
    block.chain[1].transactions.append(fake_transaction)
    block.mine_block('lkm543')

    block.verify_blockchain()
</code></pre>
<p><img src="https://www.lkm543.site/it_iron_man/day4_2.jpg" alt="Fake Transaction" /></p>
<p>除此之外你也可以到<a href="https://anders.com/blockchain/blockchain">這裡</a>玩玩看區塊鏈，一開始所有資料都是正確無誤的，所以會顯示綠色：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day4_3.jpg" alt="Demo" /></p>
<p>一旦你在前面區塊中亂插入一些紀錄，你會發現從該區塊之後的所有哈希數通通被打亂了！像是在這裡我插入：<br />
<code>"I am Bill Gates"</code></p>
<p><img src="https://www.lkm543.site/it_iron_man/day4_4.jpg" alt="Demo" /></p>
<p>被更改的區塊後的所有區塊都必須從新被計算哈希數，否則會完全對不起來而被輕易發現資料被竄改過！當然可以選擇重新計算所有的哈希數，但當主鏈夠長時，重新計算所有的哈希數所需要的運算量與成本非常可怕，也因此保障了區塊鏈的不可竄改性。更何況在重新計算時，正常的塊也在不停的被一般的礦工產出，要跟所有的礦工競爭幾近天方夜譚。</p>
<h1 id="今天的問題-1"><a class="header" href="#今天的問題-1">今天的問題</a></h1>
<p>但有個問題：我要怎麼知道發起交易的那方便是帳戶的持有者？如果不事先確認的話，代表任意路人都可以把別人的帳戶餘額領走，是萬萬不可的事情。那麼我們又要如何確認誰擁有這個帳號？誰有權力發起交易？</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，至於程式碼則放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day04.py">這裡</a>。</p>
<h1 id="ref-2"><a class="header" href="#ref-2">Ref:</a></h1>
<ul>
<li><a href="https://kknews.cc/zh-tw/tech/mpz4rjg.html">比特幣系統是如何調整挖礦難度的？</a></li>
<li><a href="https://medium.com/fpga-guide/cryptocurrency-mining-why-use-fpga-for-mining-fpga-vs-gpu-vs-asic-explained-5aaa400082b9">Cryptocurrency Mining: Why Use FPGA for Mining? FPGA vs GPU vs ASIC Explained</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day05打造一個簡易的區塊鏈4公私鑰與簽章"><a class="header" href="#day05打造一個簡易的區塊鏈4公私鑰與簽章">Day05|打造一個簡易的區塊鏈(4)：公、私鑰與簽章</a></h1>
<p>昨天遇到一個問題：如果我們未經驗證就直接把交易紀錄送上區塊鏈，那麼任意人都可以隨意移轉他人帳戶的餘額，很明顯這樣是不可以的，於是今天我們主要處理的便是驗證發起交易者的身分與權限，其中又可以分成以下三個步驟：</p>
<ol>
<li>利用RSA加密產生公、私鑰與地址</li>
<li>利用產生的公私鑰簽章後發送交易</li>
<li>試著跑起整個鏈並發起交易</li>
</ol>
<h1 id="非對稱式加密"><a class="header" href="#非對稱式加密">非對稱式加密</a></h1>
<p>區塊鏈只存在網路上，我們很明顯地無法透過身分證等文件去確認發起者的身分，因此這裡用到的是<strong>非對稱加密</strong> 。但非對稱加密因為篇幅較長與理論較深之後會獨立一個章節做進一步的說明，這裡先簡短說明一下非對稱加密的功能。</p>
<p>非對稱加密會得到兩把鑰匙：公鑰與私鑰，功能很簡單就一句話</p>
<blockquote>
<p><em>可以公鑰加密私鑰解密，也可以私鑰加密公鑰解密。</em></p>
</blockquote>
<p>也就是每個人在產生地址的時候同時會得到一把公鑰、一把私鑰，通常公鑰會釋出給對方，私鑰會自己持有以證明自己是該公鑰的持有者。</p>
<p><img src="images/day05_66908.png" alt="Public Private Key" /><br />
圖片來源：<a href="https://www.twilio.com/blog/what-is-public-key-cryptography">twillo</a></p>
<p>以上圖傳私訊給Bob為例，為了確保我所傳遞的訊息只有Bob能夠收到，因此我們使用非對稱加密來達成，步驟如下：</p>
<ol>
<li>請Bob給我他的公鑰，即便公鑰被劫走也無妨</li>
<li>透過Bob給的公鑰加密我們要傳的訊息</li>
<li>傳給Bob加密後的文件</li>
<li><strong>只有持有私鑰的Bob有能力解密該文件</strong></li>
</ol>
<p>而區塊鏈驗證身分的方法恰恰與上面的例子相反，上面的例子是使用<strong>公鑰加密</strong> 而後再用<strong>私鑰解密</strong> 。</p>
<p>驗證身分則是透過私鑰把我們的交易紀錄加密，再讓外界使用公鑰解密看看，如果能夠以公鑰解密，就能夠確保這筆交易紀錄是公鑰持有人所簽核的，也就是使用<strong>私鑰加密交易紀錄</strong> 、再使用<strong>公鑰解密</strong> ，又稱之為<strong>數位簽章</strong> 。</p>
<h1 id="利用rsa加密產生公私鑰與地址"><a class="header" href="#利用rsa加密產生公私鑰與地址">利用RSA加密產生公、私鑰與地址</a></h1>
<p>在這裡我們使用RSA加密法隨機產生一對公私鑰，並且轉存成pkcs1形式：</p>
<pre><code>import rsa

def generate_address(self):
    public, private = rsa.newkeys(512)
    public_key = public.save_pkcs1()
    private_key = private.save_pkcs1()
    return self.get_address_from_public(public_key), private_key
</code></pre>
<p>我們的public_key(pkcs1)原本上的內容是這樣的</p>
<pre><code>b'-----BEGIN RSA PUBLIC KEY-----\n
MEgCQQCC+FnLB6c50HqIU1+xHmVr2ynahARbCc3/eRFLYSDeWKbVfvpMLnrKqm/qlmOy3QXjjr15ZNSQMO+Cnn0JvnohAgMBAAE=\n
-----END RSA PUBLIC KEY-----\n'
</code></pre>
<p>我們把其中一些不必要與重複的內容過濾掉，只留下中間有意義的部分：</p>
<pre><code>def get_address_from_public(self, public):
    address = str(public).replace('\\n','')
    address = address.replace("b'-----BEGIN RSA PUBLIC KEY-----", '')
    address = address.replace("-----END RSA PUBLIC KEY-----'", '')
    address = address.replace(' ', '')
    print('Address:', address)
    return address
</code></pre>
<p>濾完之後剩下的部分便是它的公鑰，這時候我們可以直接把它當作地址來使用！</p>
<blockquote>
<p>MEgCQQCC+FnLB6c50HqIU1+xHmVr2ynahARbCc3/eRFLYSDeWKbVfvpMLnrKqm/qlmOy3QXjjr15ZNSQMO+Cnn0JvnohAgMBAAE=</p>
</blockquote>
<p>這就是我們常看到在<a href="https://www.blockchain.com/explorer">Bitcoin</a>或<a href="https://etherscan.io/">Ethereum</a>上看到的一連串像是隨機位元組的地址由來了！</p>
<p>但到這裡你可能會有個疑問：產生的公私鑰/帳號會不會有重複的可能？ 答案是：會！但是機率~0<br />
這是密碼學中有名的生日碰撞問題(Birthday attack)，詳請可以參考<a href="http://www.qukuai.top/d/370">這裡</a>還有<a href="https://medium.com/myethacademy/%E9%8C%A2%E5%8C%85%E5%9C%B0%E5%9D%80%E6%9C%89%E6%A9%9F%E6%9C%83%E9%87%8D%E8%A4%87%E5%97%8E-be1a37337ba0">這裡</a></p>
<p>總而言之在區塊鏈接納這筆交易前，先試著用地址反推回原本的公鑰，再用公鑰解密當初這筆交易紀錄的簽章看看，如果公鑰解的開就可以代表是公鑰持有人本人所簽核的，這便是剛剛提到的"數位簽章"。</p>
<pre><code>def add_transaction(self, transaction, signature):
    public_key = '-----BEGIN RSA PUBLIC KEY-----\n'
    public_key += transaction.sender
    public_key += '\n-----END RSA PUBLIC KEY-----\n'
    public_key_pkcs = rsa.PublicKey.load_pkcs1(public_key.encode('utf-8'))
    transaction_str = self.transaction_to_string(transaction)
    if transaction.fee + transaction.amounts &gt; self.get_balance(transaction.sender):
        print("Balance not enough!")
        return False
    try:
        # 驗證發送者
        rsa.verify(transaction_str.encode('utf-8'), signature, public_key_pkcs)
        print("Authorized successfully!")
        self.pending_transactions.append(transaction)
        return True
    except Exception:
        print("RSA Verified wrong!")
</code></pre>
<h1 id="利用產生的公私鑰簽章後發送交易"><a class="header" href="#利用產生的公私鑰簽章後發送交易">利用產生的公私鑰簽章後發送交易</a></h1>
<p>產生公私鑰後，先透過<code>initialize_transaction</code>初始化一筆交易，這時候可以利用昨天寫好的<code>get_balance</code>函式先確定發送者的帳戶餘額是否足夠，初始化之後便可以透過<code>sign_transaction</code>簽署。</p>
<p><code>initialize_transaction</code>與<code>sign_transaction</code>這兩個動作都是在客戶的本地端做，以避免私鑰外洩的風險。簽署好之後使用<code>add_transaction</code>把交易紀錄與簽署發到鏈上去等待礦工確認，因為我們有簽署過，所以礦工使用公鑰對簽署解密便可以確認這筆交易的確是由我們發出的。</p>
<pre><code>def initialize_transaction(self, sender, receiver, amount, fee, message):
    if self.get_balance(sender) &lt; amount + fee:
        print("Balance not enough!")
        return False
    new_transaction = Transaction(sender, receiver, amount, fee, message)
    return new_transaction

def sign_transaction(self, transaction, private_key):
    private_key_pkcs = rsa.PrivateKey.load_pkcs1(private_key)
    transaction_str = self.transaction_to_string(transaction)
    signature = rsa.sign(transaction_str.encode('utf-8'), private_key_pkcs, 'SHA-1')
    return signature

def add_transaction(self, transaction, signature):
    public_key = '-----BEGIN RSA PUBLIC KEY-----\n'
    public_key += transaction.sender
    public_key += '\n-----END RSA PUBLIC KEY-----\n'
    public_key_pkcs = rsa.PublicKey.load_pkcs1(public_key.encode('utf-8'))
    transaction_str = self.transaction_to_string(transaction)
    if transaction.fee + transaction.amounts &gt; self.get_balance(transaction.sender):
        print("Balance not enough!")
        return False
    try:
        # 驗證發送者
        rsa.verify(transaction_str.encode('utf-8'), signature, public_key_pkcs)
        print("Authorized successfully!")
        self.pending_transactions.append(transaction)
        return True
    except Exception:
        print("RSA Verified wrong!")
</code></pre>
<p>因此實際使用上可以分成三個步驟</p>
<ol>
<li>初始化一筆交易紀錄</li>
<li>利用私鑰簽署這筆交易</li>
<li>送上鏈上等待礦工驗證與處理</li>
</ol>
<pre><code>address, private = block.generate_address()

# Step1: initialize a transaction
transaction = block.initialize_transaction(address, 'test123', 1, 1, 'Test')
if transaction:
    # Step2: Sign your transaction
    signature = block.sign_transaction(transaction, private)
    # Step3: Send it to blockchain
    block.add_transaction(transaction, signature)
</code></pre>
<h1 id="試著跑起整個鏈並發起交易"><a class="header" href="#試著跑起整個鏈並發起交易">試著跑起整個鏈並發起交易</a></h1>
<p>接著就可以跑起整條鏈了！首先先為我們自己開一個地址，接著創造創世塊。然後便可以不停地挖掘新區塊→調整難度→挖掘新區塊→調整難度→....周而復始，而且中間還可以發起交易！</p>
<pre><code>def start(self):
    address, private = self.generate_address()
    self.create_genesis_block()
    while(True):            
        # Step1: initialize a transaction
        transaction = block.initialize_transaction(address, 'test123', 1, 1, 'Test')
        if transaction:
            # Step2: Sign your transaction
            signature = block.sign_transaction(transaction, private)
            # Step3: Send it to blockchain
            block.add_transaction(transaction, signature)
        self.mine_block(address)
        print(self.get_balance(address))
        self.adjust_difficulty()
</code></pre>
<h1 id="今天的問題-2"><a class="header" href="#今天的問題-2">今天的問題</a></h1>
<p>但我們的區塊鏈還少了一個必要的東西：P2P網路，我們的區塊鏈沒辦法接收其他人的請求，只能在本機端跑，因此我們明天就會來透過通訊把我們的區塊鏈區分成：節點端(礦工端)與客戶端！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，至於今天程式碼則放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day05.py">這裡</a>。</p>
<h1 id="ref-3"><a class="header" href="#ref-3">Ref</a></h1>
<ul>
<li><a href="https://www.biboss.com/gonglue/84806.html">计算：虚拟币详细地址撞击几率</a></li>
<li><a href="https://medium.com/myethacademy/%E9%8C%A2%E5%8C%85%E5%9C%B0%E5%9D%80%E6%9C%89%E6%A9%9F%E6%9C%83%E9%87%8D%E8%A4%87%E5%97%8E-be1a37337ba0">錢包地址有機會重複嗎？</a></li>
<li><a href="https://blog.techbridge.cc/2017/04/16/simple-cryptography/">網路安全(1) - 基礎密碼學</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0">維基百科-數位簽章</a></li>
<li><a href="https://www.thenewslens.com/article/31591">不用數學，一張圖了解公鑰加密法原理</a></li>
<li><a href="https://www.twilio.com/blog/what-is-public-key-cryptography">What is Public Key Cryptography?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day06打造一個簡易的區塊鏈5節點與使用者的溝通"><a class="header" href="#day06打造一個簡易的區塊鏈5節點與使用者的溝通">Day06|打造一個簡易的區塊鏈(5)：節點與使用者的溝通</a></h1>
<h1 id="前置作業"><a class="header" href="#前置作業">前置作業</a></h1>
<p>我們今天的目標是模擬節點(礦工)端與使用者端的互動，節點端儲存了自創世塊以來的所有交易明細，同時也負責接受交易、打包交易至區塊、挖掘區塊、廣播挖掘到的區塊等等；而使用者端通常只會讀取鏈上的資料與發起交易，因為交易紀錄動輒數十GB起跳，為了效率與經濟的考量，使用者端通常不會儲存交易紀錄。</p>
<p>為了方便模擬我們把兩端的程式都跑在同一台電腦上，這裡選用的通訊方式是<code>socket</code>；也因為加入通訊後程式必須同時處理多樣的工作，所以使用<code>thread</code>來讓程式能夠順利執行監聽與挖礦這兩件事情。以下先就socket與thread做個簡單介紹後再開始。</p>
<h2 id="socket"><a class="header" href="#socket">Socket</a></h2>
<p>在UNIX系統下所有的I/O(輸入及輸出)都可以看做是file descriptors，因此socket就是利用<code>UNIX file descriptors</code>來與其他程式構通。它也同時提供了良好的介面與API，讓使用這可以在不具備網路底層知識的狀況下讓程式間透過網路進行溝通。一般而言socket主要可以分成下面兩種：</p>
<ol>
<li>Stream Socket</li>
<li>Datagram Sockets</li>
</ol>
<p>Stream Socket是利用TCP(Transmission Control Protocol)協定的傳輸，特色是會確保資料傳遞的完整性(不會東掉一個西掉一個)、次序性(誰先傳就會先到)，但缺點就是為了檢核傳遞的狀況，傳遞的延遲也較長。</p>
<p>Datagram Sockets是利用UDP(User Datagram Protocol)協定，不會去檢查資料的完整性、也無法保障傳地上的次序性，但因為節省了許多檢核的作業，傳遞的延遲非常短。</p>
<p>這裡因為我們需要保障資料傳遞的完整性，選用的是Stream Socket。這裡我們把區塊鏈區分成Server端與Client端，其中Server端負責處理Client連接後發出的訊息，並給予相對應的回饋；可以把Server看作是節點(礦工)端、Client看作是一般使用者。</p>
<h2 id="thread"><a class="header" href="#thread">Thread</a></h2>
<p>程式在運行時一般一次只能做一件事情，但我們的節點在打包交易與挖掘新區塊外同時也需要接收外界同步區塊或交易的請求，因此這裡我們導入<code>Thread</code>的概念讓我們的區塊鏈有能力同時處理不同工作。</p>
<p><code>Thread</code>又稱為執行緒，在理解上可以把單一程式(<code>Program</code>)開始運行並載入記憶體後看作是處理程序<code>Process</code>，常見的作業系統像是Windows或Linux等也可以看做是Process的載具，而且CPU每顆核心同時也只能進行一個Process的運算。</p>
<p>而Process則是Thread的載具，同一個<code>Process</code>裏頭可以同時運行許多<code>Thread</code>來達到同時處理不同工作的目的。下圖是作業系統、Process、Thread的大概運作架構。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day6_1.jpg" alt="Thread" /></p>
<p>但其實Process中的所有Thread並非是同時執行，只是Thread間以相當快的速度交錯執行讓人感受不到之間的延遲而已，就像是日光燈管每秒會因為交流電亮暗交錯60次但我們感覺不出一樣。</p>
<h2 id="bitcoin中也有用到socket與thread喔"><a class="header" href="#bitcoin中也有用到socket與thread喔">Bitcoin中也有用到Socket與Thread喔！</a></h2>
<p>以Bitcoin為例，中本聰一開始的版本也是使用socket與thread的概念來完成資料的接收與處理，有一個thread專門處理socket的連接，另一個thread專門處理接受後的資訊(<a href="https://en.bitcoin.it/wiki/Satoshi_Client_Sockets_and_Messages">來源</a>)。下面是bitcoin中使用到的socket與thread的原文介紹，大抵上而言跟我們等等要寫的節點架構相當類似！</p>
<blockquote>
<p>The original bitcoin client uses a multithreaded approach to socket handling and messages processing. There is one thread that handles socket communication (ThreadSocketHandler) and one (ThreadMessageHandler) which handles pulling messages off sockets and calling the processing routines.</p>
</blockquote>
<h1 id="節點與客戶端的功能"><a class="header" href="#節點與客戶端的功能">節點與客戶端的功能</a></h1>
<p>在這裡我們先簡單區分一下節點端與客戶端分別需要那些功能：</p>
<h2 id="節點的功能"><a class="header" href="#節點的功能">節點的功能</a></h2>
<p>節點的功能與我們之前所撰寫的並無差異，也就是需要：</p>
<ul>
<li>產生公私鑰(錢包地址)</li>
<li>儲存交易紀錄</li>
<li>確認帳戶餘額</li>
<li>驗證交易上面的數位簽章</li>
<li>打包交易並挖掘新區塊</li>
</ul>
<h3 id="使用者端的功能"><a class="header" href="#使用者端的功能">使用者端的功能</a></h3>
<p>使用者端至少需要能夠<strong>產生公私鑰</strong> 與<strong>簽署交易</strong> ，簡單說就是為了避免私鑰外洩的風險，所有跟私鑰有關的作業(產生公私鑰或簽署數位簽章時)通通都由使用者端完成，不需要仰賴外界或是將私鑰傳至節點即可完成。</p>
<ul>
<li>產生公私鑰(錢包地址)</li>
<li>向節點查詢資料</li>
<li>發起並簽署交易</li>
</ul>
<h1 id="節點端"><a class="header" href="#節點端">節點端</a></h1>
<p>在節點端這裡首先我們需要準備socket的端口讓外界可以連入，因為測試時節點端與使用者端都在本機上，所以IP地址給的是本機的<code>127.0.0.1</code>，至於Port則因為每一個節點所用的Port不同，因此在執行程式時再透過命令列的參數給定。</p>
<h2 id="準備socket連線的端口"><a class="header" href="#準備socket連線的端口">準備socket連線的端口</a></h2>
<pre><code>class BlockChain:
    def __init__(self):
        # For P2P connection
        self.socket_host = "127.0.0.1"
        self.socket_port = int(sys.argv[1])
        self.start_socket_server()
</code></pre>
<p>下圖是Socket的簡單運作流程，我們等待連接、接收資訊的步驟跟圖裡是一致的。</p>
<p><img src="images/day06_83735.jpg" alt="Socket" /><br />
圖片來源：<a href="https://realpython.com/python-sockets/">Socket Programming in Python (Guide)</a></p>
<h2 id="開thread監聽新連線與傳入訊息"><a class="header" href="#開thread監聽新連線與傳入訊息">開thread監聽新連線與傳入訊息</a></h2>
<p>為了在打包交易與挖礦的同時能夠接收外界的資訊，我們開一個thread在<code>bind</code>之後等待外界的新連線<code>s.accept()</code>，同時在每次新連線建立之後，又為每一個獨立的連線開一個thread去接收並且處理資訊。</p>
<pre><code>def start_socket_server(self):
    t = threading.Thread(target=self.wait_for_socket_connection)
    t.start()

def wait_for_socket_connection(self):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind((self.socket_host, self.socket_port))
        s.listen()
        while True:
            conn, address = s.accept()

            client_handler = threading.Thread(
                target=self.receive_socket_message,
                args=(conn, address)
            )
            client_handler.start()
</code></pre>
<h2 id="接收訊息後處理"><a class="header" href="#接收訊息後處理">接收訊息後處理</a></h2>
<p>這裡我們根據使用者傳遞過來的資料，判別使用者想要做</p>
<ol>
<li>取得帳戶餘額</li>
<li>發起交易</li>
</ol>
<p>並且根據使用者想做的事情分別去接收不同的參數，並且回傳結果給使用者。</p>
<pre><code>def receive_socket_message(self, connection, address):
    with connection:
        print(f'Connected by: {address}')
        while True:
            message = connection.recv(1024)
            print(f"[*] Received: {message}")
            try:
                parsed_message = pickle.loads(message)
            except Exception:
                print(f"{message} cannot be parsed")
            if message:
                if parsed_message["request"] == "get_balance":
                    print("Start to get the balance for client...")
                    address = parsed_message["address"]
                    balance = self.get_balance(address)
                    response = {
                        "address": address,
                        "balance": balance
                    }
                elif parsed_message["request"] == "transaction":
                    print("Start to transaction for client...")
                    new_transaction = parsed_message["data"]
                    result, result_message = self.add_transaction(
                        new_transaction,
                        parsed_message["signature"]
                    )
                    response = {
                        "result": result,
                        "result_message": result_message
                    }
                else:
                    response = {
                        "message": "Unknown command."
                    }
                response_bytes = str(response).encode('utf8')
                connection.sendall(response_bytes)
</code></pre>
<h2 id="啟動節點"><a class="header" href="#啟動節點">啟動節點</a></h2>
<p>完成上面接收並且處理資訊的過程後，便可以啟動節點、打包新交易、挖掘新區塊、調節難度，同時我們也可以根據外界的請求做相對應的處置。在這裡為了測試轉帳，我們同時產出一組礦工的公私鑰來使用(轉帳的前提是帳戶裡必須有足夠的餘額，在一開始也只有礦工有，因此我們只能用礦工的公私鑰來發起交易)。</p>
<pre><code>def start(self):
    address, private = self.generate_address()
    print(f"Miner address: {address}")
    print(f"Miner private: {private}")
    self.create_genesis_block()
    while(True):
        self.mine_block(address)
        self.adjust_difficulty()
</code></pre>
<h1 id="客戶端"><a class="header" href="#客戶端">客戶端</a></h1>
<p>客戶端這裡的工作相對單純，首先建立與節點間的socket聯繫，這裡節點的IP因為同在本地端因此也為<code>127.0.0.1</code>，節點端的Port的部分則在啟動程式碼時再帶入。之後就可以開一個Thread不停去接收socket傳過來的資訊。</p>
<h2 id="接收訊息"><a class="header" href="#接收訊息">接收訊息</a></h2>
<pre><code>def handle_receive():
    while True:
        response = client.recv(4096)
        if response:
            print(f"[*] Message from node: {response}")

if __name__ == "__main__":
    target_host = "127.0.0.1"
    target_port = int(sys.argv[1])
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((target_host, target_port))

    receive_handler = threading.Thread(target=handle_receive, args=())
    receive_handler.start()
</code></pre>
<h2 id="產生錢包地址與公私鑰"><a class="header" href="#產生錢包地址與公私鑰">產生錢包地址與公私鑰</a></h2>
<p>為了避免私鑰外洩，強烈建議公私鑰都在使用者的本地端產生，在利用RSA加密法產生一對鑰匙後，再把裏頭的前綴與後綴字濾掉後便是我們的公私鑰。比方說公鑰是：</p>
<blockquote>
<p>-----BEGIN PUBLIC KEY-----<br />
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANrG/HiSL6M41EaDsmpVKW+E4QZKaiW2<br />
KZD2RR7If7f9jMZiojoS1/uM0N6AQ2G8TUkPHjBuAnS1Dn4PJZAUysMCAwEAAQ==<br />
-----END PUBLIC KEY-----</p>
</blockquote>
<p>產生的地址便是</p>
<blockquote>
<p>MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANrG/HiSL6M41EaDsmpVKW+E4QZKaiW2<br />
KZD2RR7If7f9jMZiojoS1/uM0N6AQ2G8TUkPHjBuAnS1Dn4PJZAUysMCAwEAAQ==</p>
</blockquote>
<p>私鑰原本是：</p>
<blockquote>
<p>-----BEGIN RSA PRIVATE KEY-----<br />
MIIBOwIBAAJBANrG/HiSL6M41EaDsmpVKW+E4QZKaiW2KZD2RR7If7f9jMZiojoS<br />
1/uM0N6AQ2G8TUkPHjBuAnS1Dn4PJZAUysMCAwEAAQJBAKWsPHKd2X9UQMQpZQnK<br />
9fbifHmEDsACI5YIOK2oDbfo3mzW+gfxHtS1YVZz5TlymUAwm+qxBnwjTPEm+Jqn<br />
9ukCIQD1pl7vOofGdAiPBM0M2mJpOh7/b82XSCO/LCyRaP8pPwIhAOP+wxujrxRe<br />
BwzZmH6rqpKuuK2ueEVY/eVxpnHfaZl9AiAlT2mn6DnrGICcSFxkkV7VILDIl1Cg<br />
o6JaTPlP9KScvQIhAIMFft49XHnZ5zdNPMNep7GP0vWMk/VWROI8Q6ig+TCJAiBF<br />
ug2F+uZz3Gma5ySWBN49eH95o1PqYkDcoATkZ90skQ==<br />
-----END RSA PRIVATE KEY-----</p>
</blockquote>
<p>過濾後產生的私鑰便是：</p>
<blockquote>
<p>MIIBOwIBAAJBANrG/HiSL6M41EaDsmpVKW+E4QZKaiW2KZD2RR7If7f9jMZiojoS<br />
1/uM0N6AQ2G8TUkPHjBuAnS1Dn4PJZAUysMCAwEAAQJBAKWsPHKd2X9UQMQpZQnK<br />
9fbifHmEDsACI5YIOK2oDbfo3mzW+gfxHtS1YVZz5TlymUAwm+qxBnwjTPEm+Jqn<br />
9ukCIQD1pl7vOofGdAiPBM0M2mJpOh7/b82XSCO/LCyRaP8pPwIhAOP+wxujrxRe<br />
BwzZmH6rqpKuuK2ueEVY/eVxpnHfaZl9AiAlT2mn6DnrGICcSFxkkV7VILDIl1Cg<br />
o6JaTPlP9KScvQIhAIMFft49XHnZ5zdNPMNep7GP0vWMk/VWROI8Q6ig+TCJAiBF<br />
ug2F+uZz3Gma5ySWBN49eH95o1PqYkDcoATkZ90skQ==</p>
</blockquote>
<p>同時這裡的程式碼節點端也會用到喔!</p>
<pre><code>def generate_address():
    public, private = rsa.newkeys(512)
    public_key = public.save_pkcs1()
    private_key = private.save_pkcs1()
    return get_address_from_public(public_key), extract_from_private(private_key)

def get_address_from_public(public):
    address = str(public).replace('\\n','')
    address = address.replace("b'-----BEGIN RSA PUBLIC KEY-----", '')
    address = address.replace("-----END RSA PUBLIC KEY-----'", '')
    address = address.replace(' ', '')
    return address

def extract_from_private(private):
    private_key = str(private).replace('\\n','')
    private_key = private_key.replace("b'-----BEGIN RSA PRIVATE KEY-----", '')
    private_key = private_key.replace("-----END RSA PRIVATE KEY-----'", '')
    private_key = private_key.replace(' ', '')
    return private_key
</code></pre>
<h2 id="初始化交易"><a class="header" href="#初始化交易">初始化交易</a></h2>
<p>接著就可以來初始化一筆交易了！依序填入這筆交易的匯款方、收款方、匯款金額、手續費與備註後生成一筆交易。</p>
<pre><code>class Transaction:
    def __init__(self, sender, receiver, amounts, fee, message):
        self.sender = sender
        self.receiver = receiver
        self.amounts = amounts
        self.fee = fee
        self.message = message

def initialize_transaction(sender, receiver, amount, fee, message):
    # No need to check balance
    new_transaction = Transaction(sender, receiver, amount, fee, message)
    return new_transaction
</code></pre>
<h2 id="簽章交易"><a class="header" href="#簽章交易">簽章交易</a></h2>
<p>為了讓礦工驗證這筆交易的確是由我們親自發出的，因此發出去交易前我們先透過私鑰對交易的內容做簽署，完成後就得到這筆交易的數位簽章，礦工可以透過數位簽章確認是由我們發出的。</p>
<pre><code>def transaction_to_string(transaction):
    transaction_dict = {
        'sender': str(transaction.sender),
        'receiver': str(transaction.receiver),
        'amounts': transaction.amounts,
        'fee': transaction.fee,
        'message': transaction.message
    }
    return str(transaction_dict)

def sign_transaction(transaction, private):
    private_key = '-----BEGIN RSA PRIVATE KEY-----\n'
    private_key += private
    private_key += '\n-----END RSA PRIVATE KEY-----\n'
    private_key_pkcs = rsa.PrivateKey.load_pkcs1(private_key.encode('utf-8'))
    transaction_str = transaction_to_string(transaction)
    signature = rsa.sign(transaction_str.encode('utf-8'), private_key_pkcs, 'SHA-1')
    return signature
</code></pre>
<h2 id="控制流程"><a class="header" href="#控制流程">控制流程</a></h2>
<p>接著便是控制整個流程了！在使用者端總共有三件事情可以做：</p>
<ol>
<li>產生地址與公私鑰</li>
<li>向節點詢問帳戶的餘額</li>
<li>發起並簽署交易後送到節點端等待礦工確認與上鏈</li>
</ol>
<pre><code>if __name__ == "__main__":
    target_host = "127.0.0.1"
    target_port = int(sys.argv[1])
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((target_host, target_port))

    receive_handler = threading.Thread(target=handle_receive, args=())
    receive_handler.start()

    command_dict = {
        "1": "generate_address",
        "2": "get_balance",
        "3": "transaction"
    }

    while True:
        print("Command list:")
        print("1. generate_address")
        print("2. get_balance")
        print("3. transaction")
        command = input("Command: ")
        if str(command) not in command_dict.keys():
            print("Unknown command.")
            continue
        message = {
            "request": command_dict[str(command)]
        }
        if command_dict[str(command)] == "generate_address":
            address, private_key = generate_address()
            print(f"Address: {address}")
            print(f"Private key: {private_key}")

        elif command_dict[str(command)] == "get_balance":
            address = input("Address: ")
            message['address'] = address
            client.send(pickle.dumps(message))

        elif command_dict[str(command)] == "transaction":
            address = input("Address: ")
            private_key = input("Private_key: ")
            receiver = input("Receiver: ")
            amount = input("Amount: ")
            fee = input("Fee: ")
            comment = input("Comment: ")
            new_transaction = initialize_transaction(
                address, receiver, int(amount), int(fee), comment
            )
            signature = sign_transaction(new_transaction, private_key)
            message["data"] = new_transaction
            message["signature"] = signature

            client.send(pickle.dumps(message))

        else:
            print("Unknown command.")
        time.sleep(1)
</code></pre>
<h1 id="實際操作"><a class="header" href="#實際操作">實際操作</a></h1>
<h2 id="運行節點"><a class="header" href="#運行節點">運行節點</a></h2>
<p>首先透過<code>python 節點的py檔 port位置</code>指定節點端的port並啟動。</p>
<pre><code>python .\blockchain_server.py 1111
</code></pre>
<p><img src="https://www.lkm543.site/it_iron_man/day6_2.jpg" alt="Node" /></p>
<p>啟動後便可以看到礦工的公私鑰與挖掘中的情形，稍後我們就可以透過礦工的公私鑰來發起交易！</p>
<h2 id="運行使用者端"><a class="header" href="#運行使用者端">運行使用者端</a></h2>
<p>透過<code>python 用戶的py檔 port位置</code>指定欲連接的節點端port後啟動。</p>
<pre><code>python .\blockchain_client.py 1111
</code></pre>
<p>接著就可以看到選單，輸入1、2、3便可以執行相對應的工作。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day6_3.jpg" alt="Node" /></p>
<h2 id="創建新地址"><a class="header" href="#創建新地址">創建新地址</a></h2>
<p>輸入1後便可以透過RSA加密法得到一組公私鑰！</p>
<p><img src="https://www.lkm543.site/it_iron_man/day6_4.jpg" alt="Node" /></p>
<h2 id="查詢餘額"><a class="header" href="#查詢餘額">查詢餘額</a></h2>
<p>輸入2與要查詢的地址後便可以查詢該帳戶的餘額，這裡我們查詢礦工地址的餘額：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day6_5.jpg" alt="Node" /></p>
<p>發現裏頭現在有620元！</p>
<h2 id="發起交易"><a class="header" href="#發起交易">發起交易</a></h2>
<p>接著我們利用一開始產生礦工的公私鑰，轉移50元到我們自己的地址上，手續費給1元：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day6_6.jpg" alt="Node" /></p>
<h2 id="確認是否有收到"><a class="header" href="#確認是否有收到">確認是否有收到</a></h2>
<p>最後查閱我們被轉帳的帳戶裏頭是不是有出現50元。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day6_7.jpg" alt="Node" /></p>
<p>咦？怎麼還是0元？別緊張，這是因為我們的交易還沒被打包並且挖掘出來，稍微等新區塊被礦工挖掘出來後：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day6_8.jpg" alt="Node" /></p>
<p>順利收到50元！</p>
<p>今天的目標達成了：讓使用者可以查閱節點的資料、並透過數位簽章發起交易，但是我們的節點目前只有一個，似乎不是理想中的去中心化。因此明天的目標就是讓有意願的人也可以一起自由地加入節點紀錄並且挖掘新區塊，同時完成我們簡易區塊鏈的最後一步─去中心化。</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，至於今天節點端的程式碼放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day06_server.py">這裡</a>、使用者端的程式碼則放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day06_client.py">這裡</a>。</p>
<h1 id="ref-4"><a class="header" href="#ref-4">Ref:</a></h1>
<ul>
<li><a href="http://beej-zhtw.netdpi.net/02-what-is-socket">Beej's Guide to Network Programming 正體中文版</a></li>
<li><a href="https://en.bitcoin.it/wiki/Satoshi_Client_Sockets_and_Messages">Satoshi Client Sockets and Messages</a></li>
<li><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/360741/">Python基於socket實現簡單的即時通訊功能示例</a></li>
<li><a href="https://realpython.com/python-sockets/">Socket Programming in Python (Guide)</a></li>
<li><a href="http://zake7749.github.io/2015/03/17/SocketProgramming/">TCP Socket Programming 學習筆記</a></li>
<li><a href="http://ccckmit.wikidot.com/thread">Thread 的概念</a></li>
<li><a href="https://medium.com/@totoroLiu/program-process-thread-%E5%B7%AE%E7%95%B0-4a360c7345e5">Program/Process/Thread 差異</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day07打造一個簡易的區塊鏈6節點間的同步與廣播"><a class="header" href="#day07打造一個簡易的區塊鏈6節點間的同步與廣播">Day07|打造一個簡易的區塊鏈(6)：節點間的同步與廣播</a></h1>
<h1 id="節點的建置"><a class="header" href="#節點的建置">節點的建置</a></h1>
<p>我們昨天已經能夠讓使用者端與節點端彼此溝通，而且能夠讓使用者在不需要儲存所有交易明細的狀況下向節點查詢餘額或是發起交易，但我們的節點也只有一個，在這個狀況下其實運作方式跟傳統中心化的方式並無差異。</p>
<p>因此今天的目的是要讓外界的人可以自由加入節點的運作與挖掘新區塊，在這過程中也牽涉到區塊或交易的廣播(必須把收到的新資訊廣播給彼此，區塊鏈裡的資料才會一致)，這一步完成後我們的簡易區塊鏈也就大功告成了！</p>
<h2 id="同步區塊"><a class="header" href="#同步區塊">同步區塊</a></h2>
<p>為了與已經上線運作的區塊鏈同步，需要向已知的節點發起請求，要求節點將目前所有的資料都傳遞過來。因為我們選用的是Stream Socket，接收到的資料是連續的，為了避免資料流斷開因此直到讀到<code>len(response) % 4096</code>不為零才停止。(但其實會有Bug，但因為機率很小只有1/4096這裡先忽略)。接收到資料後就把目前鏈上的資料同步。</p>
<pre><code>def clone_blockchain(self, address):
    print(f"Start to clone blockchain by {address}")
    target_host = address.split(":")[0]
    target_port = int(address.split(":")[1])
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((target_host, target_port))
    message = {"request": "clone_blockchain"}
    client.send(pickle.dumps(message))
    response = b""
    print(f"Start to receive blockchain data by {address}")
    while True:
        response += client.recv(4096)
        if len(response) % 4096:
            break
    client.close()
    response = pickle.loads(response)["blockchain_data"]

    self.adjust_difficulty_blocks = response.adjust_difficulty_blocks
    self.difficulty = response.difficulty
    self.block_time = response.block_time
    self.miner_rewards = response.miner_rewards
    self.block_limitation = response.block_limitation
    self.chain = response.chain
    self.pending_transactions = response.pending_transactions
    self.node_address.update(response.node_address)
</code></pre>
<p>實務上也是如此，你可以到<a href="https://bitnodes.earn.com/nodes/?q=Satoshi:0.18.0">這裡</a>查閱Bitcoin所有節點的資料，並且向這些節點發出請求！</p>
<h2 id="接受並判別訊息"><a class="header" href="#接受並判別訊息">接受並判別訊息</a></h2>
<p>接收資訊那裏，我們也需要新增收到其他節點的資訊後應該要做的處置，分別有下面四種：</p>
<ol>
<li>接收到同步區塊的請求─把目前的區塊鏈上的資料都dump一份給對方</li>
<li>接收到挖掘出的新區塊─確認是否有符合Hash的規則，有的話就把它加入鏈上，改挖掘下一區塊</li>
<li>接收到廣播的交易─把交易置入等待中的交易<code>pending_transactions</code></li>
<li>接收到新增節點的請求─把位置加到之後要廣播的清單中</li>
</ol>
<pre><code># 接收到同步區塊的請求
elif parsed_message["request"] == "clone_blockchain":
    print(f"[*] Receive blockchain clone request by {address}...")
    message = {
        "request": "upload_blockchain",
        "blockchain_data": self
    }
    connection.sendall(pickle.dumps(message))
    continue
# 接收到挖掘出的新區塊
elif parsed_message["request"] == "broadcast_block":
    print(f"[*] Receive block broadcast by {address}...")
    self.receive_broadcast_block(parsed_message["data"])
    continue
# 接收到廣播的交易
elif parsed_message["request"] == "broadcast_transaction":
    print(f"[*] Receive transaction broadcast by {address}...")
    self.pending_transactions.append(parsed_message["data"])
    continue
# 接收到新增節點的請求
elif parsed_message["request"] == "add_node":
    print(f"[*] Receive add_node broadcast by {address}...")
    self.node_address.add(parsed_message["data"])
    continue
</code></pre>
<h2 id="接收並驗證廣播的區塊"><a class="header" href="#接收並驗證廣播的區塊">接收並驗證廣播的區塊</a></h2>
<p>一旦接收到新區塊，必須對區塊的內容與哈希加以驗證，確認資料格式是正確的！同時也要把裏頭被打包好的交易從自身等待中的交易<code>pending_transactions</code>移除，否則該筆交易就會被執行兩次！</p>
<pre><code>def receive_broadcast_block(self, block_data):
    last_block = self.chain[-1]
    # Check the hash of received block
    if block_data.previous_hash != last_block.hash:
        print("[**] Received block error: Previous hash not matched!")
        return False
    elif block_data.difficulty != self.difficulty:
        print("[**] Received block error: Difficulty not matched!")
        return False
    elif block_data.hash != self.get_hash(block_data, block_data.nonce):
        print(block_data.hash)
        print("[**] Received block error: Hash calculation not matched!")
        return False
    else:
        if block_data.hash[0: self.difficulty] == '0' * self.difficulty:
            for transaction in block_data.transactions:
                self.chain.remove(transaction)
            self.receive_verified_block = True
            self.chain.append(block_data)
            return True
        else:
            print(f"[**] Received block error: Hash not matched by diff!")
            return False
</code></pre>
<h2 id="如果廣播的區塊驗證通過改挖掘下一塊"><a class="header" href="#如果廣播的區塊驗證通過改挖掘下一塊">如果廣播的區塊驗證通過，改挖掘下一塊</a></h2>
<p>如果通過上一步的驗證，則本地端的挖掘工作必須暫停，直接挖掘下一個新區塊。在這裡我們也修改nonce的產生方式，不再是統一由1開始逐漸+1，否則永遠都會是算力最高的節點會挖到。</p>
<pre><code>def mine_block(self, miner):
    start = time.process_time()

    last_block = self.chain[-1]
    new_block = Block(last_block.hash, self.difficulty, miner, self.miner_rewards)

    self.add_transaction_to_block(new_block)
    new_block.previous_hash = last_block.hash
    new_block.difficulty = self.difficulty
    new_block.hash = self.get_hash(new_block, new_block.nonce)
    new_block.nonce = random.getrandbits(32)

    while new_block.hash[0: self.difficulty] != '0' * self.difficulty:
        new_block.nonce += 1
        new_block.hash = self.get_hash(new_block, new_block.nonce)
        if self.receive_verified_block:
            print(f"[**] Verified received block. Mine next!")
            self.receive_verified_block = False
            return False

    self.broadcast_block(new_block)

    time_consumed = round(time.process_time() - start, 5)
    print(f"Hash: {new_block.hash} @ diff {self.difficulty}; {time_consumed}s")
    self.chain.append(new_block)
</code></pre>
<h2 id="挖掘到新區塊廣播給其他節點"><a class="header" href="#挖掘到新區塊廣播給其他節點">挖掘到新區塊，廣播給其他節點</a></h2>
<p>如果是自身挖到新區塊的話，就要把這個新區塊廣播給其他節點囉！</p>
<pre><code>def broadcast_block(self, new_block):
    self.broadcast_message_to_nodes("broadcast_block", new_block)

def broadcast_message_to_nodes(self, request, data=None):
    address_concat = self.socket_host + ":" + str(self.socket_port)
    message = {
        "request": request,
        "data": data
    }
    for node_address in self.node_address:
        if node_address != address_concat:
            target_host = node_address.split(":")[0]
            target_port = int(node_address.split(":")[1])
            client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            client.connect((target_host, target_port))
            client.sendall(pickle.dumps(message))
            client.close()
</code></pre>
<h2 id="執行我們的區塊鏈與雙節點"><a class="header" href="#執行我們的區塊鏈與雙節點">執行我們的區塊鏈與雙節點</a></h2>
<p>首先我們運行第一個節點，並指明它的port為1111</p>
<blockquote>
<p>python .\Blockchain.py 1111</p>
</blockquote>
<p>接著可以運行第二個節點，並指明它的port為1112、請它去連接與同步127.0.0.1:1111。</p>
<blockquote>
<p>python .\Blockchain.py 1112 127.0.0.1:1111</p>
</blockquote>
<p>接著就可以看到兩邊不停地交換挖掘到的新區塊了！</p>
<p><img src="https://www.lkm543.site/it_iron_man/day7_1.JPG" alt="Demo" /></p>
<h1 id="現實中的網路"><a class="header" href="#現實中的網路">現實中的網路</a></h1>
<p>雖然我們透過socket來模擬現實網路的通訊，但與真正的網路還是有些差距，以下稍微敘述一下其中較大的差異與挑戰，我們之後會再有幾天專門介紹網路的相關資訊(特別是P2P的網路)，在加入網路後，更多問題會接踵而來：網路延遲如何處理？共識如何決定、分岔等等的。</p>
<h2 id="網路的延遲"><a class="header" href="#網路的延遲">網路的延遲</a></h2>
<p>在網路交換訊息的過程中延遲是不可避免的，也就是自廣播到接收會有一段時間落差、甚至資訊的遺失，這些落差與資訊遺失會造成礦工間的異議與區塊鏈的分岔，分岔的產生主要有兩種原因：</p>
<ol>
<li>沒有完整收到別人廣播的區塊，自然就會繼續自己挖自己的而跟其他節點脫節</li>
<li>在區塊傳播過程中恰巧自己剛好挖到新區塊！</li>
</ol>
<p>分岔產生後就像下圖一樣：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day7_2.jpg" alt="Fork Demo" /></p>
<p>因此我們之後也會需要來探討如何融合礦工間的異議！</p>
<h2 id="節點不全然可信reliable"><a class="header" href="#節點不全然可信reliable">節點不全然可信(reliable)</a></h2>
<p>真實世界中的節點不全然是可信的，攻擊者可能會混入節點或帳戶的行列之中對外界發出錯誤的訊息，這種攻擊方式又稱為<a href="https://www.binance.vision/zt/security/sybil-attacks-explained">女巫攻擊(Sybil Attack)</a>。為了避免假節點與帳戶混充，因此我們需要求得節點間的共識，也需要了解在何種狀況下才能保障區塊鏈免受女巫攻擊的威脅。</p>
<h1 id="完成簡易的區塊鏈了"><a class="header" href="#完成簡易的區塊鏈了">完成簡易的區塊鏈了！</a></h1>
<p>到目前為止，我們第一部分─打造一個簡易的區塊鏈就完成了喔！但其實我們的區塊鏈還是有很多不足的地方，比方說無法處理以下這些事情：</p>
<ol>
<li>預期外的輸入、例外處理</li>
<li>單獨驗證過去的某一筆交易</li>
<li>要求同步特定的區塊</li>
<li>在上面發行代幣</li>
<li>進行多重簽名等交易</li>
<li>分岔的處理</li>
</ol>
<p>但至少我們這幾天透過一步步刻出一個簡單的區塊鏈而確定在這裡頭有三個必備的知識領域：</p>
<ol>
<li>密碼學(Hash與非對稱式加密)</li>
<li>挖礦演算法</li>
<li>P2P網路與共識</li>
</ol>
<p>在簡易應用後也需要把我們的基礎知識補足才能持續優化區塊鏈，因此明天後我們會來逐步探討與研究這三個領域！最後幾天有時間的話再來研究一下區塊鏈的發展方向與這兩年很夯的智能合約！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，今天節點端的程式碼放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day07.py">這裡</a>。</p>
<h1 id="ref-5"><a class="header" href="#ref-5">Ref:</a></h1>
<ul>
<li><a href="https://blog.gtwang.org/web-development/network-lantency-and-bandwidth/">網路的延遲（Latency）與頻寬（Bandwidth）是什麼？</a></li>
<li><a href="https://kknews.cc/zh-tw/tech/r3o6vnv.html">區塊鏈的冷暖系列之：數據同步技術的鬼畜型圖解</a></li>
<li><a href="https://www.binance.vision/zt/security/sybil-attacks-explained">女巫攻擊(Sybil Attack)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day08密碼學初探1編碼與壓縮"><a class="header" href="#day08密碼學初探1編碼與壓縮">Day08|密碼學初探(1)：編碼與壓縮</a></h1>
<h1 id="密碼學"><a class="header" href="#密碼學">密碼學</a></h1>
<p>密碼學(Cryptography)一詞的英文來自兩個古希臘詞彙kryptós(隱藏的)和gráphein(書寫)，因此古典密碼學主要著重在<strong>資訊傳遞</strong> 與<strong>保密</strong> ，隨著資訊的進步也衍伸出各種不同的加密形式以確保資料傳遞時的安全，比方說Https與SSL等，都是密碼學在網路技術上的應用以確保我們平時上網的資訊與足跡不至於洩漏。</p>
<p>在討論密碼學之前我們先從四個最基本的名詞介紹起，分別是：</p>
<ol>
<li>編碼</li>
<li>壓縮</li>
<li>哈希(湊雜)</li>
<li>加密</li>
</ol>
<p>區塊鏈使用到大量加密的技術，因此前面三個(編碼、壓縮、哈希)我們只會簡單提到它們的功能與應用，到了加密才會研究演算法是如何被實作出來的。今天我們先介紹其中兩個：<strong>編碼</strong> 與<strong>壓縮</strong></p>
<h1 id="編碼"><a class="header" href="#編碼">編碼</a></h1>
<p>對於電腦而言是只有0與1的存在，每個0或1就是一個bit(位元)，8個0或1組合起來便是一個bytes(位元組)，除了0與1外其他一概不認。但這樣會造成使用上非常地不便，於是我們就把0與1加以編碼，規定了每一組0跟1分別代表的字元，最有名的編碼表莫過於Ascii碼表，Ascii碼表的編碼單位是位元組，每個獨立的位元組都可以透過Ascii碼表轉換成一種字元，在古早的時代拿來做資訊交換或排版的工具。</p>
<p><img src="images/day08_62303.png" alt="Ascii Table" /><br />
圖片來源：<a href="https://upload.wikimedia.org/wikipedia/commons/2/26/Ascii-codes-table.png">commons wikimedia</a></p>
<p>比方說我們要跟對方說Hi，透過這張表，我們會把大寫H轉換成72、小寫i轉換成105，同時這兩個的位元組分別是01001000(H)、01101001(i)，實際上我們電腦傳給對方電腦的是01001000、01101001這兩個位元組。<br />
<img src="https://www.lkm543.site/it_iron_man/day8_1.jpg" alt="Encode" /></p>
<p>所以編碼又可以看做是資料間的轉換。而且因為編碼通常兩邊、甚至第三方都有同一張表格，彼此也都知道轉換方式，編碼的目的往往是<strong>希望資料能夠被順利傳遞與解讀</strong> ，為了傳遞效率的考量，通常編碼的研究著重在如何編碼所耗去的資料空間較小與避免轉碼出錯上。</p>
<h2 id="亂碼"><a class="header" href="#亂碼">亂碼</a></h2>
<p>如果傳遞資訊方編碼(Encode)與接收資訊方解碼(decode)使用的表格不同，就會造成亂碼的情形。</p>
<h2 id="big5與utf-8"><a class="header" href="#big5與utf-8">Big5與UTF-8</a></h2>
<p>過去瀏覽外國網站時常常有亂碼的出現，UTF-8的出現解決了這個問題，它把世界上所有語言與各種奇形怪狀的符號通通編碼進去，也因為編入的字體多很多，因此UTF-8使用的空間較大(一至四個位元組)為每個字元編碼(相較於Ascii碼表只需要一個Bytes就可以完成)。</p>
<p>而有些中文字的編碼是使用Big5編碼，讓每個中文字使用2bytes。</p>
<h2 id="編碼的其他應用"><a class="header" href="#編碼的其他應用">編碼的其他應用</a></h2>
<p>除了文字的轉換外，常見的jpg、mp4等圖片影音轉檔等也都是常見編碼的應用，透過把資料編碼達到<strong>資訊傳遞</strong> 的效果。</p>
<h1 id="壓縮"><a class="header" href="#壓縮">壓縮</a></h1>
<p>壓縮的目的是將原始的檔案資料經過數學演算法重新計算、編排或編碼後，達到<strong>所需儲存空間減少</strong> 的功能，最知名的壓縮軟體莫過於大家都用過<del>但從不付錢的</del><a href="https://rar.tw/">WINRAR</a>，就像斯斯有兩種一樣，壓縮演算法也可以大概分類成兩種：失真壓縮與無失真壓縮。</p>
<h2 id="無失真壓縮"><a class="header" href="#無失真壓縮">無失真壓縮</a></h2>
<p>無失真壓縮代表資料及便經過壓縮後，也可以<strong>解壓縮回跟原本完全一模一樣</strong> 的資料。通常適用在<strong>文字或數據</strong> 的傳地上，畢竟這樣的資料是不允許任何小瑕疵或更動的，但也因為必須保持資料的一致性，壓縮率通常會比較低，所以如果壓縮一份普通的純文字檔，通常會發現壓縮率不甚理想。</p>
<p>下面這張圖展示的是圖片的無失真壓縮，左上角的Bitmap表示的是原始資料未經過壓縮，共需要696KB，經過JPEG壓縮之後僅僅需要43.3KB的空間儲存，這也是為什麼通常我們下載下來的檔案格式通常是jpeg了！(<a href="https://homepages.cae.wisc.edu/~ece533/project/f06/aguilera_rpt.pdf">資料來源</a>)</p>
<p><img src="https://www.lkm543.site/it_iron_man/day8_2.jpg" alt="Lossless Compression" /></p>
<h2 id="失真壓縮"><a class="header" href="#失真壓縮">失真壓縮</a></h2>
<p>失真壓縮指的是資料經過壓縮後<strong>無法解壓縮回原本的資料</strong> ，會有部分的失真或偏移，通常應用在<strong>影像或是聲音</strong> 的壓縮上，因為這類的資料極便產生了微小的偏移，對大部分人的觀賞還是不會產生很大的影響(專業的玩家使用的就是無失真壓縮了)。失真壓縮的好處是可以根據需要的品質與空間大小輸出成相對應大小的檔案，這在網頁的瀏覽體驗非常重要，網頁的資源通常80%以上都是圖片，原始碼是文字格式所以占用的空間不大，因此圖片的壓縮對於網頁的瀏覽速度非常重要。</p>
<p>下面展示的是圖片的失真壓縮，可以看到隨著需求品質的下降，所需的儲存大小也跟著下降。(<a href="https://homepages.cae.wisc.edu/~ece533/project/f06/aguilera_rpt.pdf">資料來源</a>)<br />
<img src="https://www.lkm543.site/it_iron_man/day8_3.jpg" alt="Loss Compression" /></p>
<h2 id="霍夫曼hoffman編碼"><a class="header" href="#霍夫曼hoffman編碼">霍夫曼(Hoffman)編碼</a></h2>
<p>至於怎麼做到壓縮的呢?以最知名、最入門的壓縮演算法─霍夫曼(Hoffman)編碼為例，想法概念就是把<strong>最常見、出現頻率最高的資料用最小的空間去轉存或重新編碼</strong> 。</p>
<p>舉例來說我們現在有段文字需要壓縮，這段文字如下</p>
<blockquote>
<p>ABCADBDDDADBDA</p>
</blockquote>
<p>如果我們任意編碼成下面格式</p>
<blockquote>
<p>A：00、B、01、C：10、D：11</p>
</blockquote>
<p>那麼我們總共需要28 bits的儲存空間，你可能會有一個疑問為什麼不能用一個位元去編碼呢？像是：</p>
<blockquote>
<p>A：0、B、1、C：00、D：01</p>
</blockquote>
<p>因為這樣的話如果你收到01，那麼根本不知道要解成A(0)B(1)、或是D(01)！所以我們在編碼的過程也必須考慮是否能順利解碼，以剛剛的編碼格式為例，因為每兩個位元都是一組編碼，所以我們可以兩兩一組很順利的把編碼解出來。</p>
<p>那霍夫曼編碼是怎麼做的呢？首先我們先計算每個文字出現的頻率：A→4次、B→3次、C→1次、D→6次，因為D產生最多次、我們透過二元樹編給它</p>
<p><img src="https://www.lkm543.site/it_iron_man/day8_4.jpg" alt="Hoffman" /></p>
<blockquote>
<p>D：0、A：10、C：110、B、111</p>
</blockquote>
<p>於是原本的資料就可以壓縮成</p>
<blockquote>
<p>10111110100111000100111010</p>
</blockquote>
<p>壓縮後的資料僅需要26 bits便可以儲存！至於詳細的實作可以參考<a href="https://xken831.pixnet.net/blog/post/459581308-%E9%9C%8D%E5%A4%AB%E6%9B%BC%28huffman%29%E6%A8%B9-~%E8%B3%87%E6%96%99%E5%A3%93%E7%B8%AE~">這裡</a>。<br />
解碼的過程也是透過二元樹去解碼，從最開頭去解碼，直到解出最底層的頁節點為止，也因此在我們這個例子的編碼中並沒有編入1、01、00、01這幾種編碼，這是為了解碼時能夠順利被解碼出唯一一組解。</p>
<p>你也可以發現霍夫曼是透過改善編碼的方式來達到壓縮資料的目的，採取的作法是一個個字詞單一去處理，直到後來已經慢慢被<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E7%BC%96%E7%A0%81">算術編碼</a>所取代， <em>算術編碼是直接把整個輸入的訊息編碼為一個數</em> ，有興趣實做的話可以參考<a href="https://par.cse.nsysu.edu.tw/~homework/algo01/8934609/index.html">這裡</a>。</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-6"><a class="header" href="#ref-6">Ref:</a></h1>
<ul>
<li><a href="https://speakerdeck.com/inndy/no-more-crypto-fails">No More Crypto Fails</a></li>
<li><a href="http://140.125.45.29/courses/files/network%20security/network%20security%20ch%202.pdf">Chapter 2: 密碼學基礎</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6">維基百科-密碼學</a></li>
<li><a href="http://www.voidcn.com/article/p-knocnmhy-uo.html">Hoffman 编码</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day09密碼學初探2哈希湊雜"><a class="header" href="#day09密碼學初探2哈希湊雜">Day09|密碼學初探(2)：哈希(湊雜)</a></h1>
<p>我們昨天提到了四個下面名詞，並且已經解釋完編碼與壓縮：</p>
<ol>
<li>編碼</li>
<li>壓縮</li>
<li>哈希(湊雜)</li>
<li>加密</li>
</ol>
<p>在正式進入密碼學之前我們接著介紹：<strong>哈希</strong></p>
<h1 id="哈希湊雜"><a class="header" href="#哈希湊雜">哈希(湊雜)</a></h1>
<p>我們在<a href="https://ithelp.ithome.com.tw/articles/10215088">Day03|打造一個簡易的區塊鏈(2)：產生創世塊與挖掘新區塊</a>中有稍微介紹一下哈希數：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day3_1.jpg" alt="Hash" /></p>
<p>簡而言之哈希可以把<strong>任意長度的輸入轉換成固定長度的輸出，而且無法被逆轉換</strong> ，跟昨天我們提到的編碼做比較：編碼可以完全轉換回原本的詞彙，但是哈希不行，<strong>哈希數的轉換是單向的</strong> ！</p>
<h2 id="哈希在區塊鏈上的功能"><a class="header" href="#哈希在區塊鏈上的功能">哈希在區塊鏈上的功能</a></h2>
<h3 id="工作量證明proof-of-workpow"><a class="header" href="#工作量證明proof-of-workpow">工作量證明(Proof of Work，POW)</a></h3>
<p>回憶一下我們之前是這樣挖掘新區塊的：透過不斷修改nonce值後重新計算hash數，直到我們找出來的hash數符合當下的難度為止。</p>
<pre><code>while new_block.hash[0: self.difficulty] != '0' * self.difficulty:
    new_block.nonce += 1
    new_block.hash = self.get_hash(new_block, new_block.nonce)
</code></pre>
<p>利用哈希函數的單向性，讓礦工只能不停地去產生新的輸入(<code>nonce</code>)後，期望能夠找到一個能夠符合的解；並無法透過已知的難度去反推符合的nonce值。</p>
<h3 id="驗證區塊"><a class="header" href="#驗證區塊">驗證區塊</a></h3>
<p>因為哈希函式單向轉換的特性，我們可以把區塊哈希數生成的其中一個參數仰賴於前一個區塊，像鎖鏈般把所有區塊結合在一起(回憶一下之前出現過的下圖)，這樣只要某一個區塊被攻擊或竄改，透過很快的計算哈希數與驗證，我們就可以輕易揪出是哪個區塊被攻擊了！而且因為工作量證明(POW)的機制，如果攻擊者想要重新計算哈希鏈來讓驗證可以通過，因為哈希函式單向運算的保障，攻擊者需要耗費龐大的運算資源才能做到。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day2_3.jpg" alt="Hash Chain" /></p>
<p>回憶一下我們之前可以這樣驗證鏈上的資料是否有被竄改過：</p>
<pre><code>def verify_blockchain(self):
    previous_hash = ''
    for idx,block in enumerate(self.chain):
        if self.get_hash(block, block.nonce) != block.hash:
            print("Error:Hash not matched!")
            return False
        elif previous_hash != block.previous_hash and idx:
            print("Error:Hash not matched to previous_hash")
            return False
        previous_hash = block.hash
    print("Hash correct!")
    return True
</code></pre>
<h3 id="驗證單筆交易"><a class="header" href="#驗證單筆交易">驗證單筆交易</a></h3>
<p>為了驗證單筆交易的真偽，我們可以把該筆交易的明細也透過哈希函式轉換成一個哈希數，接著只要向節點索取區塊內的交易哈希數便可以驗證該筆交易的真偽，而不需要向節點同步所有資料。關於如何改進單筆交易的驗證效率，我們之後提到Merkle Tree時會更進一步地說明Bitcoin的交易驗證機制。</p>
<h2 id="哈希的其他功能"><a class="header" href="#哈希的其他功能">哈希的其他功能</a></h2>
<p>除了區塊鏈之外，在電腦科學的領域中也會大量使用到哈希函式。</p>
<h3 id="確保下載的資料沒有被竄改"><a class="header" href="#確保下載的資料沒有被竄改">確保下載的資料沒有被竄改</a></h3>
<p><img src="https://www.lkm543.site/it_iron_man/day9_1.jpg" alt="Ubuntu Hash" /></p>
<p>網路上我們常常會互傳檔案，或是直接從網站上把資料下載下來，於是有心人士可以故意把惡意軟體包裝成正常軟體供人在網路上流傳，為了避免這類事情發生，開發者可以把軟體事先利用哈希函式轉換出一個哈希數：</p>
<blockquote>
<p>f800c84a4fac2ee698d1b8ec49c3c6dd13c3cca4</p>
</blockquote>
<p>如此一來如果有人造假軟體在其他地方流傳，它所提供的檔案算出來的哈希數就會是不同的哈希數，像是：</p>
<blockquote>
<p>ea010ee53036c72c7932dad62065a292f3226bf5</p>
</blockquote>
<p>於是就可以很輕易的被發現這個檔案是被造假過，並非原始檔案。例如你可以到<a href="https://releases.ubuntu.com/bionic/">Ubuntu的下載頁面</a>，會發現許多MD5、SHA開頭的檔案：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day9_2.jpg" alt="Ubuntu Hash" /></p>
<p>要檢測/驗證的話，可以到<a href="https://briian.com/6457/">這裡</a>下載檢測器，或是到<a href="https://vitux.com/how-to-verify-download-in-ubuntu-with-sha256-hash-gpg-key/">這裡</a>有完整的驗證教學。</p>
<h3 id="保護原始資料"><a class="header" href="#保護原始資料">保護原始資料</a></h3>
<p>平時登入網站所使用的帳號密碼都應該要被網站管理者好好保存，其中一個必備的條件是：密碼的儲存永遠不該是明文儲存，如果以明文儲存的話一旦資料庫被竊取則所有使用者的密碼都會被看光光，然後通常....大部分使用者在各個網站使用的密碼都是一樣的，所以一旦資料庫被竊取，駭客便可以輕鬆地拿著竊取到的帳號跟密碼到各個網站去登入了。</p>
<p>比方說我們的密碼如果是 <em>a1Sna6!g2</em> ，那麼<strong>網站的資料庫永遠不應該直接儲存明文</strong> <em>a1Sna6!g2</em> ！</p>
<p>而是儲存透過哈希函式像是SHA-256轉換出的哈希數，像是</p>
<blockquote>
<p>7e5a1428400e9c5576ef9ff7538ee6257ebecaede29d5e0bd48237f5ef05cd1d</p>
</blockquote>
<p>把這段文字儲存進資料庫裏頭，即便資料庫被竊取，駭客手上也只能拿到這段加密後的文字，也無法得知原本的密碼是多少。你可能會有個疑問，那麼我要怎麼驗證使用者輸入的密碼就是當初的密碼呢？其實我們只要再次把使用者登入當下輸入的密碼再轉換一次哈希數，如果轉出來的哈希數一樣，幾乎就可以代表使用者輸入的是正確的密碼了(還記得不同輸入值，輸出成同一個哈希數的機率~0嗎?)！</p>
<p>不過因為通常哈希數都會遠遠比使用者的密碼還長，所以網路上也很多利用常見的文字或密碼轉換出哈希數後再記錄下來的資料庫，例如你可以在<a href="https://hashkiller.co.uk/Cracker/MD5">這個網站</a>輸入MD5的值，它會幫你找是否有相對應的原始資料存在。如果你輸入下面這個MD5密文：</p>
<blockquote>
<p>827ccb0eea8a706c4c34a16891f84e7b</p>
</blockquote>
<p>你會發現轉出來是12345，因為12345太多人用啦！所以本身密碼的複雜度也是相當重要！另一個小技巧是加鹽：</p>
<p><img src="images/day09_71613.jpg" alt="Salt" /><br />
圖片來源：<a href="https://imgur.com/">imgur圖床</a></p>
<p>喔，不是這種加鹽。密碼學中的加鹽(salt)指的是在把使用者的密碼轉換成密文前多做一些小改變，比如說我們在使用者輸入的密碼前後各加上!a!，變成!a!12345!a!再丟進去算哈希，算出來的哈希數就會完全不一樣了！變成：</p>
<blockquote>
<p>5b839893d2ad60d14de1102151f0381d</p>
</blockquote>
<p>就可以發現即便使用者用一個很簡單的密碼，經過我們的加鹽之後，在<a href="https://hashkiller.co.uk/Cracker/MD5">這個網站</a>又解不出來了，於是使用者的密碼又多一層保障！</p>
<h3 id="哈希表hash-table"><a class="header" href="#哈希表hash-table">哈希表(Hash Table)</a></h3>
<p><img src="images/day09_79983.png" alt="Hash table" /><br />
圖片來源：<a href="https://en.wikipedia.org/wiki/Hash_table">維基百科</a></p>
<p>如果你有學過演算法的話<del>這裡就可以跳過</del> ，打個比方來說，Facebook上頭假設有100億個帳號(畢竟現在網軍或分身氾濫)，如果帳號密碼是用陣列儲存的話，那麼我們每次登入都要從第一個帳號往下找直到找到我們的帳號對應到的密碼為止，平均要找50億次，很明顯的效率不佳。</p>
<p>而哈希函數可以幫助你直接把使用者的帳號轉換成一個數字，這個數字就代表它在陣列中的索引值，因此就不需要一個個往下找了！關於哈希表的詳情可以參考<a href="https://blog.techbridge.cc/2017/01/21/simple-hash-table-intro/">這裡</a>。</p>
<h2 id="自製一個簡單的哈希函式"><a class="header" href="#自製一個簡單的哈希函式">自製一個簡單的哈希函式</a></h2>
<p>我們簡單製作一個哈希函式，這裡我們哈希函式的定義與步驟是：</p>
<ol>
<li>哈希數從512開始</li>
<li>哈希數乘上逐個字元的ascii碼</li>
<li>哈希數加上3</li>
<li>哈希數除以1024取餘數</li>
<li>重複步驟2~4直到每個字元都處理完</li>
<li>哈希數乘上字串長度</li>
<li>哈希數除以1024取餘數</li>
</ol>
<pre><code>def hash(input):
    hash_number = 512
    for char in input:
        hash_number *= ord(char)
        hash_number += 3
        hash_number %= 1024
    hash_number *= len(input)
    hash_number %= 1024
    return hash_number

if __name__ == "__main__":
    print(hash("Hello World!"))
    print(hash("Bill Gates"))
    print(hash("100000000"))
</code></pre>
<p>於是三種字串的輸入"Hello World!"、"Bill Gates"、"100000000"，分別會得到哈希數280、610、43了！而且哈希數280、610、43並沒有辦法反推回原本的輸入！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，今天哈希函式的程式碼放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day09.py">這裡</a>。</p>
<h1 id="ref-7"><a class="header" href="#ref-7">Ref:</a></h1>
<ul>
<li><a href="http://www.tsnien.idv.tw/Security_WebBook/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E9%9B%9C%E6%B9%8A%E8%88%87%E4%BA%82%E6%95%B8%E6%BC%94%E7%AE%97%E6%B3%95.html">資訊與網路安全概論-粘添壽</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">維基百科-雜湊函式</a></li>
<li><a href="https://blockgeeks.com/guides/what-is-hashing/">What Is Hashing?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day10密碼學初探3古典加密"><a class="header" href="#day10密碼學初探3古典加密">Day10|密碼學初探(3)：古典加密</a></h1>
<p>我們前天提到了下面四個名詞，並且已經解釋完編碼、壓縮、哈希：</p>
<ol>
<li>編碼</li>
<li>壓縮</li>
<li>哈希(湊雜)</li>
<li>加密</li>
</ol>
<p>因此今天我們最後要介紹：<strong>加密</strong></p>
<h1 id="加密"><a class="header" href="#加密">加密</a></h1>
<p><img src="https://www.lkm543.site/it_iron_man/day10_1.png" alt="Encrypt" /></p>
<p><code>加密(Encrypt)</code>的目的是我們想要讓<strong>只有特定第三方能夠讀取</strong> 我們的訊息，以上面這個圖為例，我們在發送訊息前將我們的原始訊息<code>(明文，Plaintext)</code>加密(Encrypt)成Kl，那麼即便傳遞訊息的過程中信使被攔截，攔截者看到的也只是一段加密過後的文字<code>(密文，Cipertext)</code>，從而確保了資訊的安全。如果我們想要取得原始的資料，那麼也只需要透過<code>金鑰(Key)</code>去解密便可以了！</p>
<p>網路時代的資訊安全是奠基在密碼學之上的，我們每天在網路上傳遞各式各樣的訊息，私人傳遞的訊息自然不希望被第三者瀏覽、登入的密碼更是萬萬不可被中間人截取到、操作網路atm進行提匯款的時候更要再三確認使用者的身分，因此如何避免資訊被截取、破譯與偽造是現今網路時代的一大課題，我們首先來看加密法的大原則 ：</p>
<h2 id="kerckhoffss-principle柯克霍夫原則"><a class="header" href="#kerckhoffss-principle柯克霍夫原則">Kerckhoffs's principle(柯克霍夫原則)</a></h2>
<p>Auguste Kerckhoffs在19世紀提出的幾個加密系統需要有的原則：</p>
<ul>
<li>假定敵人知道加密方法的細節後仍然保持機密，因為敵人是否知道我們加密的方法是未知的。</li>
<li>加密用的密鑰必須容易溝通和記憶，而且可以輕易改變以調整。</li>
<li>必須可以用在通訊上。</li>
<li>無須他人的協助，一個人便可以使用。</li>
<li>即便加密演算法被洩漏，只要金鑰沒有外洩，加密後的密文仍然是安全的。</li>
</ul>
<p>加密方法被洩漏後仍應保持安全性，在任何的狀態下，都必須假定加密方法已經被敵人取得，否則一旦日後發現已經被敵人知悉，更換任何金鑰都是徒勞。不只有Auguste Kerckhoffs提倡這件事，著名的密碼學學者Claude Shannon與Bruce Schneie也都有類似的想法。</p>
<blockquote>
<p>"The enemy knows the system" - Claude Shannon</p>
</blockquote>
<blockquote>
<p>"Security through obscurity." - Bruce Schneie</p>
</blockquote>
<h2 id="古典的幾種加密法"><a class="header" href="#古典的幾種加密法">古典的幾種加密法</a></h2>
<p>在進入現代的加密法之前，我們來看看幾種古典的加密法，雖說目前這幾種加密法都可以輕易地被電腦破譯，但其實大部分的現代加密法背後的精神跟原理都是源自於古典加密法。</p>
<h3 id="caesar加密"><a class="header" href="#caesar加密">Caesar加密</a></h3>
<p><img src="https://cdn.instructables.com/FZZ/XPQ8/IRTDSFHC/FZZXPQ8IRTDSFHC.LARGE.jpg?auto=webp&amp;fit=bounds" alt="Caesar" /></p>
<p>圖片來源：<a href="https://www.instructables.com/id/Basics-of-Cryptography-Caesar-Cipher/">Basics of Cryptography: Caesar Cipher</a></p>
<p>Caesar加密據傳聞是<del>歷史課本上的</del> 那個凱薩所發明的，它的方法簡單而暴力，就是把每個字母偏移幾個作為替換，比方說往右偏移三個，也就是A都改成D、B都改成E、C都改成F....作為替代文字，簡單而硬漢(?)的方式讓它可以很快地被加解密，但缺點也很明顯：英文字母不就那26個，要暴力解出來也只需要嘗試25次就可以解出來了。我們最開頭把Hi轉換成Kl其實也是Caesar加密法！</p>
<p>下面是Caesar加密的簡單python實作，先取得字母的次序後，再平移，這裡我們定義加密是把ascii碼增加、解密則是把ascii碼減少：</p>
<pre><code>def txt_shift(txt, shift):
    result = ""
    for idx in range(0, len(txt)):
        char = txt[idx]
        if char.isalpha():
            if char.isupper():
                order = ord(char) -65 + shift
                order %= 26
                order += 65
            elif char.islower():
                order = ord(char) -97 + shift
                order %= 26
                order += 97
            char = chr(order)
        result += char
    return result

def caesar_encryption(txt, shift):
    return txt_shift(txt, shift)

def caesar_decryption(txt, shift):
    return txt_shift(txt, -1 * shift)

plain_txt = "Hello!"
shift_amount = 10

print(f"原始明文: {plain_txt}")
cipher_txt = caesar_encryption(plain_txt, shift_amount)
print(f"加密密文: {cipher_txt}")
decryption_cipher_txt = caesar_decryption(cipher_txt, shift_amount)
print(f"解密結果: {decryption_cipher_txt}")
</code></pre>
<p>就可以得到加解密的結果如下：</p>
<blockquote>
<p>原始明文: Hello!<br />
加密密文: Rovvy!<br />
解密結果: Hello!</p>
</blockquote>
<p>但Caesar加密法被洩漏後即便不知道偏移個數，但只要嘗試25次就可以破譯，很明顯的Caesar加密不符合Kerckhoffs's principle。</p>
<h3 id="monoalphabetic加密"><a class="header" href="#monoalphabetic加密">Monoalphabetic加密</a></h3>
<p><img src="https://www.lkm543.site/it_iron_man/day10_2.png" alt="Monoalphabetic" /></p>
<p>Caesar加密實在太容易被破解了，簡單改進Caesar加密的方法就是不要固定偏移幾個字元，而是另外開一張表做隨機的對應，比方說我們開一個新的對應表格：A→F、B→T、C→J代替，我們的表格總共會有26!總可能。</p>
<p>下面是Monoalphabetic加密的簡單實作，先透過隨機數取得字母的代換表後，加密時再根據代換表把原始明文的字母替換掉，解密的時候則需要把該代換表反轉過來：</p>
<pre><code>from random import sample

def txt_shift(txt, shift):
    result = ""
    for idx in range(0, len(txt)):
        char = txt[idx]
        if char.isalpha():
            order = ord(char)
            if char.isupper():
                order -= 65
                order = shift[order]
                order += 65
            elif char.islower():
                order -= 97
                order = shift[order]
                order += 97
            char = chr(order)
        result += char
    return result

def mono_encryption(txt, shift):
    return txt_shift(txt, shift)

def mono_decryption(txt, shift):
    inverse_shift = [0] * 26
    for idx, value in enumerate(shift):
        inverse_shift[value] = idx
    return txt_shift(txt, inverse_shift)

plain_txt = "Hello!"
shift_list = sample(range(0,26), 26)

print(f"原始明文: {plain_txt}")
print(f"Monoalphabet: {shift_list}")
cipher_txt = mono_encryption(plain_txt, shift_list)
print(f"加密密文: {cipher_txt}")
decryption_cipher_txt = mono_decryption(cipher_txt, shift_list)
print(f"解密結果: {decryption_cipher_txt}")
</code></pre>
<p>就可以得到以下的執行結果：</p>
<blockquote>
<p>原始明文: Hello!<br />
Monoalphabet: [23, 8, 24, 0, 1, 4, 5, 22, 10, 12, 19, 7, 6, 20, 3, 14, 2, 21, 15, 17, 9, 16, 13, 18, 11, 25]<br />
加密密文: Wbhhd!<br />
解密結果: Hello!</p>
</blockquote>
<p>看起來似乎萬無一失了，但實際上不是的。</p>
<p>事情不會那麼順利的，人類的語言是有強烈規則性，每個字母的使用頻率並不均等，比方說母音a、e、i、o、u的使用頻率就是硬生生比別人高一大截，如果發現有五個字母的使用頻率異常高，那麼就可以猜測他們是a、e、i、o、u其中之一而後逐步破譯，接著搭配下圖索統計出來的字頻表便可以從中比對。</p>
<p><img src="images/day10_20289.png" alt="Monoalphabetic Frequency" /></p>
<p>圖片來源：<a href="https://en.wikipedia.org/wiki/Frequency_analysis">Wikipedia</a></p>
<p>雖然嘗試的次數多了些，但在搭配語言學與不斷嘗試的前提下仍然可以破譯，Monoalphabetic加密也不符合Kerckhoffs's principle。</p>
<h3 id="vigenère-cipher-aka-polyalphabetic加密"><a class="header" href="#vigenère-cipher-aka-polyalphabetic加密">Vigenère Cipher a.k.a. Polyalphabetic加密</a></h3>
<p><code>Vigenère Cipher</code>是Monoalphabetic加密一種威力加強版，既然Monoalphabetic加密只有一張表，那用很多張表來加密總行了吧？Vigenère Cipher便是產生很多張表格，並且彼此抽換，而<strong>Vigenère Cipher的金鑰指的就是目前這個字應該要用哪一張表格破譯</strong> ，如果有ABCD四種Monoalphabetic表格，比較簡單的作法就是第一個字母用A表格、第二個字母用B表格、第三個字母用C表格、第四個字母用D表格、第五個字母用A表格....</p>
<p>但這樣利用語言本身重複的機率其實還是有辦法破譯，詳情限於篇幅可以參考<a href="https://hitcon.org/2018/CMT/slide-files/d1_s2_r4.pdf">這個PDF</a>的16-21頁。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Vigen%C3%A8re_square_shading.svg/1024px-Vigen%C3%A8re_square_shading.svg.png" alt="Vigenère Cipher" /></p>
<p>圖片來源：<a href="https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher">Wikipedia</a></p>
<p>順帶一提，這集的超智遊戲裏頭的每一種暗號都可以看做是一種表格，各種暗號(對照表)的交替使用能夠有效的增加破譯的難度，這一集裡頭渡久地用的方法其實跟Vigenère Cipher的精神一樣：不停地抽換暗號(編碼表)。</p>
<p><del>私心覺得超智遊戲還蠻好看的，有空的可以追追看。</del></p>
<p><a href="https://www.youtube.com/watch?v=7w9_O0W-EFc"><img src="https://img.youtube.com/vi/7w9_O0W-EFc/0.jpg" alt="Yes" /></a></p>
<h3 id="one-time-pad一次性密碼本"><a class="header" href="#one-time-pad一次性密碼本">One-Time Pad(一次性密碼本)</a></h3>
<p><code>One-Time Pad</code>的作法跟Caesar加密類似，但具體鑰<strong>偏移幾個字是隨機決定</strong> 的。比方說我們產生一個隨機偏移表：</p>
<blockquote>
<p>24 7 21 5 18 ....</p>
</blockquote>
<p>這張表就是One-Time Pad的金鑰，代表第一個字元我們要往後偏移24個、第二個字元我們要往後偏移7個、第三個字元我們要往後偏移21個、第四個字元我們要往後偏移5個、第五個字元我們要往後偏移18個....</p>
<p>如果產生的隨機金鑰長度跟訊息一樣，也就是每一個字元有自己的偏移與獨特的Monoalphabetic表格的話，理論上這One-Time Pad會因為密文與明文沒有任何統計上的關係而無法被任何數學或運算破解的加密法，你應該也可以發現經過One-Time Pad加密後的密文，明文可能是任何文字(例如密文是ABC，但因為每個字母的偏移量是隨機的，因此它有可能是car、cat、dog都有可能)，因此也是<strong>唯一一種理論上無法被破解的密碼</strong> 。但問題反而會在要如何安全、隨機地產生One-Time Pad、如何保護One-Time Pad的金鑰在傳送的過程中不會被幹走是主要的問題。</p>
<h3 id="rail-fence-ciphers柵欄加密法"><a class="header" href="#rail-fence-ciphers柵欄加密法">Rail-Fence Ciphers(柵欄加密法)</a></h3>
<p>柵欄加密法指的是我們把明文根據某種排列方式或圖形排列後再重新寫出。舉例來說我們把Hello World分成上下兩行：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day10_4.jpg" alt="Rail-Fence Ciphers" /></p>
<p>利用簡單的重新排序，就可以得到加密之後的密文：HWeolrllod，同時字序的結構也因此被打散了！</p>
<p>今天先把幾個古典加密的方法帶過去，明天我們來研究現代一點的密碼學！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，至於Caesar加密的程式碼則放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day10_caesar.py">這裡</a>、Monoalphabetic加密的程式碼放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day10_monoalpha.py">這裡</a>。</p>
<h1 id="ref-8"><a class="header" href="#ref-8">Ref:</a></h1>
<ul>
<li><a href="http://140.125.45.29/courses/files/network%20security/network%20security%20ch%202.pdf">Chapter 2: 密碼學基礎</a></li>
<li><a href="https://hitcon.org/2018/CMT/slide-files/d1_s2_r4.pdf">應用密碼學入門</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E5%85%8B%E9%9C%8D%E5%A4%AB%E5%8E%9F%E5%89%87">維基百科-柯克霍夫原則</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day11密碼學初探4現代加密xor與spn加密"><a class="header" href="#day11密碼學初探4現代加密xor與spn加密">Day11|密碼學初探(4)：現代加密─XOR與SPN加密</a></h1>
<h1 id="比昨天稍微現代一點的加密"><a class="header" href="#比昨天稍微現代一點的加密">比昨天稍微現代一點的加密</a></h1>
<p>奠定現代密碼學的兩大基柱分別是取代-重排網路與費斯妥密碼：</p>
<ul>
<li>取代-重排網路(Substitution-Permutation Network)</li>
<li>費斯妥密碼(Feistel Cipher)</li>
</ul>
<p>這兩者可說是現在密碼學的扛霸子，幾乎所有現代密碼學的演算法裡或多或少都可以看到他們的足跡，而明天要介紹的區塊加密法(block cipher)則利用了這兩者的精神加以延伸，雖然感覺我們跟區塊鏈離得越來越遠，但實際上區塊鏈就是區塊加密法(block cipher)的一種變體，所以要了解區塊鏈裏頭的各種名詞，不可不從加密開始。</p>
<h2 id="xor-cipher"><a class="header" href="#xor-cipher">XOR Cipher</a></h2>
<p>在之後講到現代加密的<code>Substitution-Permutation Network</code>與<code>Feistel Cipher</code>前，不可不提到兩者都會用到的XOR加密，XOR加密法利用的就是任何一段文字被另一段文字XOR運算兩次後會得到原本的文字，這種加密法的好處就是因為只有XOR運算，容易運算、運算快速、電路上容易實現、成本也小，下面的公式描述了這個現象，我們可以把裏頭的A看作是要傳遞的明文、B是加解密用的金鑰、C是加密後的密文</p>
<blockquote>
<p>A⊕B=C C⊕B=A</p>
</blockquote>
<p>用實際例子來看的話就是下面這張圖，每次加密我們都隨機產生一個金鑰，再利用金鑰與原始文字作XOR運算得到加密後的密文。傳遞之後接收端可以再讓密文與金鑰作另一次XOR運算得到原本的明文。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day11_1.png" alt="XOR Cipher" /></p>
<p>在這裡金鑰可以粗分成兩種：金鑰長度小於訊息、金鑰長度與訊息等長，如果金鑰長度小於訊息長度，代表我們會重複利用該筆金鑰作XOR運算，這時候利用字頻的分析就可以破解XOR加密，但如果金鑰與訊息等長，那其實就跟我們昨天提到的<code>One-Time Pad</code>一樣，理論上是不可被破解的。</p>
<p>下面是XOR加密法的簡單實作：這裡我們為了之後顯示位元組的方便，先準備兩個函式可以把字串轉換成位元組01構成的字串。</p>
<pre><code>def string_to_bytes(input):
    input = bytearray(input, 'utf-8')
    result = ""
    for byte in input:
        for i in range(7, -1, -1):
            result += str((byte &gt;&gt; i) &amp; 1)
    return result

def bytes_to_string(input):
    result = ""
    for idx in range(0, int(len(input)/8)):
        binary = input[8*idx:8*(idx+1)]
        result += chr(int(binary, 2))
    return result
</code></pre>
<p>接著產生金鑰，金鑰的產生由簡單的0跟1所構成，根據需要的長度產生。接著便可以進行XOR的運算，如果兩個輸入不同，則輸出1，兩個輸入值相同則輸出0。最後就可以用XOR來加解密了！注意這裡因為金鑰的長度有可能小於訊息長度，所以一旦處理到超出金鑰的長度，就從金鑰的頭開始重新使用金鑰。</p>
<pre><code>import random

def generate_key(length):
    key = ""
    for i in range(0, length):
        key += str(random.randint(0, 1))
    return key

def xor_operation(text, key):
    if text == key:
        return "0"
    else:
        return "1"

def xor_en_decrypt(text, key):
    result = ""
    len_txt = len(text)
    len_key = len(key)
    for idx in range(0, len_txt):
        if idx &gt;= len_key:
            key_idx = idx % len_key
        else:
            key_idx = idx
        xor_result = xor_operation(text[idx], key[key_idx])
        result += xor_result
    return result
</code></pre>
<p>最後就可以來實作看看啦，先隨意給定一個我們想加密的訊息，接著根據訊息長度產生金鑰，再讓訊息與金鑰進行XOR運算便可以得到密文。要解密的話也是一樣，讓密文與金鑰作XOR運算，就可以得到原本的密文。</p>
<pre><code>if __name__ == "__main__":
    message = "XOR Cipher!"
    print(f"Origin message: {message}")
    message = string_to_bytes(message)
    print(f"Message in binary: {message}")

    key = generate_key(len(message))
    print(f"Key: {key}")

    encryption = xor_en_decrypt(message, key)
    print(f"Encryption: {encryption}")

    decryption = xor_en_decrypt(encryption, key)
    print(f"Decryption: {decryption}")

    text = bytes_to_string(decryption)
    print(f"Text: {text}")
</code></pre>
<p>實際運行結果如下：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day11_2.jpg" alt="XOR Demo" /></p>
<h1 id="substitution-permutation-networkspn"><a class="header" href="#substitution-permutation-networkspn">Substitution-Permutation Network(SPN)</a></h1>
<p>SPN是Claude Shannon在1949年提出，Claude Shannon認為一個好的加密方法必須有這兩種特色：</p>
<blockquote>
<p>Diffusion：將密文中有可能出現的統計結構消除，同時明文的一點小改變會讓密文產生很大的變化<br />
Confusion：複雜化密文與金鑰間的關係</p>
</blockquote>
<p>我們昨天提到的One-Time Pad有這兩個特色，所以<code>One-Time Pad</code>也是唯一在金鑰安全的狀態下無法被解密的加密方法。至於為什麼要<code>Diffusion</code>與<code>Confusion</code>呢？</p>
<p>Diffusion是為了避免密文可以透過詞頻等分析被解出來，就像是昨日我們提到的Monoalphabetic，即便Monoalphabetic在金鑰的複雜度上幾不可能被破譯，但是詞頻的統計結構可以逐步解開我們的轉換表，為了避免攻擊者可以透過語言中會出現的統計結構來破譯，所以在密文中出現的統計結構必須被消除。同時為了避免傳遞兩段類似文字的情形中被猜出加密方式與密鑰，也期望即便明文只有一些小變動也會使密文產生很大的變化。</p>
<p>Confusion是為了讓密文看起來更像隨機、無法被讀取，同時在金鑰洩漏的狀況下能夠有多一層保障，只要密文與金鑰間夠複雜，攻擊者只能不斷嘗試各種加密方式來是突破譯。</p>
<p>Diffusion跟Confusion兩者都是為了避免攻擊者在知道密文與明文的狀態下可以解出加密方式與金鑰，這種情形又可以稱之為<a href="https://en.wikipedia.org/wiki/Known-plaintext_attack">known-plaintext attack</a>。</p>
<p>下面是一個基本的SPN算法，其中主要有代換、置換和輪金鑰混合三個步驟，在這裡我們先簡介一下代換、置換：</p>
<ul>
<li>
<p>代換：把明文的字母用另一個字母替換，我們昨日提到的Monoalphabetic就是代換法的應用。</p>
</li>
<li>
<p>置換：調動字母的順序，我們昨日提到的Rail-Fence Ciphers就是置換法的應用。</p>
</li>
</ul>
<p>SPN的想法其實很好理解，既然單次的代換與置換都很容易被破譯，那麼代換跟置換都用總行了吧？單輪不夠的話，那重複加密很多輪，那如何解密呢？其實一樣解密很多輪就可以把最原始的明文解出來。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/SubstitutionPermutationNetwork2.png/540px-SubstitutionPermutationNetwork2.png" alt="SPN" /></p>
<h2 id="spn演算法實作"><a class="header" href="#spn演算法實作">SPN演算法實作</a></h2>
<p>SPN演算法每次的輸入明文是固定的，為了簡化與方便後續的運算與表達，我們這裡把輸入SPN算法的位元數設定在16個位元。流程大概跟上圖顯示的一樣：</p>
<blockquote>
<p>明文→XOR Cipher(→S-boxes→P-boxes→XOR Cipher)*n→S-boxes→P-boxes→XOR Cipher→密文</p>
</blockquote>
<p>其中(→S-boxes→P-boxes→XOR Cipher)*n代表的是我們要重複做幾輪加密</p>
<h3 id="xor-cipher-1"><a class="header" href="#xor-cipher-1">XOR Cipher</a></h3>
<p>在<code>XOR Cipher</code>這裡我們可以直接把昨天寫好的函式拿過來使用。分別處理：產生金鑰、XOR運算、XOR加解密。只是因為SPN會做多組的XOR Cipher，所以SPN金鑰的產生方式是透過一組最初始的金鑰產生另外(回合數+1)組16bits的金鑰。</p>
<pre><code>def generate_key(key, rounds):
    key += key
    keys = []
    for idx in range(rounds):
        key_this_round = key[4*idx+4:4*idx+20]
        keys.append(key_this_round)
    return keys

def xor_operation(text, key):
    if text == key:
        return "0"
    else:
        return "1"

def xor_en_decrypt(text, key):
    result = ""
    len_txt = len(text)
    len_key = len(key)
    for idx in range(0, len_txt):
        if idx &gt;= len_key:
            key_idx = idx % len_key
        else:
            key_idx = idx
        xor_result = xor_operation(text[idx], key[key_idx])
        result += xor_result
    return result
</code></pre>
<h3 id="s-boxes替換盒"><a class="header" href="#s-boxes替換盒">S-boxes(替換盒)</a></h3>
<p>替換盒這裡我們可以先產生一個隨機數列<code>s_box</code>，這個數列裏頭有0-15隨機散布而且不重複，它看起來會長成這樣：</p>
<blockquote>
<p>s_box = [4, 6, 15, 12, 5, 1, 3, 11, 14, 13, 0, 7, 9, 10, 8, 2]</p>
</blockquote>
<p>這個數列的意思是：1用5替換掉、2用7替換掉、3用16替換掉....(記得索引值從0開始)，於是我們就可以進行替換了！實作方法如下：</p>
<pre><code>def substitution(input, s_box):
    output = ""
    for idx in range(4):
        data = input[4*idx:4*(idx+1)]
        number = int(data, 2)
        number_substitution = s_box[number]
        # Convert to binary string
        # ex: 9 -&gt; "1001"
        binary_number = ""
        for i in range(3, -1, -1):
            binary_number += str((number_substitution &gt;&gt; i) &amp; 1)

        output += binary_number
    return output
</code></pre>
<h3 id="p-boxes排列盒"><a class="header" href="#p-boxes排列盒">P-boxes(排列盒)</a></h3>
<p>排列盒這裡我們跟s_box用同樣方法產生一個隨機數列<code>p_box</code>：</p>
<blockquote>
<p>p_box = [13, 3, 12, 1, 9, 8, 15, 4, 6, 5, 10, 14, 2, 0, 11, 7]</p>
</blockquote>
<p>這代表：第1個bit要移動到第14個bit、第2個bit要移動到第4個bit、第3個bit要移動到第13個bit....實作方法如下</p>
<pre><code>def permutation(input, p_box):
    output = list("0" * 16)
    for idx, value in enumerate(p_box):
        output[value] = input[idx]
    return "".join(output)
</code></pre>
<h3 id="加密重複xor-ciphers-boxesp-boxes的步驟"><a class="header" href="#加密重複xor-ciphers-boxesp-boxes的步驟">加密：重複XOR Cipher→S-boxes→P-boxes的步驟</a></h3>
<p>加密的過程中就不斷重複XOR Cipher→S-boxes→P-boxes的過程，每次進入XOR-Cipher的金鑰都不一樣，但每次s_box、p_box的參數都相同，注意這裡會因為XOR的步驟會因為頭尾都作而比s_box與p_box多進行一次。</p>
<pre><code>def spn_encrypt(text, rounds, key, s_box, p_box):
    output = text
    for idx in range(rounds):
        output = xor_en_decrypt(output, key[idx])
        output = substitution(output, s_box)
        output = permutation(output, p_box)
    output = xor_en_decrypt(output, key[rounds])
    return output
</code></pre>
<h3 id="解密把加密的過程倒置過來"><a class="header" href="#解密把加密的過程倒置過來">解密：把加密的過程倒置過來</a></h3>
<p>這裡有兩點需要注意：xor_cipher使用的key必須倒置、s_box與p_box的參數也必須互換(原本如果是1替換成4，現在必須把4替換回1)，把加密的過程反過來作就可以解密了！</p>
<pre><code>def spn_decrypt(text, rounds, key, s_box, p_box):
    output = text
    s_box_inverse = [0]*16
    p_box_inverse = [0]*16
    for idx in range(16):
        s_box_inverse[s_box[idx]] = idx
        p_box_inverse[p_box[idx]] = idx
    for idx in range(rounds):
        output = xor_en_decrypt(output, key[rounds-idx])
        output = permutation(output, p_box_inverse)
        output = substitution(output, s_box_inverse)
    output = xor_en_decrypt(output, key[0])
    return output
</code></pre>
<h3 id="測試一下加解密"><a class="header" href="#測試一下加解密">測試一下加解密</a></h3>
<p>到這裡就可以測試我們的代換─置換網路是否可以正常運作了！</p>
<pre><code>if __name__ == '__main__':
    rounds = 3
    key = "1011101000111110"
    keys = generate_key(key, rounds + 1)
    print(f"初始金鑰： {key}")
    print(f"產生金鑰： {keys}")

    s_box = random.sample(range(0, 16), 16)
    print(f"s_box： {s_box}")
    p_box = random.sample(range(0, 16), 16)
    print(f"p_box： {p_box}")

    message = "1001001110100101"
    print(f"原始明文： {message}")
    encryption = spn_encrypt(message, rounds, keys, s_box, p_box)
    print(f"加密密文： {encryption}")
    decryption = spn_decrypt(encryption, rounds, keys, s_box, p_box)
    print(f"原始明文： {decryption}")
</code></pre>
<p><img src="https://www.lkm543.site/it_iron_man/day12_1.jpg" alt="SPN Demo" /></p>
<h2 id="那spn有滿足diffusion跟confusion嗎"><a class="header" href="#那spn有滿足diffusion跟confusion嗎">那SPN有滿足Diffusion跟Confusion嗎？</a></h2>
<p>首先回憶一下Diffusion跟Confusion這兩個詞代表的意思：</p>
<blockquote>
<p>Diffusion：將密文中有可能出現的統計結構消除，同時明文的一點小改變會讓密文產生很大的變化<br />
Confusion：複雜化密文與金鑰間的關係</p>
</blockquote>
<p>首先是Diffusion，想像一下如果我們僅改變輸入明文的其中一個bit，則這個bit會被餵到s-box做替換，使跟這個bit同一組的數個bits通通被換掉，而後被傳入p-box做重新排序，等於所有的bit都有機會被更動到，而後又進到下一輪開始的s-box，如果其中只有一個位元被更動，那麼輸出的位元仍然會有相當大的變化！光說沒證據，那麼我們簡單用上面的程式碼做個實驗：</p>
<blockquote>
<p>原始明文： 1001001110100101<br />
加密密文： 0010000011101100<br />
原始明文： 1001001110100111<br />
加密密文： 1101110001110000</p>
</blockquote>
<p>這裡我們對明文只做了一個bit的更動：1001001110100101→1001001110100111，但密文卻從0010000011101100→1101110001110000整整改變了10個bit！</p>
<p>Confusion的理由跟Diffusion類似，因為裏頭的bit通通被替換與重新排序了，密文與金鑰間的關係對外界來說自然是幾不可考了！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，至於今天的程式碼則放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day12.py">這裡</a>。</p>
<h1 id="spn與區塊鏈"><a class="header" href="#spn與區塊鏈">SPN與區塊鏈</a></h1>
<p>到這裡我們可以發現SPN每次能夠加密的長度都是固定的！而且SPN透過了多輪重複的加密來大幅提升破譯難度，這兩種特色也會在明天區塊加密中的介紹被提及，屆時就可以發現區塊鏈並不是一夕之間被發明出來的新技術，背後是由許多傳統的技術積累而構成的！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，至於今天的XOR程式碼則放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day11_XOR.py">這裡</a>，SPN程式碼則放<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day11_SPN.py">這裡</a>。</p>
<h1 id="ref-9"><a class="header" href="#ref-9">Ref:</a></h1>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%88%96%E5%AF%86%E7%A0%81">維基百科-互斥或密碼</a></li>
<li><a href="http://140.125.45.29/courses/files/network%20security/network%20security%20ch%202.pdf">Chapter 2: 密碼學基礎</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E6%8D%A2-%E7%BD%AE%E6%8D%A2%E7%BD%91%E7%BB%9C">維基百科-代換-置換網路</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/36262011">密码学入门（一）：用Python实现对称加密算法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day12密碼學初探5現代加密feistel與區塊加密"><a class="header" href="#day12密碼學初探5現代加密feistel與區塊加密">Day12|密碼學初探(5)：現代加密─Feistel與區塊加密</a></h1>
<p>在講解完昨天的2種加密法─XOR Cipher與Substitution-Permutation Network(SPN)後，我們今天要來講解Feistel Cipher與區塊加密，講解完區塊加密後，你就可以發現區塊加密其實跟區塊鏈架構是一樣的！</p>
<h1 id="feistel-cipher"><a class="header" href="#feistel-cipher">Feistel Cipher</a></h1>
<p>Feistel在1973所提出Feistel Cipher，幾乎被應用在所有區塊加密的演算法上(區塊加密是甚麼以下會再說明)，Feistel Cipher跟昨天提到的Substitution Permutation Network的精神很類似：用各種算法算很多輪來打散密文與明文間的關係，下圖是Feistel Cipher的演算法流程：</p>
<p><img src="images/day12_55132.jpg" alt="Feistel Cipher" /></p>
<p>圖片來源：<a href="https://www.tutorialspoint.com/cryptography/">tutorialspoint</a></p>
<p>Feistel Cipher首先會跟SPN一樣利用一把原始金鑰生成(回合數)個金鑰，隨後把明文切割成左右兩部分(L0與R0)，接著在每一回合中，依序在第N回合中對左右兩部分做：</p>
<ol>
<li>把右邊(RN)的的部分跟第N把金鑰作F函數的轉換(RN')</li>
<li>第一步驟轉換出來的結果(RN')再和這一回合的左邊做XOR運算便是新產生的右邊(RN+1=LN⊕RN')</li>
<li>接著再把此輪的右邊的原始資料直接當作下一輪的左邊(LN+1=RN)</li>
</ol>
<p>與SPN相同，加解密都是利用相同的編碼方法，因此密文解密的過程即是把加密的過程反過來，即可。要注意的是F函數應該要有取代的功能(因為左右兩邊交換的過程中其實已經有置換，但沒有取代，取代應該要在F函數中被實做出來)，此外，F函數的設計也會影響到攻擊的難度，F函數越複雜，由密文拆解出明文就會越困難。</p>
<p>如果F函數用的是跟SPN同樣的s_box呢?這樣的話就很像我們昨天提到的SPN網路，但SPN網路在實務上比較容易被平行運算，在GPU或ASIC的運算上能夠很輕易的實現，但在嵌入式或是智慧卡上頭SPN就不太適用了。另外用s_box當作F函數其實就是我們之前提到的Data Encryption Standard(DES)。</p>
<h1 id="串流加密-vs-區塊加密"><a class="header" href="#串流加密-vs-區塊加密">串流加密 vs 區塊加密</a></h1>
<p>我們到目前為止提到的加密法都是對稱式加密，對稱式加密指的是加解密用的是同一把金鑰，而對稱式加密裏頭又可以分成：串流加密(stream cipher)與區塊加密(block cipher)。</p>
<p>串流加密是透過固定的算法與金鑰，對明文的位元逐個做加解密，也就是同一套模式從第一個字元運算到最後一個字元，好處是運算速度快，可以隨時隨著資料的輸入而加密，通常運用在通訊上。</p>
<p>區塊加密則不然，每個區塊加密都有<strong>固定長度的輸入</strong> ，也就是區塊加密每次只能加密固定長度的資料，如果要加密的資料超出區塊加密法能夠加密的上限，就把原始資料切割成許多子資料後再分別加密；如果資料長度不足則需要補齊到區塊加密法能接收的長度。我們介紹的SPN或是Feistel Cipher因為都有固定長度的輸入，因此兩者都屬於區塊加密。</p>
<p>目前主流的加密方法都是區塊加密了，因此我們接下來對幾種區塊加密的方法做個簡介：</p>
<h2 id="electronic-codebookecb"><a class="header" href="#electronic-codebookecb">Electronic codebook(ECB)</a></h2>
<p>在Electronic codebook(ECB)的模式中會根據區塊加密法每次能夠加密的資料大小把資料切割成許多獨立的區塊，每個區塊再獨立地被加解密，下面是它的流程圖：</p>
<p>加密<br />
<img src="images/day12_75405.png" alt="CBC Encryption" /></p>
<p>圖片來源：<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB">Wikipedia</a></p>
<p>解密<br />
<img src="images/day12_55055.png" alt="CBC Decryption" /></p>
<p>圖片來源：<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB">Wikipedia</a></p>
<p>但ECB的缺陷就是包含同樣資訊的區塊會被加密成同樣的密文，使得Diffusion不足(無法保障密文與明文間的複雜)。</p>
<h3 id="重放攻擊"><a class="header" href="#重放攻擊">重放攻擊</a></h3>
<p>另外一個ECB模式的缺陷就是容易被<strong>重放攻擊</strong>(應念二聲ㄔㄨㄥˊ，重複的重)，意即因為每一個區塊都有獨立的訊息，即使攻擊者不知道加密方式與金鑰，只要攻擊者知道區塊的功能後也只需要重複傳遞該區塊，接收端便會誤認接收了多次相同的訊息，比方說其中一個區塊是匯款給他人，那麼攻擊者可以透過不斷傳遞該區塊的方式把使用者的餘額給提領光。</p>
<h2 id="cipher-block-chainingcbc"><a class="header" href="#cipher-block-chainingcbc">Cipher-block chaining(CBC)</a></h2>
<p>ECB模式的問題在於當我們紀錄連續資料時，容易被重放攻擊，同時也很難逐一驗證每個區塊資訊是否有被竄改過，因此Cipher-block chaining(CBC)便應運而生，在CBC模式中，每區塊的明文會先跟前一個密文區塊進行XOR運算後再加密。因為此時每個區塊的加密都會使用到前面所有區塊的參數，因此只要中間其中一個區塊被更改過，那麼便會輕易地被發現，下圖是它概要的加解密流程。</p>
<p>加密<br />
<img src="images/day12_46008.png" alt="CBC Encryption" /></p>
<p>圖片來源：<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB">Wikipedia</a></p>
<p>解密<br />
<img src="images/day12_20884.png" alt="CBC Decryption" /></p>
<p>圖片來源：<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB">Wikipedia</a></p>
<p>到這裡你也可以發現：<strong>CBC</strong> 加密其實就是Blockchain的前身，這也給我們一個線索，既然中本聰知道CBC加密，那麼中本聰自己應該就是從事密碼學相關領域的工作！</p>
<h3 id="區塊鏈上的重放攻擊"><a class="header" href="#區塊鏈上的重放攻擊">區塊鏈上的重放攻擊</a></h3>
<p>但在區塊鏈上也有所謂的重放攻擊，因為主鏈硬分岔之後的加密演算法、私鑰、公鑰通通都相同，所以攻擊者可以重現在另一條鏈上的交易(因為簽署或密文都可以在另外一條鏈找到，找到後就可以在其他鏈上發起同樣的交易)。避免重放攻擊的方法就是讓分岔後的每條鏈有自己獨立的ID，這樣就可以讓交易只在某特定ID的鏈上能夠被廣播。</p>
<p>可以點選<a href="https://www.binance.vision/zt/security/what-is-a-replay-attack">這裡</a>了解相關資訊，也因此<strong>了解區塊鏈之前必須先了解密碼學</strong> 。</p>
<h1 id="現代加密標準"><a class="header" href="#現代加密標準">現代加密標準。</a></h1>
<p>今天的最後我們來簡單聊聊現代幾種加密的標準。</p>
<h2 id="data-encryption-standarddes"><a class="header" href="#data-encryption-standarddes">Data Encryption Standard(DES)</a></h2>
<p>DES使用7個8位元大小的位元組共56位元作為金鑰內容，也屬於區塊式密碼(block cipher，意即每次加密的長度是固定的，我們之後會再提及)，每次的輸入能夠加密64位元的明文，加密過程共有16輪，每輪都使用演算法從金鑰產生不同的子金鑰(subkey)來加密，也在1977年被美國國家標準局製定為標準，下面是DES加密的大概流程。</p>
<p><img src="images/day12_91835.png" alt="DES" /></p>
<p>圖片來源：<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96">維基百科</a></p>
<h3 id="triple-des3des"><a class="header" href="#triple-des3des">Triple DES(3DES)</a></h3>
<p>但隨著電腦硬體的飛速進步，早在1997年6月，Rocke Verser、Matt Curtin、Justin Dolske團隊就能透過暴力運算所有金鑰的2^56次方種可能來破解DES加密，1999年甚至有人能夠在一天內的時間就破解DES加密。DES此時非常需要一個替代方案來取代，但新方案的出現需要經過密碼學者的驗證與研究，產生新演算法的標準耗時而緩不濟急，因此過渡方案便是透過重複利用三次的DES加密、同時也把金鑰長度變成三倍，藉此在過渡階段避免對DES的攻擊。</p>
<h2 id="advanced-encryption-standard加密aes"><a class="header" href="#advanced-encryption-standard加密aes">Advanced Encryption Standard加密(AES)</a></h2>
<p>因為過往的標準DES已無法提供足夠的安全性，國家標準暨技術研究院(National INstitute of Standards and Technology，NIST)在1997年9月12日向密碼學界徵求能夠替代DES的加密演算法，經過3年的驗證以後，Rijndael演算法最後入選成為進階加密標準(Advanced Encryption Standard，AES)。</p>
<p>也因為AES採用Rijndael演算法，所以AES有兩意義：標準或演算法。如果AES指的是演算法時，那麼AES演算法就是Rijndael演算法。</p>
<h3 id="rijndael演算法"><a class="header" href="#rijndael演算法">Rijndael演算法</a></h3>
<p>Rijndael演算法由比利時學者Joan Daemen和Vincent Rijmen提出，因此Rijndael演算法的名稱就來自於兩位學者名字的融合，其特色是基於明天我們會詳細提到的<code>代換-置換網路(Substitution-permutation network，SPN)</code>的加密演算。也就是原始的明文會透過多次的加密與轉換後生成密文，大部分的加密演算法也都會透過重複多輪的加密與轉換來增加加密的安全性。</p>
<h1 id="編碼壓縮哈希加密的比較"><a class="header" href="#編碼壓縮哈希加密的比較">編碼、壓縮、哈希、加密的比較</a></h1>
<p>終於把加密的內涵與幾個重要算法講解完畢，今日的最後讓我們簡單複習一下密碼學裏頭這四種詞彙代表的意涵：</p>
<ul>
<li>編碼：<strong>雙向轉換</strong> 資料的儲存形式或內容</li>
<li>壓縮：轉換後使資料的<strong>儲存空間變小</strong> ，也可以解開回原先的檔案</li>
<li>哈希：<strong>單向</strong> 把不定長度的輸入變成固定長度的輸出</li>
<li>加密：可以雙向轉換，但<strong>只有特定的對象有辦法反向解開</strong> 而得到原本的資料</li>
</ul>
<p><img src="https://www.lkm543.site/it_iron_man/day10_3.jpg" alt="Example" /></p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-10"><a class="header" href="#ref-10">Ref:</a></h1>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B4%B9%E6%96%AF%E5%A6%A5%E5%AF%86%E7%A0%81">維基百科-費斯妥密碼</a></li>
<li><a href="https://www.tutorialspoint.com/cryptography/feistel_block_cipher.htm">Feistel Block Cipher</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96">維基百科-資料加密標準</a></li>
<li><a href="https://wiki.kmu.edu.tw/index.php/Feistel_cipher"> 費斯特密文</a></li>
<li><a href="https://www.cnblogs.com/starwolf/p/3365834.html">AES五种加密模式（CBC、ECB、CTR、OCF、CFB）</a></li>
<li><a href="http://blockgeek.com/t/topic/1518">区块链中，什么是重放攻击，什么是重放保护呢？</a></li>
<li><a href="https://zh.wikipedia.org/wiki/3DES">維基百科-3DES</a></li>
<li><a href="https://blog.csdn.net/jerry81333/article/details/78091145">DES 数据加密标准 结构详解</a></li>
<li><a href="https://www.itread01.com/content/1541892089.html">AES標準及Rijndael演算法解析</a></li>
<li><a href="https://panx.asia/archives/51155"> 你的網路資訊真的安全嗎？美國政府公定「資料加密標準」首度被破解</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day13密碼學初探6merkle-tree"><a class="header" href="#day13密碼學初探6merkle-tree">Day13|密碼學初探(6)：Merkle Tree</a></h1>
<h1 id="merkle-tree"><a class="header" href="#merkle-tree">Merkle Tree</a></h1>
<p><img src="https://www.lkm543.site/it_iron_man/day14_1.PNG" alt="Merkle Tree" /></p>
<p>我們在密碼學的開頭已經講解過哈希(湊雜)的原理以及應用，而今天要談到的<code>Merkle Tree</code>其實是演算法裏頭的一種二元樹，透過兩兩計算哈希值的方法來驗證資料的正確性跟完整性。以上圖為例，上面的Merkle Tree最底層可以看做是Bitcoin的每一筆交易，每一筆交易可以分別計算出哈希值，接著在兩兩一對分別計算兩哈希值的哈希值，直到最後只剩下一個哈希值hash(ABCD)，這時候我們稱它為<code>Merkle Root</code>。</p>
<h2 id="為什麼不直接連接concatenation所有交易再hash就好"><a class="header" href="#為什麼不直接連接concatenation所有交易再hash就好">為什麼不直接連接(concatenation)所有交易再Hash就好？</a></h2>
<p>我們在之前的實作區塊鏈中，定義了我們的哈希值是由四種不同的狀態透過哈希函式sha-1計算而得(其實sha-1已經被破譯了，實務上盡量避免用sha-1)：</p>
<ol>
<li>前一個區塊的哈希值</li>
<li>區塊最初的時間</li>
<li>把所有的交易訊息連接成一個字串</li>
<li>nonce值(複習一下：礦工在找的就是這個nonce值)</li>
</ol>
<pre><code>def transaction_to_string(self, transaction):
    transaction_dict = {
        'sender': str(transaction.sender),
        'receiver': str(transaction.receiver),
        'amounts': transaction.amounts,
        'fee': transaction.fee,
        'message': transaction.message
    }
    return str(transaction_dict)

def get_transactions_string(self, block):
    transaction_str = ''
    for transaction in block.transactions:
        transaction_str += self.transaction_to_string(transaction)
    return transaction_str

def get_hash(self, block, nonce):
    s = hashlib.sha1()
    s.update(
        (
            block.previous_hash
            + str(block.timestamp)
            + self.get_transactions_string(block)
            + str(nonce)
        ).encode("utf-8")
    )
    h = s.hexdigest()
    return h
</code></pre>
<p>這是很簡單也很容易理解的算法：只要這個區塊中的任何一個交易被修改過，由交易紀錄連接起來的字串會跟著改變，那麼最後算出來的哈希值也必定會發生改變，從而讓我們得知裏頭的資料並不可信。</p>
<p>但如果我們的確這樣做的話，我們會如何驗證一筆交易是否真的存在呢？這時候只能照著自己設計的演算法需求把該區塊的所有交易通通都收集起來，然後再連接、再跟其他參數計算Hash看有沒有吻合，也就是說<strong>為了驗證一筆交易，必須把同一區塊內的所有交易紀錄都下載下來</strong> 。</p>
<h2 id="merkle-tree如何驗證交易"><a class="header" href="#merkle-tree如何驗證交易">Merkle Tree如何驗證交易</a></h2>
<p><img src="https://www.lkm543.site/it_iron_man/day14_2.png" alt="Merkle Tree Verify" /></p>
<p>但有了Merkle Tree就不一樣了，以上圖為例，假設我們想要確認Tx D是否存在這個區塊中，那我們只需要下載這個區塊的Hash(C)、Hash(AB)、跟Hash(ABCD)三個值(順待一提，這裡的Hash(ABCD)就是這個區塊的Merkle Root)，驗證的方法就是：</p>
<ol>
<li>計算Tx D的哈希值Hash(D)</li>
<li>計算Hash(D)與Hash(C)的哈希值Hash(CD)</li>
<li>計算Hash(AB)與Hash(CD)的哈希值Hash(ABCD)</li>
<li>確認我們計算出來的Hah(ABCD)跟區塊裡的Merkle Root或Hash(ABCD)有沒有一致</li>
<li>一致→該筆交易的確存在這個區塊，不一致→該筆交易不存在於這個區塊</li>
</ol>
<p>以bitcoin而言，實際上一個區塊平均會有3-500筆交易在裏頭(可以參考<a href="https://www.quora.com/How-many-transactions-are-included-in-a-block-chain">這裡</a>)，為了方便計算我們假定這個區塊中有512筆交易。也就是最下面代表交易的交易node有512個點、再上一層有256個點、再上一層有128個點....，那麼透過Merkle Tree，我們只需要取得Merkle Root跟另外8個Hash值便可以驗證該筆交易是否為真。</p>
<p><code>512筆交易 vs 8個Hash</code>，需要的資料整整少了64倍(因為交易的大小會大於Hash大小，實際上會節省更多空間)，這就是Merkle Tree的威力！</p>
<h2 id="second-preimage-attack"><a class="header" href="#second-preimage-attack">Second preimage attack</a></h2>
<p>但有沒有可能即便算出來的Merkle Root是一致的，但裏頭的Transaction不一樣呢？當然有可能，如果你有印象之前提到的生日碰撞，該問題是：給定一哈希值H，要找出經過哈希函數轉後後也是H的任一明文；而這裡的問題有點小小的不同：給定明文(在這裡是交易)M1後，要找出另一個明文M2跟M1在特定的哈希函數下擁有相同的哈希值，白話文就是我要找到另外一個交易紀錄同樣經過哈希函數後可以吻合Merkle Root的話，我就可以騙過整個驗證系統，這就是密碼學上所稱的<code>Second preimage attack</code>。</p>
<p>不過這個機率很小很小，小到幾乎可以忽略，因為Bitcoin使用的是SHA-256加密法，也就是說每次新產生的交易M2跟欲攻擊的交易M1有相通Hash值的機率只有2^-256次方。</p>
<h2 id="bitcoin中的merkle-tree"><a class="header" href="#bitcoin中的merkle-tree">Bitcoin中的Merkle Tree</a></h2>
<p>下圖是應用在Bitcoin上的Merkle Tree，最底層是每一筆交易，透過計算每筆交易的哈希值後再兩兩運算可以得到Merkle Tree供以後驗證之用，大抵上的過程跟我們上頭講解的是一樣的(<del>因為原本就是用Bitcoin來舉例</del>)</p>
<p><img src="https://en.bitcoinwiki.org/upload/en/images/thumb/9/95/Hash_Tree.svg/500px-Hash_Tree.svg.png" alt="Bitcoin" /></p>
<p>圖片來源：<a href="https://en.bitcoinwiki.org/wiki/Main_Page">BitcoinWiki</a></p>
<p>建立好Merkle Tree後就可以大幅減少驗證交易所需要的資訊量，也因此Bitcoin提供了兩種節點<code>Full node</code>與<code>SPV(Simplified Payment Verification) node</code>：</p>
<h3 id="full-node"><a class="header" href="#full-node">Full Node</a></h3>
<p>Full Node的話很好理解，就是儲存了自創世塊以來的所有交易，如果你想要開一個Full Node的話，<a href="https://bitcoin.org/en/full-node#special-cases">Bitcoin org</a>有建議的硬體規格如下：</p>
<ul>
<li>200 GB的儲存空間，另外讀寫速度都要在100MB/s以上.</li>
<li>2GB以上的記憶體</li>
<li>上傳速度400 Kbps的網路</li>
</ul>
<p>可以發現最難的還是卡在Full Node為了儲存所有交易紀錄所需要的空間(建議200GB)，這對筆記型電腦或個人PC來說或許不難，可是對手機等行動裝置來說就有點太大了，不然你可以看<a href="https://www.apple.com/tw/shop/buy-iphone/iphone-11-pro">iPhone在各個容量上的價錢</a>.....</p>
<h3 id="spvsimplified-payment-verification-node"><a class="header" href="#spvsimplified-payment-verification-node">SPV(Simplified Payment Verification) Node</a></h3>
<p>但有了Merkle Tree的協助，行動端的裝置可以只安裝SPV Node，裏頭只有每個Block的Header(約80個Bytes)，一但有檢查交易紀錄是否存在於某個區塊中，就去訪問Full Node並且索取該區塊的Merkle Tree以供驗證，這個方法又稱之為<code>Merkle Path Proof</code>。</p>
<p>下面是中本聰在<a href="https://bitcoin.org/bitcoin.pdf">白皮書</a>中所留的一段話</p>
<blockquote>
<p>A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory.</p>
</blockquote>
<p>簡單翻譯就是：並非所有裝置都有足夠的資源當full node，但如果某些輕型裝置只有驗證或發送交易需求的話，那麼它並不需要儲存自創世塊以來的全部區塊的交易資料，只需要儲存每Block的標頭，這樣即使一年過去了，你的手機也只會增加4.2MB的資料！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-11"><a class="header" href="#ref-11">Ref:</a></h1>
<ul>
<li><a href="https://www.itread01.com/content/1544187062.html">Merkle Tree（默克爾樹）演算法解析</a></li>
<li><a href="https://zh.wikipedia.org/zh-tw/%E5%93%88%E5%B8%8C%E6%A0%91">維基百科-哈希樹</a></li>
<li><a href="https://en.bitcoinwiki.org/wiki/Merkle_tree">Wikipedia-Merkle Tree</a></li>
<li><a href="https://bitcoin.stackexchange.com/questions/76811/why-use-merkle-root-and-not-just-concatonation-of-all-hashes">Why use Merkle Root (and not just concatonation of all hashes?</a></li>
<li><a href="https://bitcoin.org/bitcoin.pdf">Bitcoin: A Peer-to-Peer Electronic Cash System</a></li>
<li><a href="https://bitcoin.stackexchange.com/questions/10479/what-is-the-merkle-root">What is the Merkle root?</a></li>
<li><a href="https://countchu2.blogspot.com/2017/03/full-nodespv-nodetransaction.html">Full Node和SPV Node如何驗證Transaction？</a></li>
<li><a href="https://flawed.net.nz/2018/02/21/attacking-merkle-trees-with-a-second-preimage-attack">Attacking Merkle Trees With a Second Preimage Attack</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day14密碼學初探7非對稱加密與數位簽章"><a class="header" href="#day14密碼學初探7非對稱加密與數位簽章">Day14|密碼學初探(7)：非對稱加密與數位簽章</a></h1>
<h1 id="對稱與非對稱加密"><a class="header" href="#對稱與非對稱加密">對稱與非對稱加密</a></h1>
<p>在密碼學的領域中，加密法可以根據加密、解密是否用同一把金鑰來決定，如果加解密用的是同一把鑰匙，那麼它便是<code>對稱式加密</code>，你也可以發現到目前為止我們所提到的Caesar、Monoalphabetic、Vigenère Cipher、One-Time Pad、Rail-Fence Ciphers、XOR Cipher、SPN、Feistel Cipher都是對稱式加密！如果加密、解密時用的金鑰不同則稱為<code>非對稱加密</code>，因為非對稱式加密的算法較為複雜，背後也會牽扯到數學理論，所以我們延後到這裡才做說明。</p>
<h2 id="對稱式加密"><a class="header" href="#對稱式加密">對稱式加密</a></h2>
<p>我們之前所有提到的加密演算法裏利用同一把金鑰就可以做到加密與解密(解密其實就是把加密算法反過來做)。這麼做的好處就是相對容易運算、(<del>我們下面非對稱式加密推導完之後你應該就會有感覺</del>)、計算量小、所需時間也少。</p>
<p>安全性方面，利用<code>One-Time Pad</code>也是唯一一種理論上完全無法被解密的加密算法。但這樣做有甚麼問題跟缺陷呢？</p>
<p>即便演算法本身的安全性無虞，但金鑰呢？你必須先把金鑰傳遞給對方，對方才有辦法解密，但你能夠確保金鑰的傳遞過程是安全的嗎？為了確保金鑰傳遞的安全是不是要再讓金鑰加密一次、又為了確保金鑰的金鑰是安全的，是不是又要把金鑰的金鑰又加密一次變成金鑰的金鑰的金鑰......(<del>你真的確定你有個安全的好方法能夠傳遞金鑰不被外洩，你就用那個方法傳遞明文不就好了</del>)，所以對稱式加密的癥結點在於：<strong>對稱式加密是安全的，但傳遞過程不是</strong> 。</p>
<h2 id="非對稱式加密-1"><a class="header" href="#非對稱式加密-1">非對稱式加密</a></h2>
<p>為了解決對稱式加密傳遞的難處，非對稱式加密每次都會產生兩把鑰匙：公鑰與私鑰。</p>
<p><img src="images/day14_47494.png" alt="symmetric key" /><br />
圖片來源：<a href="https://courses.cs.ut.ee/">courses.cs.ut.ee</a></p>
<p>兩把鑰匙的差別在於：<strong>私鑰可以產出公鑰、公鑰無法產出私鑰</strong> ，因此產生的兩把鑰匙中，私鑰會放在身上、公鑰才會在外流通或傳遞，如此一來就可以避免傳遞過程中被竊聽的風險。另外因為兩把鑰匙在加密、解密上彼此可通用，因此又衍伸出兩種主要用法：</p>
<ol>
<li>公鑰加密、私鑰解密</li>
<li>私鑰加密、公鑰解密</li>
</ol>
<p><img src="images/day14_66908.png" alt="Bob" /><br />
圖片來源：<a href="https://www.twilio.com/">twillo</a></p>
<p>公鑰加密、私鑰解密的應用場景就像我們之前提過的：傳私密訊息給別人；利用別人的公鑰加密後，就可以確保持有私鑰的本人有辦法解開(上圖)。</p>
<p>私鑰加密、公鑰解密的就是數位簽章，透過數位簽章我們可以確保該訊息的確是由私鑰的持有人發出的，因此為了確保該筆交易是由本人發起的，每筆交易都必須經過<code>數位簽章</code>的確認。</p>
<p>你在<a href="https://etherscan.io/">區塊鏈瀏覽器</a>上看到的一連串像亂碼般的錢包地址，就是透過非對稱加密產出的<code>公鑰</code>，每把公鑰都有相對應的<code>私鑰</code>，在必要的時候我們可以利用私鑰對訊息或交易做簽署，讓礦工確認這筆訊息或交易的確是由我們本人發出來的。</p>
<p>回憶一下我們之前所寫的程式碼，在發起交易前必須都必須先用私鑰簽署以證明是本人，送上鏈前礦工會根據公鑰是否能解密來確認該筆交易是否的確由私鑰持有者發出。</p>
<pre><code>def sign_transaction(self, transaction, private_key):
    private_key_pkcs = rsa.PrivateKey.load_pkcs1(private_key)
    transaction_str = self.transaction_to_string(transaction)
    signature = rsa.sign(transaction_str.encode('utf-8'), private_key_pkcs, 'SHA-1')
    return signature

def add_transaction(self, transaction, signature):
    public_key = '-----BEGIN RSA PUBLIC KEY-----\n'
    public_key += transaction.sender
    public_key += '\n-----END RSA PUBLIC KEY-----\n'
    public_key_pkcs = rsa.PublicKey.load_pkcs1(public_key.encode('utf-8'))
    transaction_str = self.transaction_to_string(transaction)
    if transaction.fee + transaction.amounts &gt; self.get_balance(transaction.sender):
        print("Balance not enough!")
        return False
    try:
        # 驗證發送者
        rsa.verify(transaction_str.encode('utf-8'), signature, public_key_pkcs)
        print("Authorized successfully!")
        self.pending_transactions.append(transaction)
        return True
    except Exception:
        print("RSA Verified wrong!")
</code></pre>
<p>下面就如何產生非對稱式加密的兩大方法(RSA、ECC)做個簡單探討：</p>
<h1 id="rsa加密"><a class="header" href="#rsa加密">RSA加密</a></h1>
<p><code>RSA(Rivest–Shamir–Adleman)加密法</code>是1977年由Ron Rivest、Adi Shamir、Leonard Adleman共同提出(RSA取名自三個人名字加總)，背後原理是透過一個非常大的質數難以被分解，同時兩個大質數相乘後要拆解回原本的兩質數非常困難。</p>
<h2 id="rsa公私鑰的產生"><a class="header" href="#rsa公私鑰的產生">RSA公私鑰的產生</a></h2>
<p>在了解RSA加密如何產生公私鑰前，必須先了解兩個名詞：<code>歐拉函數</code>與<code>模反元素</code></p>
<ul>
<li>歐拉函數φ(N)指≦N的整數中，跟N互質的個數，如果N是由兩質數p、q構成的，可以滿足：(<a href="https://blog.csdn.net/LOI_QER/article/details/52862505">證明</a>)</li>
</ul>
<blockquote>
<p>φ(N)=φ(p*q)=(p-1)(q-1)</p>
</blockquote>
<ul>
<li>模反元素：整數a對同餘整數N的模反元素b會滿足以下公式</li>
</ul>
<blockquote>
<p>ab ≡ 1 (mod N)</p>
</blockquote>
<p>≡在數學裡是同餘的意思，可以理解成ab跟1除以N的餘數會一樣(也就是1)。因此整數a對同餘整數N的模反元素b又可以理解成對a找到另一個整數b，使a*b除以N的餘數為1。</p>
<p>公私鑰的產生步驟如下：</p>
<ol>
<li>選擇兩個大而且相異的質數：p與q，計算N=p*q</li>
<li>根據<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">歐拉函數</a>，求r=φ(N)=φ(p*q)=(p-1)(q-1)</li>
<li>選一個小於r的整數e，使e與r互質。</li>
<li>求e對r的<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0">模反元素</a>d，也就是ed ≡ 1 (mod r)</li>
<li>銷毀p、q</li>
</ol>
<p>這時候產生的(N、e)與(N、d)就分別是RSA加密的兩把鑰匙</p>
<p>在這裡為了方便舉例我們用一個很小的數來理解：</p>
<ol>
<li>使p=13、q=17，N=pq=221</li>
<li>r=(p-1)(q-1)=12*16=192</li>
<li>選一個小於192(r)的整數187(e)，使187(e)與192(r)互質。</li>
<li>求187(e)對192(r)的模反元素：115(d)</li>
<li>銷毀p、q</li>
</ol>
<p>產生的(221、187)與(221、115)就分別是這次RSA加密的公私鑰。(模反元素可以透過<a href="https://planetcalc.com/3311/">這裡</a>線上運算，integer填e、modulus填r)，現在我們得到(221、187)為公鑰、(221、115)為私鑰</p>
<h2 id="rsa加密-1"><a class="header" href="#rsa加密-1">RSA加密</a></h2>
<p>加密的過程中，先把要加密的訊息編碼成為一個&lt;N而且&gt;0的整數，如果訊息太長就切割，接著利用下面式子把n加密成密文cipher</p>
<blockquote>
<p>cipher ≡ n^e mod(N)</p>
</blockquote>
<p>如果透過公鑰(221、187)加密100這個數，就會得到cipher≡100^187 mod(221)，cipher(密文)就是9</p>
<h2 id="rsa解密"><a class="header" href="#rsa解密">RSA解密</a></h2>
<p>解密的過程其實就是用另一把鑰匙反過來運算</p>
<blockquote>
<p>n ≡ cipher^d mod(N)</p>
</blockquote>
<p>如果透過另一把私鑰(221、115)解密9這個數，就會得到n≡9^115 mod(221)，n就是100，原始明文就被解出來了！所以只有在兩把鑰匙相互對應的狀況下可以互相解密，這裡示範的是公鑰加密、私鑰解密，也就是傳私訊給對方，但又確保了只有對方收的到。</p>
<h2 id="要如何攻擊rsa"><a class="header" href="#要如何攻擊rsa">要如何攻擊RSA?</a></h2>
<p>如果攻擊者想要攻擊RSA的話，他想透過竊得的密文cipher與竊取到的整數N(221)與公鑰e(187)破解另一把私鑰d(115)，他只能透過下面這個公式：</p>
<blockquote>
<p>de ≡ 1 mod(r)</p>
</blockquote>
<p>因為r=(p-1)*(q-1)也就是代換成：</p>
<blockquote>
<p>de ≡ 1 mod((p-1)*(q-1))</p>
</blockquote>
<p>為了破解私鑰，攻擊者必須先求出p與q的值。還記得N=pq嗎？但因為N是一個非常大的數，也是由p與這q兩個非常大的質數相乘而得，這導致了N要運算回p與q非常困難，因此利用<strong>兩個大質數相乘後很難拆解回原本的兩質數來保證了RSA的安全性</strong> ，所以N的大小也決定了加密被破解的難易度。</p>
<p>這裡我們就不對RSA加密法的正確性做嚴謹的證明，如果你對數學的證明有興趣可以參考<a href="http://pajhome.org.uk/crypt/rsa/maths.html">這裡</a>。如果你還不是很熟悉的話，<a href="https://www.cryptool.org/en/cto-highlights/rsa-step-by-step">這個網站</a>可以幫助你一步步做下來。</p>
<h1 id="橢圓公式elliptic-curve-cryptographyecc"><a class="header" href="#橢圓公式elliptic-curve-cryptographyecc">橢圓公式(Elliptic Curve Cryptography，ECC)</a></h1>
<p>計算完RSA後我們可以得知：非對稱加密是透過數學運算上的不可逆來打造安全性的，同時私鑰可以很容易的產生公鑰、公鑰卻無法反推回私鑰。同樣具有這個特性的還有數學上的橢圓公式(Elliptic Curve)，而且相較於RSA，ECC可以使用更少的位元數達到比RSA更強的安全性，同時在加解密的速度上也比RSA快上許多，在寸土寸金的區塊鏈上這個特性就更加重要，因此目前幾個主流的公鏈像是Bitcoin或Ethereum裡產生公私鑰的非對稱加密主要都是透過橢圓公式來達成了。</p>
<h2 id="橢圓公式概論"><a class="header" href="#橢圓公式概論">橢圓公式概論</a></h2>
<p><code>橢圓公式</code>跟我們之前學的橢圓是不一樣的，典型橢圓公式的定義如下：</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=y%5E2%3Dax%5E3%2Bbx%5E2%2Bcx%2Bd" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=y%5E2%3Dax%5E3%2Bbx%5E2%2Bcx%2Bd" /></p>
<p>你可以在<a href="https://www.desmos.com/calculator">這個網站</a>上畫出橢圓公式的圖形，比方說</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=y%5E2%3Dx%5E3%2B2x%5E2-5x%2B1" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=y%5E2%3Dx%5E3%2B2x%5E2-5x%2B1" /></p>
<p>就可以畫成：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day15_1.jpg" alt="Elliptic Curve" /></p>
<h2 id="橢圓公式的加法定理"><a class="header" href="#橢圓公式的加法定理">橢圓公式的加法定理</a></h2>
<p>這裡我們只看會用到的加法，詳細的數學運算與推導有興趣可以參考<a href="https://www.cnblogs.com/Kalafinaian/p/7392505.html">這裡</a>。橢圓曲線上加法P+Q=R的定義是連接兩點P、Q的直線，可以得到與該直線相交的曲線另外一點R'，把R'的Y座標取負號得到的點就是R。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day15_2.jpg" alt="Elliptic Curve" /></p>
<p>如果P=Q的情形下，P就代表橢圓切線上的切點，可以得到另外一點2P。同樣的2P可以繼續進行2P+P=3P來計算3P的座標。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day15_3.jpg" alt="Elliptic Curve" /></p>
<h2 id="橢圓公式的離散"><a class="header" href="#橢圓公式的離散">橢圓公式的離散</a></h2>
<p>在電腦科學中，資料的點不若幾何上的連續，資料點是離散的，因此我們在離散化的橢圓公式加入取餘數與同餘的概念，詳細的數學運算與推導有興趣同樣可以參考<a href="https://www.cnblogs.com/Kalafinaian/p/7392505.html">這裡</a>。</p>
<p>這裡另外定義一個名詞"階"，指的是如果存在一個整數n，可以使np出現在無窮遠處或無法交出第三點，則n為p的"階"，如果不存在就稱p是無限階。</p>
<h2 id="橢圓公式的不可逆"><a class="header" href="#橢圓公式的不可逆">橢圓公式的不可逆</a></h2>
<p>如果我們有個式子為nP=Q，P跟Q跟上面的定義一樣都是橢圓曲線上的點，N是P的階，同時n&lt;N(代表nP必定可以交出Q)，如果給定n與P，透過加法運算nP可以很快地取得Q。但如果反過來給的是Q與P，要計算n相當困難(實際上的p與N都會很大)。</p>
<p>所以對應這時候的P，n其實就是私鑰、Q點就是公鑰，要從私鑰解出公鑰非常容易，但要從公鑰反推私鑰就很困難了！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-12"><a class="header" href="#ref-12">Ref:</a></h1>
<ul>
<li><a href="https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/246717/">對稱加密與非對稱加密優缺點詳解</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理（一）</a></li>
<li><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">Wikipedia-RSA</a></li>
<li><a href="https://sites.google.com/site/danzcosmos/proof-of-the-rsa-algorithm">Proof of the RSA Algorithm</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">維基百科-歐拉函數</a></li>
<li><a href="https://medium.com/@RiverChan/%E5%9F%BA%E7%A4%8E%E5%AF%86%E7%A2%BC%E5%AD%B8-%E5%B0%8D%E7%A8%B1%E5%BC%8F%E8%88%87%E9%9D%9E%E5%B0%8D%E7%A8%B1%E5%BC%8F%E5%8A%A0%E5%AF%86%E6%8A%80%E8%A1%93-de25fd5fa537">基礎密碼學(對稱式與非對稱式加密技術)</a></li>
<li><a href="https://www.itread01.com/content/1547537909.html">區塊鏈中的密碼學（三）-橢圓曲線加密算法分析</a></li>
<li><a href="https://medium.com/cryptocow/exploring-elliptic-curve-pairings-e322a3f029e8">探索橢圓曲線對</a></li>
<li><a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography</a></li>
<li><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/43964/">橢圓曲線加密演算法</a></li>
<li><a href="https://www.itread01.com/content/1546294330.html">橢圓曲線加密演算法</a></li>
<li><a href="https://www.cnblogs.com/Kalafinaian/p/7392505.html">ECC椭圆曲线详解(有具体实例)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day15密碼學初探8零知識證明"><a class="header" href="#day15密碼學初探8零知識證明">Day15|密碼學初探(8)：零知識證明</a></h1>
<h1 id="沒有隱私的交易"><a class="header" href="#沒有隱私的交易">沒有隱私的交易</a></h1>
<p>打開<a href="https://etherscan.io/address/0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c">Ethereum區塊瀏覽器任意點一個地址</a>，你會發現該錢包地址所有的交易紀錄、收款、匯款的明細通通被攤在陽光下，因為區塊鏈上的帳本人人都可以擁有，舉凡所有的交易、金流全部都公開透明，要了解一個地址的使用情形非常容易：只要點開區塊鏈瀏覽器就可以了。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day16_1.jpg" alt="Etherscan" /><br />
圖片擷取自：<a href="https://etherscan.io/">Etherscan</a></p>
<p>但問題來了，如果這是一間公司的錢包地址，那麼這間公司的所有收入與支出都會攤在對手的眼皮底下，也就是說這間公司的營業額、客單價、消費人數、成本結構等機密資訊都可以輕易地被任何人取得。換算成個人的例子就是：如果你的錢包地址外流，那麼你在何時向誰支付了多少錢、你的戶頭裡還剩多少錢通通可以透過查詢區塊鏈得知。</p>
<p>即使區塊鏈的特色之一就是公開透明、無法竄改，但很明顯的，某些交易或資訊我們還是不希望外界知道。如果不希望外界知道的話，交易明細也必須對礦工保密，但如果連礦工都不知道發起人與收款人是誰、款項多少，那他恐怕也無法幫我們確認餘額是否足夠、是否為本人簽發，這樣不就沒辦法發起交易了嗎？</p>
<p>有沒有辦法在礦工不知道交易細節的狀況下仍然可以讓礦工驗證交易？方法是有的，在沒有任何交易相關資訊的前提下說服礦工這筆交易是合法的，這就是<code>零知識證明</code>。</p>
<h1 id="零知識證明zero-knowledge-proofs"><a class="header" href="#零知識證明zero-knowledge-proofs">零知識證明(Zero-Knowledge Proofs)</a></h1>
<p>零知識證明的定義是：<strong>不提供任何有關訊息的資料，但仍然可以說服對方該筆訊息是正確的。</strong></p>
<p>最普遍的舉例就是如果前面有一個U字型的通道，通道正中間有一道上鎖的鐵門，那你如何在不出示任何有關鑰匙的資訊下說服驗證者你手上有鑰匙？在這裡有個簡單的方法：不論驗證者要你從A出口或B出口出來你都可以做到，便可以說服驗證者你手上有鑰匙了(即便他連鑰匙或開門的動作都沒看到)！</p>
<p><img src="images/day15_25647.png" alt="ZKP Demo" /><br />
圖片來源：<a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof">Wikipedia</a></p>
<p>零知識證明在區塊鏈上的應用就是在沒有出示任何交易明細的情形下，說服礦工我們有權力動用這筆錢並發起匯款，也就是交易的紀錄就被隱藏，藉此保障了隱私。</p>
<h2 id="同態隱藏homomorphic-hidings"><a class="header" href="#同態隱藏homomorphic-hidings">同態隱藏(Homomorphic Hidings)</a></h2>
<p><code>同態隱藏</code>是零知識證明的核心，滿足同態隱藏的函式f(x)有三個定義：</p>
<ol>
<li>透過f(x)很難反推出x</li>
<li>不同的x會導致不同的f(x)</li>
<li>如果知道f(x)與f(y)的值，就可以算出f(x+y)</li>
</ol>
<p>為了幫助理解，我們可以想像成x與y是我們需要保密的兩筆資訊，但同時我們又需要向外界證明我們手上有這兩筆資料。因此我們可以透過滿足同態隱藏的函式f傳遞加密過後的f(x)與f(y)給對方，對方可以計算f(x+y)的值來知道我們手上這兩筆資料的和的確是x+y，但又無法確知x與y的值。最後結果就是我們在沒有洩漏x與y的狀況下說服對方認可我們手上x與y的和的確是x+y。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day16_2.png" alt="Homomorphic Hidings" /></p>
<p>比方說我們現在有兩個數123、321想要隱藏，但又想要說服別人我們手上這兩個數的和是444的話，我們可以透過計算f(123)與f(321)的值給對方後，讓對方透過f(123)與f(321)去計算f(x+y)的值是否為f(444)，如果是的話就可以說服對方了。同時同態隱藏的定義之一便是透過f(x)很難反推x，因此即便我們把f(123)與f(321)給出去，對方也很難反推出123與321的值。另外也因為不同的x會導致不同的f(x)，如果f(x+y)算出來的確是f(444)，就可以肯定x、y的和的確就是444而且沒有其他可能。</p>
<p>但一般的加減乘除無法滿足同態隱藏，因此計算上必須導入取餘數的概念，有興趣看完整推導的話可以參考<a href="https://electriccoin.co/blog/snark-explain/">這裡</a>。</p>
<h2 id="zk-snarks"><a class="header" href="#zk-snarks">zk-SNARKs</a></h2>
<p>第一個利用零知識證明來做到交易匿蹤性的是<a href="https://www.zfnd.org/">ZEC</a>，其中的演算法便是<code>zk-SNARKs</code>，但因為ZEC的新區塊獎勵會有大約20%進入基金會的口袋以支持運作，部分支持者不滿這種行為於是分岔出了<a href="https://zclassic.org/">ZCL</a>，因此兩者的加密法與架構都是一致的。(順帶一提，我覺得ZEC的行為是很合理的、ZCL倒有點小題大作，研究與開發不可能只靠熱情就能持續，還是要有銀彈支撐)</p>
<p>zk-SNARKs是<code>zero knowledge Succinct Non-interactive ARgument of Knowledge</code>的縮寫(<del>實在有夠長</del>)，這幾個詞分別代表了：Succinct(簡潔，用很少的資料量可以完成整個溝通與驗證)、Non-interactive(只需要很少刺或不需要與原始發送者溝通即可驗證訊息)、ARgument(只在計算上是安全的，如果遇到一個計算能力極強的攻擊者會失效)。</p>
<p>想更了解zk-SNARKs可以參考<a href="https://z.cash/technology/zksnarks/">ZEC的官網</a>，或是中文資料對你比較友善的話也可以參考<a href="https://medium.com/taipei-ethereum-meetup/%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3-zk-snarks-7a0187f399f1">這裡</a>。<br />
關於零知識證明更多的資料，這裡有一份<a href="https://people.eecs.berkeley.edu/~sanjamg/classes/cs294-spring16/scribes/6.pdf">Berkley的上課講義</a>，有興趣可以參考一下(<del>順便看一下國外頂尖大學是怎麼上課的</del>)。</p>
<h2 id="犯罪者的溫床"><a class="header" href="#犯罪者的溫床">犯罪者的溫床</a></h2>
<p>保障了交易雙方隱私的同時，也往往成為犯罪者洗錢的溫床，為了避免洗錢也有許多國家希望能夠禁止匿蹤幣在交易所的流通(<a href="https://www.forbes.com/sites/adelsteinjake/2018/04/30/japans-financial-regulator-is-pushing-crypto-exchanges-to-drop-altcoins-favored-by-criminals/">資料來源</a>)，雖然你可能會有疑問，之前盛行的勒索軟體為什麼不直接勒索匿蹤貨幣就好？原因是匿蹤幣的流通量都比較小眾，相對使用的門檻也高一點，攻擊者如果要受害者去買一個他不知道要怎麼買、怎麼用的東西往往太強人所難......</p>
<h1 id="幾種匿蹤性貨幣"><a class="header" href="#幾種匿蹤性貨幣">幾種匿蹤性貨幣</a></h1>
<p>接下來我們簡單介紹一下目前幾種主流的匿蹤貨幣：</p>
<h2 id="zec"><a class="header" href="#zec">ZEC</a></h2>
<p>ZEC最有名的就是它的錢包地址也可以分成兩種：<code>透明地址</code>與<code>隱私地址</code>，因此對應到四種交易種類，因為匿蹤需要耗費更多的運算資源與運算時間，因此ZEC透過手續費的機制讓使用者選擇要透明的交易(手續費較少)或是隱私的交易(手續費較多)，這四種交易形式分別如下圖。</p>
<p><img src="images/day15_33464.png" alt="Zec Transaction Type" /><br />
圖片來源：<a href="https://electriccoin.co">electriccoin</a></p>
<p>共區分成：</p>
<ol>
<li>Public: 匯款、收款雙方都是透明的。</li>
<li>Shielding: 收款方式保密的。</li>
<li>Deshielding: 匯款方是保密的。</li>
<li>Private: 匯款、收款雙方都是保密的。</li>
</ol>
<p>你可以到<a href="https://explorer.zcha.in/">ZEC的區塊瀏覽器</a>找找看是否能夠找到我們上面提到的這四種交易(實際上有匿蹤的交易很少，大家為了省手續費基本上都用Public)。</p>
<h2 id="moneroxmr"><a class="header" href="#moneroxmr">Monero(XMR)</a></h2>
<p>XMR主要使用了三個技術來保障隱私：</p>
<ol>
<li>Ring Signature</li>
<li>Ring Confidential Transactions</li>
<li>Stealth Address</li>
</ol>
<p>XMR的有趣之處在於你可以利用私鑰為每一次的收款產出<code>一次性的地址</code>(有點類似劃撥的概念)，透過生成無限多地址的能力，讓外界無從猜測那些地址是屬於那些人的。<a href="https://moneroblocks.info/">XMR的區塊瀏覽器</a>在此，對相關技術細節有興趣的話可以參考<a href="https://medium.com/taipei-ethereum-meetup/monero-%E9%96%80%E7%BE%85%E5%B9%A3-%E9%9A%B1%E5%8C%BF%E4%BA%A4%E6%98%93%E7%9A%84%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9-423451f4e8b4">這裡</a></p>
<h2 id="dash"><a class="header" href="#dash">Dash</a></h2>
<p>Dash的匿蹤性是靠著把要發送給別人的錢通通參在一起，比方說現在A要匯款給B、C要匯款給D，為了隱私就先把AB要匯的錢<code>混在一起(mix)</code>再從中撥款給C與D，於是外界就區分不出來A或C的款項原本是要匯給誰了！</p>
<p>你可能會有疑問，那如果A與B的金額不一樣，那不就穿幫了嗎。事實不然，Dash會把交易金額切割承夠細夠小的單位，在讓這些小單位的Dash去做混合(mix)，而這些負責混合的節點又稱為master node。順帶一提，你可以到<a href="https://docs.dash.org/en/stable/masternodes/setup.html">Dash的官方文件</a>上看看怎麼成為Dash的master node，並賺取每年大概6%的Dash，但在成為master node前你要先準備1000 Dash(以現在幣值計算需要快三百萬台幣....)</p>
<p><img src="https://www.lkm543.site/it_iron_man/day16_3.png" alt="Dash" /></p>
<p>下面這張表格是各種匿蹤幣的比較，你也可以發現因為Dash有master node的機制，在分類上並不是去中心化(decentralized)的。</p>
<p><img src="images/day15_18921.jpg" alt="Comparison" /><br />
圖片來源：<a href="https://masterthecrypto.com">masterthecrypto</a></p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-13"><a class="header" href="#ref-13">Ref:</a></h1>
<ul>
<li><a href="https://blocktrend.today/07-17-2018-zero-knowledge-proof-intro">看懂零知識證明（zero-knowledge proofs）</a></li>
<li><a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof">Wikipedia-Zero-knowledge proof</a></li>
<li><a href="https://electriccoin.co/blog/snark-explain/">Explaining SNARKs Part I: Homomorphic Hidings</a></li>
<li><a href="https://hackmd.io/4DLJ4mikRni08g5s9OukKg">認識零知識證明 - 吳偉誠</a></li>
<li><a href="https://electriccoin.co/blog/anatomy-of-zcash/">Anatomy of A Zcash Transaction</a></li>
<li><a href="https://medium.com/taipei-ethereum-meetup/%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3-zk-snarks-7a0187f399f1">深入瞭解 zk-SNARKs</a></li>
<li><a href="https://www.chainnews.com/articles/931561645479.htm">零知识证明 | 1. 什么是同态隐藏？</a></li>
<li><a href="https://itw01.com/KY5EWNK.html">區塊鏈解讀-零知識證明（－zero-knowledge proof）</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day16關於挖礦的兩三事1原理應用與礦池"><a class="header" href="#day16關於挖礦的兩三事1原理應用與礦池">Day16|關於挖礦的兩三事(1)：原理應用與礦池</a></h1>
<h1 id="挖礦"><a class="header" href="#挖礦">挖礦</a></h1>
<p>在結束完充滿數學又落落長的密碼學初探後，我們先進到比較應用的挖礦稍微喘口氣。先回憶一下我們在第三天所寫的簡易區塊鏈中是這樣挖掘新區塊的：不停計算nonce值，直到我們能夠找到一個符合當下難度的解的nonce。這個過程中如果擁有越強的運算力(or越多的機台)，找到解的機會就越大、獲得的區塊獎勵也會越豐厚。</p>
<p>但這樣會有個問題：如果挖礦的人越來越多，那麼單人/單機挖到區塊的機率也會越來越低，也無法匹敵擁有巨型運算能力的專業戶，那麼區塊鏈圈的大家該如何應對這種情形呢？</p>
<pre><code>while new_block.hash[0: self.difficulty] != '0' * self.difficulty:
    new_block.nonce += 1
    new_block.hash = self.get_hash(new_block, new_block.nonce)
</code></pre>
<h1 id="原生的挖礦"><a class="header" href="#原生的挖礦">原生的挖礦</a></h1>
<p>實際上的區塊鏈在使用者clone並同步完主節點的資料與程式碼後通常裏頭都會內建挖礦的指令，比方說你可以透過用來安裝或同步節點的<a href="https://ethereum.gitbooks.io/frontier-guide/mining_with_geth.html">geth挖礦</a>，而Bitcoin原本跑節點的程式也有提供使用CPU挖礦的功能，但因為CPU挖礦在SHA-256已經毫無競爭力，所以<a href="https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.13.0.md#removal-of-internal-miner">其原生的挖礦程式已經被移除掉</a>。</p>
<h1 id="挖礦方式演變"><a class="header" href="#挖礦方式演變">挖礦方式演變</a></h1>
<p>既然挖礦有利潤，就會有人想要改進原本的挖礦效能與方式，於是坊間各種優化、加速挖礦演算法的軟體與方式也逐漸有人在開發，這裡我們簡單說明一下挖礦方式的演進。</p>
<h2 id="solo-mining"><a class="header" href="#solo-mining">Solo Mining</a></h2>
<p>最古早的挖礦是以單機為單位的，也就是每個機台獨自營運與挖礦，在初期Bitcoin礦工稀少的狀況下大家都是用Solo Mining起家的。Solo Mining的定義是不依靠任何外力幫助或是參與任何集體挖礦的計畫(像是底下提到的礦池)，所以通常自身也會營運一個節點以供新區塊的廣播之用，也因為沒有任何外力幫助，Solo Mining挖到區塊的所產生獎勵也不需要跟別人分配。</p>
<h2 id="proxy挖礦"><a class="header" href="#proxy挖礦">Proxy挖礦</a></h2>
<p>但隨著挖礦的人越來越多，如果你手上還是只有一台機器，那恐怕挖到天花地老也無法挖出新區塊，以Bitcoin為例每年大約出產五萬多個新區塊，如果你的算力不到全網算力的五萬分之一，那恐怕挖一年也挖不出任何東西。於是第一個解決方案就是Proxy(代理伺服器)：</p>
<p><img src="https://hide-ip-proxy.com/wp-content/uploads/2018/04/what-is-proxy-server.png" alt="Proxy" /><br />
圖片來源：<a href="https://hide-ip-proxy.com/what-is-a-proxy-server/">What is a Proxy Server?</a></p>
<p>Proxy的原理就是眾多機台使用一台Server來轉發封包，這樣對外界而言，就好像所有的資訊都是從這台Proxy Server出來，也就是可以讓多人使用同一個Proxy Server達到把許多機器合而為一一起挖礦的效果。</p>
<h2 id="礦池挖礦"><a class="header" href="#礦池挖礦">礦池挖礦</a></h2>
<p>隨著挖礦的人越來越多，開放式、可以自由加入的挖礦方式─礦池也就出現，目前以礦池為單位的挖礦方式已經成為主流，礦池可以分配工作給所有參與人，再把所有機器的工作成果加總起來(下圖)，並同時記錄所有機器的貢獻度，再依據貢獻程度分配挖礦的收益。</p>
<p><img src="https://coinrevolution.com/wp-content/uploads/2018/11/Understanding-Mining-Pools-and-How-They-Work-%E2%80%93-Bitzamp.jpg" alt="Mining Pool" /><br />
圖片來源：<a href="https://coinrevolution.com/what-is-a-bitcoin-mining-pool/">Coinrevolution.com</a></p>
<p>但這樣的方式也引起了一些批評與爭議，目前主要的區塊產出通通都是由礦池負責，下圖是今年Ethereum各大礦池挖出新區塊的比例：</p>
<p><img src="images/day16_93753.png" alt="Mining Pool" /><br />
圖片來源：<a href="https://www.buybitcoinworldwide.com/ethereum/mining-pools/">buybitcoinworldwide</a></p>
<p>前三大礦池(Eth-Pool、F2Pool、Dwarf Pool)就佔據了超過50%的的算力，原先以去中心化為號招的區塊鏈，卻因為礦池似乎又變成中心化了？</p>
<h3 id="stratum的出現"><a class="header" href="#stratum的出現">Stratum的出現</a></h3>
<p>在礦池的出現並且一步步成為主流方式的背景裡，Stratum的出現功不可沒，Stratum讓想要參與挖礦的礦工不再需要營運一個完整的節點、也不需要去驗證或取得每筆交易的打包或驗證，只需要承擔礦池所分派計算哈希值的工作即可，極大的減少了礦工參與挖礦的門檻。</p>
<p>在<a href="https://bitcoin.org/en/mining-guide">Bitcoin Org</a>裏頭有這一段話敘述了Stratum的功用：</p>
<blockquote>
<p>Unlike getblocktemplate, miners using Stratum cannot inspect or add transactions to the block they’re currently mining. Also unlike getblocktemplate, the Stratum protocol uses a two-way TCP socket directly, so miners don’t need to use HTTP longpoll to ensure they receive immediate updates from mining pools when a new block is broadcast to the peer-to-peer network.</p>
</blockquote>
<h3 id="自己建礦池"><a class="header" href="#自己建礦池">自己建礦池</a></h3>
<p>網路上目前已經有<a href="https://github.com/sammy007/open-ethereum-pool">開放原始碼的礦池</a>，也因此目前要建立一個礦池的門檻非常低，但相對而言建立礦池比較需要的是資安方面的人才，畢竟如果礦池被攻破，礦池所持有的虛擬貨幣與帳本都會暴露在攻擊者的掌控下，此外，因為挖礦通常都是24小時不停運作，如何維持礦池的穩定進行也是另外的議題。</p>
<h3 id="建一個eth礦池需要有多少算力"><a class="header" href="#建一個eth礦池需要有多少算力">建一個ETH礦池需要有多少算力</a></h3>
<p>但建礦池不難，也要有人來挖呀！需要多少算力才可以支撐起一個礦池？這個問題就會使用到一點高中數學的概念，假設你擁有全網算力的x(0≦x≦1)，那麼每次出塊你搶到的機會大約也是x、沒有搶到的機會是1-x。也就是說連續q塊沒搶到的機率p會是：</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=p%3D(1-x)%5Eq" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=p%3D(1-x)%5Eq" /></p>
<p>根據出塊時間可以反推每天的總出塊數目，像Ethereum平均15秒出一塊、Bitcoin平均600秒出一塊去推估Ethereum一天可以產生約5760塊、Bitcoin則是只有144塊，因此Ethereum每天至少出一塊的機率為1-(1-x)^5760。</p>
<p>我在<a href="https://www.desmos.com/calculator/k1vv3qylvk">這個網站</a>把式子打出來，有興趣可以參考一下，你只需要調整出塊時間(秒)、希望多久出一塊(天)，該網頁就會自動把你有多少算力時每天至少出一塊的機率圖形繪製出來，實際操作會看到下面這些圖(橫軸代表持有算力是全網算力的10^-n)，以Ethereum為例：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day17_2.jpg" alt="Ethereum Demo" /></p>
<p>在機率=0.99的狀態下，n大約為-3.097，大約需要0.08%的全網算力。</p>
<p>以Bitcoint出塊時間600秒/10分鐘為例：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day17_3.jpg" alt="Bitcoin Demo" /></p>
<p>在機率=0.99的狀態下，n大約為-1.502，大約需要3.15%的全網算力。</p>
<p>那如果你同樣擁有Bitcoin、Ethereum各0.1%的全網算力，那麼Bitcoin每天至少挖到一塊的機率是13.4%，然而對於Ethereum，同樣情形下卻有99.7%的機率，幾乎能保證每天至少會挖到一塊。</p>
<p>在期望每天有99%機率會出一塊的前提下，建設礦池挖掘Bitcoin需要3.15%全網的算力、Ethereum只需要全網0.08%的算力，相較起來Ethereum架設礦池所需要的算力門檻低上許多，這也是為什麼自架礦池在Ethereum比較盛行的原因。</p>
<p>ETH的全網算力可以在<a href="https://etherscan.io/chart/hashrate">這裡</a>查詢，但其實這裡的算力並不是真正的算力，區塊鏈並沒有辦法知道有多少機器在挖礦，你看到的全網算力是透過目前難度與平均出塊時間反推出來的。</p>
<h1 id="挖礦硬體"><a class="header" href="#挖礦硬體">挖礦硬體</a></h1>
<p>談完挖礦從Solo Mining→Proxy Ming→Pool Mining的發展後，我們來談談單機的變化，也就是挖礦用的硬體。</p>
<h2 id="cpu與gpu"><a class="header" href="#cpu與gpu">CPU與GPU</a></h2>
<p>初始的挖礦都是在家用電腦上以CPU或GPU來進行(<del>因為也沒別的選擇了</del>)，相較於CPU，GPU在計算哈希上通常有著巨大的優勢，你可以到<a href="https://ark.intel.com/content/www/tw/zh/ark.html#@Processors">這裡</a>查看Intel CPU的核心數目，家用的處理器一般落在4~6個核心上，你也可以到<a href="https://www.nvidia.com/zh-tw/geforce/20-series/">這裡</a>看看Nvidia的GPU核心個數，通常GPU的核心數目會有數千個之多，處理器核心數目的差異可以到一千倍。</p>
<p>可以做個簡單的比喻，如果CPU、GPU是兩家不同的貨運行，CPU擁有的就像是4台大貨車─車數少，但每台車的運量與速度非常強大，GPU擁有的就像是4000台腳踏車─車數多，但每台車的運量與速度不佳。而挖礦就好比要去各個地方探索，直到找到寶藏為止，這時候GPU的數千台腳踏車在尋寶上就有了巨大的優勢。</p>
<h2 id="fpga"><a class="header" href="#fpga">FPGA</a></h2>
<p>FPGA是Field Programmable Gate Array的縮寫，中文叫做"現場可程式化邏輯閘陣列"，FPGA的使用者可以根據實際上的需要跟程式碼，把程式燒進去FPGA裏頭，也就是FPGA的邏輯閘是可以被改變的，透過直接改變邏輯閘能夠讓FPGA的運算效能勝過CPU與GPU，但缺點就是異常昂貴的價格(入門版的就要價十萬起跳，對比CPU與GPU一兩萬的價格)。也因為這個特性通常拿來做IC設計時的驗證，確保實際投產時不會出錯(一投產就十億起跳了，萬萬不能出任何差錯)。</p>
<p>如果使用FPGA來挖礦，速度上會勝過CPU與GPU，但同時算法又可以更改的，也因此在分類上通常會把FPGA介於家用的CPU、GPU與等等會提到的ASIC中間。</p>
<p><img src="images/day16_20217.png" alt="FPGA" /></p>
<p>圖片來源：<a href="https://www.xilinx.com/products/boards-and-kits/alveo.html">Xilink</a></p>
<h2 id="asicapplication-specific-integrated-circuit"><a class="header" href="#asicapplication-specific-integrated-circuit">ASIC(Application-Specific Integrated Circuit)</a></h2>
<p>一般的CPU架構是偏向複雜指令集(CISC)計算、GPU架構偏向簡單指令集(RISC)，會說偏向是因為CPU與GPU裡還是有架構的不同，並沒有一定，像常聽到的ARM架構CPU反而就偏向RISC。</p>
<p>複雜指令集的處理核心可以想像成裏頭有許多複雜的基本語法，簡單指令集的處理核心裏頭是由多種簡單的基本語法構成，比方說複雜指令集裏頭已經有乘法的指令，同時該指令還可以幫助你做記憶體的讀取跟寫入，也就是乘法只需要一個指令集就可以完成；但簡單指令集就只能拆成讀取記憶體、乘法、寫入記憶體三個指令集完成。(CISC與RISC兩者的差異可以參考<a href="https://www.itread01.com/content/1549989571.html">這裡</a>)，總之在CPU、GPU裏頭所有的運算都會被拆成基礎指令集去完成(不過GPU有部分運算會交給電路直接去實作)。</p>
<p>但ASIC不一樣，他把大部分的計算直接透過電路去完成，也就是在設計電路時就把電路直接設計成可進行該運算的模式，透過這種設計方式達到運算時大幅度的效能增加與供耗減少，但也因為它的電路設計是根據某種特定的演算法，因此無法從事其他運算，只能說ASIC是Born to mine. 為挖礦而生的硬體，也是特殊應用積體電路(Application-Specific Integrated Circuit，ASIC)名稱的由來。</p>
<p>對於Bitcoin挖礦而言，ASIC的出現輾過了所有CPU與GPU，讓CPU與GPU挖礦不再有效益，也導致了挖礦硬體極度中心化，因為ASIC的生產主要由幾家ASIC製造商(像是Bitmain、Baikal、Halong Mining......等)所壟斷，生產礦機、經營礦池一條龍的產業讓比特大陸(Bitmain)一間公司甚至掌握了過半的算力(<a href="https://bitcoinist.com/bitmain-51-percent-bitcoin-hashrate/">來源</a>)。為了對抗這種情形社群也有許多應對─包含開發不適合ASIC的演算法、或是更迭參數等，至於如何對抗ASIC則是我們明日介紹的重點。</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-14"><a class="header" href="#ref-14">Ref:</a></h1>
<ul>
<li><a href="https://ethereum.stackexchange.com/questions/40082/how-to-mine-with-geth">How to mine with geth</a></li>
<li><a href="https://medium.com/taipei-ethereum-meetup/%E7%A4%A6%E6%B1%A0%E5%87%BA%E5%A1%8A%E6%A8%99%E6%BA%96-%E7%82%BA%E4%BD%95%E6%98%AF%E5%85%A8%E7%B6%B2%E5%8D%83%E5%88%86%E4%B9%8B%E4%B8%80%E7%AE%97%E5%8A%9B-8baeb704e9b5">礦池出塊標準 為何是全網千分之一算力</a></li>
<li><a href="https://www.blockchain-council.org/blockchain/solo-mining-works/">WHAT IS SOLO MINING &amp; HOW IT WORKS?</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%8E%B0%E5%9C%BA%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E9%97%A8%E9%98%B5%E5%88%97">維基百科-現場可程式化邏輯閘陣列</a></li>
<li><a href="https://cg2010studio.com/2011/10/04/cpu%E8%88%87gpu%E7%9A%84%E6%9E%B6%E6%A7%8B%E4%B9%8B%E6%83%B3%E6%B3%95/">CPU與GPU的架構之想法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day17關於挖礦的兩三事2抗asic演算法"><a class="header" href="#day17關於挖礦的兩三事2抗asic演算法">Day17|關於挖礦的兩三事(2)：抗ASIC演算法</a></h1>
<h1 id="bitcoin被asic攻陷"><a class="header" href="#bitcoin被asic攻陷">Bitcoin被ASIC攻陷</a></h1>
<p>對於Bitcoin而言，一個合規的<code>nonce</code>是這樣被尋找到的：透過不斷改變<code>nonce</code>的值再跟前一個區塊的hash(<code>previous_hash</code>)、所有交易的hash值構成merkle tree的根<code>merkle_root</code>透過SHA-256函式計算哈希值後確認是否合規，直到找到一個合規的<code>found_hash</code>為止(為了方便舉例，除了這三個輸入參數外的都先忽略)。</p>
<blockquote>
<p>found_hash = sha256(previous_hash, merkle_root, nonce)</p>
</blockquote>
<p>也因此運算的瓶頸就在Bitcoin所使用的<code>SHA-256</code>演算法，如果能夠在同一時間大量、重複的運算就可以在挖礦中取得極大的優勢，因此這種計算方式極度適合ASIC，也導致了在<code>ASIC</code>進入挖礦市場後便迅速成為了Bitcoin的主流挖礦硬體，徹底把家用CPU/GPU從這場挖礦大戰中掃了出去。</p>
<p><img src="images/day17_77145.png" alt="ASIC" /><br />
圖片來源：<a href="https://www.bitmain.com/">Bitmain</a></p>
<h2 id="用cpu挖能挖多少"><a class="header" href="#用cpu挖能挖多少">用CPU挖能挖多少？</a></h2>
<p>或許你還是很難想像ASIC與家用CPU/GPU的效能差異，<a href="https://en.bitcoin.it/wiki/Non-specialized_hardware_comparison">這裡</a>頭列了幾個家用硬體的算力值，GPU目前頂多約1000Mh/s、AMD架構的CPU頂多100Mh/s，對比ASIC目前至少有10Th/s起跳的算力(<a href="https://www.bitmain.com/">Bitmain</a>最新的機台甚至可以達到64Th/s)，兩者間的實力整整差了<strong>數萬到數十萬倍</strong> ，也就是你用家用電腦挖一整年Bitcoin大概也只能挖....5塊台幣的Bitcoin。</p>
<p>註：Mh/s：10^6 hash/s ; Gh/s：10^9 hash/s、Th/s ; 10^12 hash/s</p>
<h2 id="asic帶來極度中心化的疑慮"><a class="header" href="#asic帶來極度中心化的疑慮">ASIC帶來極度中心化的疑慮</a></h2>
<p>ASIC除了帶來算力的增長外，同時也壟斷了挖礦的方式，在過去想要參與挖礦與記帳的用戶只需要使用原本的家用電腦便可以參與，但如果現在想要參與挖礦就必須至礦機製造商添購礦機，無形中拉高了一般人參與的門檻，同時也造成了挖礦變成一個極度中心化與專業化的行業，也產生一旦礦機商在挖礦硬體植入後門，整個Bitcoin就會毀於一旦，這些都與原本的去中心化的精神越走越遠，於是乎對抗ASIC的呼聲也越來越大。</p>
<p><img src="images/day17_67784.jpg" alt="Bitmain Centralization" /><br />
圖片來源：<a href="https://medium.com/@jimmysong/mining-centralization-scenarios-b74102adbd36">Mining Centralization Scenarios</a></p>
<h1 id="ethereum如何對抗asic"><a class="header" href="#ethereum如何對抗asic">Ethereum如何對抗ASIC</a></h1>
<p>挖礦的總出塊利潤是固定的，一有利潤就會有人想研製特別的硬體(ASIC)專門投入挖礦來取得比別人更大的優勢，為了對抗ASIC造成後續中心化與門檻提高的問題，<code>Ethereum</code>於是從挖礦的演算法著手，設計出不適合ASIC運算的演算法來抵抗威脅。</p>
<h2 id="dagger-hashimoto演算法"><a class="header" href="#dagger-hashimoto演算法">Dagger-Hashimoto演算法</a></h2>
<p>Ethereum的挖礦演算法叫做<code>Dagger-Hashimoto</code>，簡稱為<code>Ethash</code>，是把Thaddeus Dryja發明的<code>Hashimoto演算法</code>加入Ethereum創始人Vitalik Buterin發明的<code>Dagger演算法</code>後融合而成，特色是挖礦的效率基本上和處理器效能無關，而跟記憶體的頻寬成正相關。</p>
<p>為什麼透過頻寬就可以對抗ASIC呢？因為ASIC的原理是透過處理器電路的設計與數目的堆疊來加大計算固定演算法的速度，因此設計的核心數目越多、製程越高階，處理速度就能夠輾壓家用的CPU與GPU，但同時在這種設計下的記憶體是共用的，也就是說即使計算能力得到了提升，記憶體的速度仍然留在原地。</p>
<p>如果設計出一種以頻寬(傳遞資料的速度，不懂的話可以看<a href="https://www.itsfun.com.tw/%E8%A8%98%E6%86%B6%E9%AB%94%E9%A0%BB%E5%AF%AC/wiki-2351866-7387646">這裡</a>)決定運算能力的算法，因為每塊記憶體的頻寬跟處理器的控制單元數目都是固定的，因此通常增加<strong>記憶體的數目只能加大記憶體的容量，並沒有辦法加大頻寬</strong> ，有點像是一座小島上只有一個港口能靠岸(下圖)，這時候在島上加蓋新房子的確能夠增加容納的人數(記憶體大小)，但運輸的效能(運算能力)取決在港口數目而絲毫沒有改變。要同時移動更多人(增加運算能力)，增加房屋(記憶體數目或容量)是沒有用的，只能增加手上持有的小島(機器)數目，因此ASIC並沒有辦法佔到太多便宜。(但<a href="https://zh.wikipedia.org/zh-tw/%E9%9B%99%E9%80%9A%E9%81%93%E8%A8%98%E6%86%B6%E9%AB%94%E6%8A%80%E8%A1%93">雙通道、四通道</a>的技術就另當別論，而且雙通道或四通道並不適用在有向無環圖演算法)。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day18_1.png" alt="Port" /></p>
<p>我們來簡單說明一下Dagger-Hashimoto演算法是如何實做出來的。</p>
<h2 id="有向無環圖directed-acyclic-graphdag"><a class="header" href="#有向無環圖directed-acyclic-graphdag">有向無環圖(Directed Acyclic Graph，DAG)</a></h2>
<p>在講解Dagger-Hashimoto演算法之前，來談一下有向無環圖(Directed Acyclic Graph，DAG)，一個典型的有向無環圖的定義如下：</p>
<blockquote>
<ol>
<li>該圖形的每條邊都有方向性(有向)</li>
<li>從圖中的任意點出發，無論路徑為何都無法回到起點(無環)</li>
</ol>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c6/Topological_Ordering.svg/1024px-Topological_Ordering.svg.png" alt="DAG" /><br />
圖片來源：<a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">維基百科</a></p>
<p>Ethash的原理就是應用有向無環圖(DAG)，它的設計是每30000個Epoch(~5.2天)就會生成一個稍大一點的DAG，因此每過一個Epoch後為了產生新的DAG都會稍稍延遲，但因為Ethash的DAG只跟目前的區塊高度(數目)有關，為了避免等待，許多挖礦程式也會同時生成兩個DAG以免Epoch更新時的延遲。</p>
<h2 id="hashimoto演算法"><a class="header" href="#hashimoto演算法">Hashimoto演算法</a></h2>
<p>Thaddeus Dryja提出的Hashimoto演算法期望透過I/O(輸入跟輸出)的頻寬來決定挖礦的能力以抵制ASIC，它的哈希算法步驟如下(這裡的⊕就是<a href="https://zh.wikipedia.org/zh-tw/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96">XOR運算</a>、&lt;&lt;與&gt;&gt;分別是<a href="http://tw.gitbook.net/t/python3/article-79.html">位元左移與右移</a>)：</p>
<ol>
<li>輸入前一個區塊的hash(<code>previous_hash</code>)、交易明細組成的Merkle Tree的根<code>merkle_root</code>、欲挖掘的<code>nonce</code>透過<code>SHA-256</code>生成一個初始的<code>hash_initialize</code>(這一步就是Bitcoin產生hash的過程)。</li>
<li>讓i從從0到63，依序把
<ol>
<li><code>hash_initialize</code>右移i個位元</li>
<li>位移後除以交易個數後取餘數就可以得到要取出交易(<code>transaction</code>)</li>
<li>取出該筆的交易(<code>transaction</code>)的交易序號(<code>tx_id</code>)後再左移i個位元</li>
</ol>
</li>
<li>讓取得到的64組位元彼此依序做XOR運算得到最後的交易序號(<code>tx_id_final</code>)</li>
<li>讓<code>nonce</code>左移192個位元</li>
<li>再讓最後的交易序號(<code>tx_id_final</code>)與左移後的<code>nonce</code>做XOR運算</li>
<li>得到最後的<code>final_hash</code></li>
<li>確認<code>final_hash</code>是否合乎規定，不合的話就改變<code>nonce</code>後重新計算一次。</li>
</ol>
<pre><code>hash_initialize = sha256(previous_hash, merkle_root, nonce)
for i in range(0,64):
    shifted_hash = hash_initialize &gt;&gt; i
    transaction = shifted_hash % len(transactions)
    tx_id[i] = get_tx_id(transaction) &lt;&lt; i
tx_id_final = tx_id[0] ⊕ tx_id[1] … ⊕ tx_id[63]
final_hash = tx_id_final ⊕ (nonce &lt;&lt; 192)
</code></pre>
<p>可以發現這個過程不停在讀取區塊鏈上的歷史交易紀錄，也同時在做記憶體的左移與右移，因此記憶體的頻寬決定了Hashimoto演算法的運算速度。</p>
<h2 id="dagger-hashimoto"><a class="header" href="#dagger-hashimoto">Dagger-Hashimoto</a></h2>
<p><code>Dagger-Hashimoto</code>加入Vitalik Buterin發明的<code>Dagger演算法</code>，相較於<code>Hashimoto</code>，<code>Dagger-Hashimoto</code>用一個有向無環圖(DAG)替代掉交易紀錄，也就是讓對歷史交易紀錄的讀寫變成對DAG的讀寫。</p>
<p>對<code>Dagger演算法</code>有興趣進一步了幾的話可以參考<a href="http://www.hashcash.org/papers/dagger.html">這裡</a>。</p>
<p>簡單說明一下<code>Dagger-Hashimoto</code>中產生DAG的步驟：</p>
<ol>
<li>計算出16MB大小的<code>cache</code></li>
<li>透過這16MB的<code>cache</code>生成1GB大小的<code>DAG</code></li>
<li>每隔30000個Epoch，因為硬體的進步就會讓<code>cache</code>跟<code>DAG</code>也長大一些</li>
</ol>
<p>如下圖所示，因為DAG是有方向性而且連續的，其資料的讀寫無法被平行化處理，所以雙通道、四通道的技術很難應用在Dagger-Hashimoto算法之上。比方說你的確可以把整個DAG切割成四個記憶體(RAM)儲存，但檢索時還是得從第一個RAM逐步檢索到最後一個RAM，因此多通道的技術並不能直接適用於DAG(當然你可以透過演算法嘗試解決，比如說紀錄該DAG於每塊記憶體的輸入與輸出藉此加速計算)。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day18_2.png" alt="RAM" /></p>
<h1 id="其他種抗asic演算法"><a class="header" href="#其他種抗asic演算法">其他種抗ASIC演算法</a></h1>
<h2 id="xmr與asic開發商的戰爭"><a class="header" href="#xmr與asic開發商的戰爭">XMR與ASIC開發商的戰爭</a></h2>
<p>XMR(門羅幣)最初採用的是CryptoNight演算法，該演算法的特色是需要一個2mb的cache(快取記憶體)支撐，也因為CPU的cache相較於GPU還是有優勢的，因此在CryptoNight的算法上GPU雖然還是相對有一些優勢，但兩者的差異不大。但CryptoNight終究還是被礦機製造商攻破，開發出了算力高達220Kh/s的<a href="https://www.aliexpress.com/item/32951312898.html">礦機</a>，即便是與算力最高的顯示卡VEGA系列(大概擁有2Kh/s的算力)比較，也整整高出了超過一百倍(更何況大部分顯卡都只有400-700h/s)！</p>
<p>為了應對這種狀況跟未來持續可能發生的威脅，XMR決定每年會固定時間更改參數，徹底杜絕ASIC(還記得ASIC只能運算同算法同參數嗎？)。</p>
<p>下面可以看到XMR改變算法與參數後，一堆ASIC被洗出去造成全網算力驟降的情形：</p>
<p><img src="images/day17_50091.png" alt="XMR" /><br />
圖片來源：<a href="https://www.reddit.com/r/Monero/comments/8aoxhp/bye_bye_asics/">Reddit</a></p>
<h2 id="x11x13x15x17"><a class="header" href="#x11x13x15x17">X11、X13、X15、X17...</a></h2>
<p>另一種對抗ASIC的路線就是混合各種不同的演算法，因為ASIC只能針對特定演算法做優化，於是根據現在的時間、區塊高度、交易紀錄等參數隨機決定要用哪一種算法，藉此來抵制無法隨意切換算法的ASIC。順帶一提，這裡的11、13、15、17分別代表了其中混合了幾種不同的挖礦演算法。</p>
<h1 id="究竟有沒有必要對抗asic"><a class="header" href="#究竟有沒有必要對抗asic">究竟有沒有必要對抗ASIC？</a></h1>
<p>我覺得<a href="https://tokeneconomy.co/is-the-war-against-asics-worth-fighting-b12c6a714bed">這篇整理的觀點非常好</a>，究竟有沒有對抗ASIC的必要一直是熱門的討論議題，兩派的論點大致如下：</p>
<ul>
<li>支持對抗ASIC：
<ol>
<li>ASIC的出現讓一般人參與的門檻拉高</li>
<li>ASIC讓礦機製造商把持多數算力，違背去中心化的精神</li>
</ol>
</li>
<li>反對對抗ASIC：
<ol>
<li>固定更改演算法會有非常大的風險</li>
<li>修改算法後都會造成一陣子算力的流失與低落(因為ASIC剔除後算力下降，但出塊難度尚未來的及調整過來，礦工無利可圖)，此時缺乏算力的情形下非常容易被攻擊。</li>
<li>GPU的礦場也有中心化的問題。</li>
<li>剔除了ASIC只會讓製造商改用FPGA應對，但純對抗沒有辦法徹底解決問題。</li>
<li>ASIC的出現是因為人性的貪婪，是必然而非偶然無法避免。</li>
</ol>
</li>
</ul>
<p>不管ASIC的出現是好是壞，礦工間的戰爭，還在持續著。</p>
<h1 id="ref-15"><a class="header" href="#ref-15">Ref:</a></h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Wikipedia-Directed acyclic graph</a></li>
<li><a href="https://en.bitcoinwiki.org/wiki/Dagger-Hashimoto">Wikipedia-Dagger-Hashimoto</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ethash">Wikipedia-Ethash</a></li>
<li><a href="https://kknews.cc/zh-tw/tech/e3rm89q.html">每天五分鐘，玩轉區塊鏈(14)：以太坊簡介</a></li>
<li><a href="https://ek21.com/news/2/104794/">電腦記憶體雙通道、四通道記憶體對遊戲重要嗎？</a></li>
<li><a href="https://ethereum.stackexchange.com/questions/1993/what-actually-is-a-dag">What actually is a DAG?</a></li>
<li><a href="https://diyhpl.us/~bryan/papers2/bitcoin/meh/hashimoto.pdf">Hashimoto: I/O bound proof of work</a></li>
<li><a href="http://www.hashcash.org/papers/dagger.html">Dagger: A Memory-Hard to Compute, Memory-Easy to Verify Scrypt Alternative</a></li>
<li><a href="https://www.jishuwen.com/d/24xM/zh-tw">以太坊原始碼分析—Ethash共識演算法</a></li>
<li><a href="https://tokeneconomy.co/is-the-war-against-asics-worth-fighting-b12c6a714bed">Is The War Against ASICs Worth Fighting?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day18關於挖礦的兩三事3挖礦實戰"><a class="header" href="#day18關於挖礦的兩三事3挖礦實戰">Day18|關於挖礦的兩三事(3)：挖礦實戰</a></h1>
<h1 id="如何開始挖礦"><a class="header" href="#如何開始挖礦">如何開始挖礦</a></h1>
<p>今天我們來簡單談一下如何挖礦，以及如果有興趣要挖礦的話該怎麼開始以及有那些眉角需要注意！</p>
<h2 id="選擇幣種演算法"><a class="header" href="#選擇幣種演算法">選擇幣種/演算法</a></h2>
<p>參與挖礦的第一步就是選擇想要挖的幣種，現在主流可以挖的幣有BTC、ETH、ZEC、ZCL、XMR、DASH、DCR等，雖說幣種繁多，但只要想挖的幣種使用的演算法是相同的，便可以隨意切換而且算力不會受到任何影響，用演算法區分會比較適當。其中又可以分成三種主流的挖礦方式：ASIC挖礦、Nicehash挖礦以及GPU挖礦。</p>
<h3 id="asic挖礦"><a class="header" href="#asic挖礦">ASIC挖礦</a></h3>
<p>首先是ASIC挖礦，這類幣種代表礦機廠商已經開發出ASIC，而且官方沒有要對抗(修改演算法或參數)的打算，因此已經都被ASIC攻陷，普通家用電腦或已經沒有競爭的空間。而且ASIC買來也只有挖礦的用途，並無法挪作他用，所以一旦礦機商推陳出新，舊機台也只能直接報廢。</p>
<p>如果是ASIC的話，你可以到<a href="https://www.asicminervalue.com/">Asicminervalue</a>查看每種機台的報酬率(像下圖)，沒意外的話報酬率都十分低。即便看起來每月利潤相當豐厚的幣種，也只是因為ASIC還沒大舉進入市面的假象，一旦礦機大舉入市，帳面上的收益會直接崩盤，所以大部分的情況下都應該直接避免購買ASIC，我身邊買ASIC的人通常賺錢的比例....非常低。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day19_2.JPG" alt="ASIC Demo" /></p>
<h3 id="gpu挖礦"><a class="header" href="#gpu挖礦">GPU挖礦</a></h3>
<p>另一種方式是透過家用的顯示卡來挖礦，這種挖礦方式的好處是假使不挖了，GPU還是能夠拿來使用，這類幣種所採用的演算法便是我們昨天提到的Proof by bandwidth或是利用多種演算法交錯來抵禦ASIC，也因為尚未被ASIC大舉進攻，通常個體挖礦也還能夠保持一定的收益，你可以在<a href="https://whattomine.com/">Whattomine</a>裡查看每一張顯卡或算力的收益，比方說一張<a href="https://www.amd.com/zh-hant/products/graphics/radeon-rx-570">AMD RX570</a>就可以在<a href="https://whattomine.com/coins?utf8=%E2%9C%93&amp;adapt_q_380=0&amp;adapt_q_fury=0&amp;adapt_q_470=0&amp;adapt_q_480=0&amp;adapt_q_570=1&amp;adapt_570=true&amp;adapt_q_580=0&amp;adapt_q_vega56=0&amp;adapt_q_vega64=0&amp;adapt_q_vii=0&amp;adapt_q_1050Ti=0&amp;adapt_q_10606=0&amp;adapt_q_1070=0&amp;adapt_q_1070Ti=0&amp;adapt_q_1080=0&amp;adapt_q_1080Ti=0&amp;adapt_q_1660=0&amp;adapt_q_1660Ti=0&amp;adapt_q_2060=0&amp;adapt_q_2070=0&amp;adapt_q_2080=0&amp;adapt_q_2080Ti=0&amp;eth=true&amp;factor%5Beth_hr%5D=27.9&amp;factor%5Beth_p%5D=120.0&amp;zh=true&amp;factor%5Bzh_hr%5D=19.0&amp;factor%5Bzh_p%5D=100.0&amp;cnh=true&amp;factor%5Bcnh_hr%5D=640.0&amp;factor%5Bcnh_p%5D=110.0&amp;cng=true&amp;factor%5Bcng_hr%5D=640.0&amp;factor%5Bcng_p%5D=110.0&amp;cnr=true&amp;factor%5Bcnr_hr%5D=730.0&amp;factor%5Bcnr_p%5D=120.0&amp;cnf=true&amp;factor%5Bcnf_hr%5D=1250.0&amp;factor%5Bcnf_p%5D=110.0&amp;eqa=true&amp;factor%5Beqa_hr%5D=85.0&amp;factor%5Beqa_p%5D=100.0&amp;cc=true&amp;factor%5Bcc_hr%5D=0.0&amp;factor%5Bcc_p%5D=0.0&amp;cr29=true&amp;factor%5Bcr29_hr%5D=0.0&amp;factor%5Bcr29_p%5D=0.0&amp;ct31=true&amp;factor%5Bct31_hr%5D=0.2&amp;factor%5Bct31_p%5D=100.0&amp;eqb=true&amp;factor%5Beqb_hr%5D=13.0&amp;factor%5Beqb_p%5D=110.0&amp;ns=true&amp;factor%5Bns_hr%5D=700.0&amp;factor%5Bns_p%5D=140.0&amp;bcd=true&amp;factor%5Bbcd_hr%5D=8.6&amp;factor%5Bbcd_p%5D=110.0&amp;tt10=true&amp;factor%5Btt10_hr%5D=11.5&amp;factor%5Btt10_p%5D=110.0&amp;x16r=true&amp;factor%5Bx16r_hr%5D=6.5&amp;factor%5Bx16r_p%5D=110.0&amp;phi2=true&amp;factor%5Bphi2_hr%5D=0.0&amp;factor%5Bphi2_p%5D=0.0&amp;xn=true&amp;factor%5Bxn_hr%5D=0.0&amp;factor%5Bxn_p%5D=0.0&amp;hx=true&amp;factor%5Bhx_hr%5D=6.6&amp;factor%5Bhx_p%5D=110.0&amp;zlh=true&amp;factor%5Bzlh_hr%5D=12.5&amp;factor%5Bzlh_p%5D=100.0&amp;ppw=true&amp;factor%5Bppw_hr%5D=6.7&amp;factor%5Bppw_p%5D=130.0&amp;x25x=true&amp;factor%5Bx25x_hr%5D=0.7&amp;factor%5Bx25x_p%5D=75.0&amp;mtp=true&amp;factor%5Bmtp_hr%5D=0.0&amp;factor%5Bmtp_p%5D=0.0&amp;lrev3=true&amp;factor%5Blrev3_hr%5D=33.5&amp;factor%5Blrev3_p%5D=120.0&amp;factor%5Bcost%5D=0.1&amp;sort=Profitability24&amp;volume=0&amp;revenue=24h&amp;factor%5Bexchanges%5D%5B%5D=&amp;factor%5Bexchanges%5D%5B%5D=binance&amp;factor%5Bexchanges%5D%5B%5D=bitfinex&amp;factor%5Bexchanges%5D%5B%5D=bitforex&amp;factor%5Bexchanges%5D%5B%5D=bittrex&amp;factor%5Bexchanges%5D%5B%5D=cryptobridge&amp;factor%5Bexchanges%5D%5B%5D=dove&amp;factor%5Bexchanges%5D%5B%5D=exmo&amp;factor%5Bexchanges%5D%5B%5D=gate&amp;factor%5Bexchanges%5D%5B%5D=graviex&amp;factor%5Bexchanges%5D%5B%5D=hitbtc&amp;factor%5Bexchanges%5D%5B%5D=hotbit&amp;factor%5Bexchanges%5D%5B%5D=ogre&amp;factor%5Bexchanges%5D%5B%5D=poloniex&amp;factor%5Bexchanges%5D%5B%5D=stex&amp;dataset=Main&amp;commit=Calculate">這裡</a>看到它的算力與利潤分別為多少，評估後再決定要不要下去。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day19_1.JPG" alt="RX 570 Demo" /></p>
<h3 id="nicehash挖礦"><a class="header" href="#nicehash挖礦">Nicehash挖礦</a></h3>
<p>另一種挖礦方式是持有硬體，但不直接參與特定的礦池挖礦，而是透過<a href="https://www.nicehash.com/">Nicehash</a>這個算力租賃平台把自身的算力售予別人，Nicehash在接受到你的算力後，會直接結算BTC給你，對於想要直接獲取BTC的人實在方便許多，同時也提供了一種利用GPU來獲取BTC的方式。Nicehash比較特殊的作法是它會檢測你每一張顯示卡對於各個演算法下的效能，接著根據購買者對於每個演算法的出價決定我們的顯示卡究竟要採用哪個演算法。</p>
<p><img src="images/day18_18040.png" alt="Nicehash" /></p>
<p>圖片來源：<a href="https://www.inverse.com/article/39221-nicehash-robbed-of-78-million-worth-of-bitcoin">inverse.com</a></p>
<p>Nicehash的另一種使用方式就是購買別人的算力，通常是礦池在剛始建立時缺乏算力而無法穩定出塊與吸引其他人加入時會使用到，<a href="https://justhodl.blogspot.com/2018/03/nicehash-buy-hashrate-mining.html">這裡</a>有詳細的買算力教學，有興趣的話可以閱讀，不過另一種用法就是被攻擊者拿來租借後進行51%攻擊了(之後會再詳述)。</p>
<h3 id="ethereum的算力預估"><a class="header" href="#ethereum的算力預估">Ethereum的算力預估</a></h3>
<p>目前主流的個體挖礦都是Ethereum了，因此下面的教學主要都是以ETH為主，這裡提供一個簡單的方式去粗略預估每種顯卡的算力：把顯卡的<code>記憶體頻寬除以8000Bytes</code>便是大概的算力值(h/s，每秒可以算幾個hash)。原理就是我們昨天說的─Dagger-Hashimoto演算法是Proof by bandwidth，因此根據顯卡的頻寬就能夠大概把算力估計出來(但只有在軟體已經針對硬體優化過的狀況下適用)。</p>
<p>以RX570為例，你可以在<a href="https://www.techpowerup.com/gpu-specs/radeon-rx-570.c2939">這裡</a>看到RX570的頻寬大約是224GB/s，除以8000 Bytes後便大約是28 Mh/s，跟實際上超頻後的最大值31Mh/s相距不遠。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day19_3.JPG" alt="570 Spec" /></p>
<p>至於另一張家用神卡<a href="https://www.geforce.com/hardware/desktop-gpus/geforce-gtx-1050-ti/specifications">1050ti</a>的記憶體頻寬約在112GB/s上下，換算出的算力大約14Mh/s。</p>
<h2 id="選擇硬體"><a class="header" href="#選擇硬體">選擇硬體</a></h2>
<p>選擇好欲挖掘的幣種與演算法後，接著就可以來選擇要添購的硬體，這裡我們以Ethereum為例，組成礦機的過程大致上跟組裝一台電腦一樣，但在同一台主機上我們可能會插上十幾張顯卡！</p>
<h3 id="cpuramssd網路"><a class="header" href="#cpuramssd網路">CPU、RAM、SSD、網路</a></h3>
<p>為了讓礦機能夠順利運行，因此一般電腦的零組件是不可少的，但又為了節省成本，因此在CPU、RAM、SSD、網路選擇最基本/廉價的硬體即可，也就是通常只會搭配4GB的RAM與128GB的SSD(建議不要用HDD，不然等待重開機的過程會讓你想死)，CPU大部分人都選用便宜堪用的<a href="https://ark.intel.com/content/www/tw/zh/ark/products/97452/intel-celeron-processor-g3930-2m-cache-2-90-ghz.html">G3930</a>，只要1000出頭便可以入手。網路的部分也是一樣，因為現今的挖礦幾乎都採用了我們前幾天提到的Stratum協定，因此一台礦機只需要幾KB的上下載速度便足夠了！</p>
<h3 id="主機板"><a class="header" href="#主機板">主機板</a></h3>
<p>主機板的使用就一個要點：能夠接上GPU的PCIE插槽越多越好，因為主機零件(CPU、RAM、SSD)是有成本的，如果能夠在一台主機上插上越多的GPU，就代表每張GPU需要攤提的主機成本就越低也越有競爭力，主流八卡機是採用<a href="https://www.asus.com/tw/Motherboards/ROG-STRIX-B250H-GAMING/">B250H Gaming</a>這張主機板，但其實上面只有六個PCIE插槽，其餘兩個需要從M.2轉接。專業或想要挑戰的人可以選用<a href="https://www.asus.com/us/Motherboards/B250-MINING-EXPERT/">ASUS Mining Expert</a>，上頭甚至有19個PCIE插槽！雖然說插槽數一多成本也下降，但隨之而來除錯上的困難也是必須考慮的。</p>
<h3 id="psu電源供應器"><a class="header" href="#psu電源供應器">PSU(電源供應器)</a></h3>
<p>PSU(電源供應器)的使用只有兩個要點：務必足瓦、請使用金牌以上認證的PSU。足瓦是為了保證供電是有餘裕的避免突波造成電器的損壞，如果瓦數不足有時候會透過雙電源啟動線(下圖)來提供足夠的供電(畢竟如果你真的用了19張顯示卡在Mining Expert那張板子上，光靠一台電源供應器一定是推不動的。)，金牌以上的電源供應器是為了保證電源使用的效率，畢竟電費是開始挖礦後最大的開支，因此電源的轉換效率會直接決定日後的電費多寡。</p>
<p>補充說明一下：80PLUS的認證依序可以分成：銅牌、銀牌、金牌、白金、鈦金，通常越往上電源轉換效率越好、越省電，但價格也會越高。</p>
<p><img src="images/day18_68573.jpg" alt="雙電源啟動線" /><br />
圖片來源：<a href="https://www.armygroup.com.tw/shop/goods-3598.html">改裝軍團</a></p>
<h3 id="gpu"><a class="header" href="#gpu">GPU</a></h3>
<p>在確保你的GPU有辦法提供你想要的算力與性價比後(通常是RX570、RX580、GTX 1060、GTX1070)，GPU的選用主要有兩點：保固期與記憶體廠牌，保固期決定了你的顯示卡能夠被使用多久，即便損壞你還是能夠跟原廠換一張新的過來，而記憶體的製造商主要有三大廠，一般而言：<code>三星&gt;美光&gt;海力士</code>。因為對於Ethereum的算法而言，記憶體的頻寬是重要的，而在實測上三星與美光能夠超頻並提供高一點的算力(其中三星又&gt;美光)，而海力士則幾乎不能超頻。</p>
<h2 id="選擇作業系統"><a class="header" href="#選擇作業系統">選擇作業系統</a></h2>
<p>作業系統的選用除了常見的Windows與Linux外，目前也有許多開發出專門應用在挖礦上的作業系統，像是<a href="https://hiveos.farm/">Hiveos</a>、<a href="http://ethosdistro.com/">ETHOS</a>、SparkOS等作業系統，如果是專門挖礦、平常不會拿來使用的主機強烈建議安裝挖礦專用的作業系統，裏頭整合了驅動程式與挖礦控制等軟體，可以避免安裝驅動程式不合或是難以監控的問題。另外一點是隨著時間過去，DAG也會增加，AMD預設的顯示卡架構會印為DAG的增加造成大幅度的算力下降，選擇挖礦的作業系統能夠幫助你輕鬆解決這個問題而不需要另外設定。(一般Windows你安裝AMD的驅動後必須在驅動程式介面啟動運算模式以避免DAG增大帶來的負面影響)。</p>
<h2 id="選擇挖礦軟體"><a class="header" href="#選擇挖礦軟體">選擇挖礦軟體</a></h2>
<p>Ethereum主要的挖礦軟體有Claymore、Ethminer、Phoenix Miner等，其中臺灣最多人使用的就是Claymore，即使它會抽取你1%不等的算力(你可以指定不要讓Claymore抽1%，但Claymore會讓你算力減少2%)，但因為Claymore目前仍是主要公認效能最好的挖礦軟體(沒有之一)，因此還是最主流的挖礦軟體。你可以到<a href="https://bitcointalk.org/index.php?topic=1433925.0">bitcoin talk</a>下載最新的Claymore來使用。</p>
<h1 id="實際畫面"><a class="header" href="#實際畫面">實際畫面</a></h1>
<p>這裡我用家裡的電腦(Win10)搭配<a href="https://www.techpowerup.com/gpu-specs/radeon-rx-460.c2849">RX460</a>做示範，RX 460擁有112GB/s的頻寬，理論上能夠跑到約14Mh/s，但因為這裡我沒有超頻與優化，而只有看到11~12Mh/s的算力。也可以在畫面中看到DAG的載入，這就是我們昨天所說的Dagger-Hashimoto演算法裏頭的DAG！</p>
<p><img src="https://www.lkm543.site/it_iron_man/day19_4.JPG" alt="Miner Demo" /></p>
<h1 id="ref-16"><a class="header" href="#ref-16">Ref:</a></h1>
<ul>
<li><a href="https://www.asicminervalue.com/">Asicminervalue</a></li>
<li><a href="https://whattomine.com/">Whattomine</a></li>
<li><a href="https://bitcointalk.org/">bitcointalk</a></li>
<li><a href="https://zh.wikipedia.org/wiki/80_PLUS">維基百科-80PLUS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day19關於挖礦的兩三事4礦工間的戰爭"><a class="header" href="#day19關於挖礦的兩三事4礦工間的戰爭">Day19|關於挖礦的兩三事(4)：礦工間的戰爭</a></h1>
<h1 id="礦工間的戰爭"><a class="header" href="#礦工間的戰爭">礦工間的戰爭</a></h1>
<p>挖礦是有利潤的，但也因為區塊鏈的出塊與獎勵是固定的，挖礦對於所有參與的礦工是一場<a href="https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%92%8C%E5%8D%9A%E5%BC%88">零和遊戲</a>。為了增加自己的收益，方法大致可以分為提高獲利、壓低成本兩種方式，下面就幾種常見增加收益的方法做個簡單說明(<del>屏除違法的偷接電</del>)。</p>
<h2 id="壓低成本電費"><a class="header" href="#壓低成本電費">壓低成本(電費)</a></h2>
<p>電費的成本可以佔到總成本的30-60%不等(視硬體價格而定，目前因為幣價相對低點，因此硬體價格與折舊費用低廉，電費可以佔到總成本的60%左右)，並且因為挖礦所需的消費型3C硬體的價格往下談的空間不大，壓低成本的方式最常從電費下手。</p>
<h3 id="硬體調校"><a class="header" href="#硬體調校">硬體調校</a></h3>
<p>透過軟體與參數的調校可以稍微減少供耗，以Ethereum的Dagger-Hashimoto演算法為例，它需要記憶體的頻寬，但對於核心的計算能力反而不太要求，但核心往往是整張GPU中最耗電的部分，因此我們可以透過降低核心電壓頻率、拉高記憶體頻率的方式來達到提高算力的同時也減少供耗的效果。</p>
<h3 id="契約用電與時間電價"><a class="header" href="#契約用電與時間電價">契約用電與時間電價</a></h3>
<p>除了調校GPU的參數外，也可以向<a href="http://taipowerdsm.taipower.com.tw/">台電</a>申請時間電價(補充個小知識：台灣並沒有工業用電這種東西，只有契約用電！)或契約用電，透過在離峰時間才啟動挖礦程式可以讓每度電的電費壓在1.8元以下。而契約用電的成本則落在2.5-2.8元左右/度，比起家用最高級距動輒5、6元便宜許多。但申請前要注意台電的時間電價與契約電都有綁約一年的限制，而且契約電每月需要根據簽訂的容量繳交相對應的基本費(即便你一度電都沒用也得繳)，所以契約電對於專業礦場較為適合、家用時間電價對於散戶較為友善。</p>
<p><img src="http://taipowerdsm.taipower.com.tw/images/form_01.png" alt="時間電價" /><br />
圖片來源：<a href="http://taipowerdsm.taipower.com.tw/">台電</a></p>
<h2 id="增加挖礦期望值"><a class="header" href="#增加挖礦期望值">增加挖礦期望值</a></h2>
<p>如果對區塊鏈或礦池的運作夠熟悉，也可以透過區塊廣播或打包的眉眉角角來獲取更大的利益。這裡要另外說明，因為挖礦對所有礦工而言是一個零和遊戲，在增加自己獲利的同時也會損害到其他人的利益，因此某些為了使自己的利益最大化的方式往往被認為是不道德的。</p>
<h3 id="挖空塊"><a class="header" href="#挖空塊">挖空塊</a></h3>
<p>其中一個礦池的作弊方式便是<code>挖空塊</code>，還記得我們在之前寫的簡易區塊鏈中是這樣處理接收到的區塊的：</p>
<pre><code>def receive_broadcast_block(self, block_data):
    last_block = self.chain[-1]
    # Check the hash of received block
    if block_data.previous_hash != last_block.hash:
        print("[**] Received block error: Previous hash not matched!")
        return False
    elif block_data.difficulty != self.difficulty:
        print("[**] Received block error: Difficulty not matched!")
        return False
    elif block_data.hash != self.get_hash(block_data, block_data.nonce):
        print(block_data.hash)
        print("[**] Received block error: Hash calculation not matched!")
        return False
    else:
        if block_data.hash[0: self.difficulty] == '0' * self.difficulty:
            for transaction in block_data.transactions:
                self.pending_transaction.remove(transaction)
            self.receive_verified_block = True
            self.chain.append(block_data)
            return True
        else:
            print(f"[**] Received block error: Hash not matched by diff!")
            return False
</code></pre>
<p>大抵而言可以把步驟簡化成：</p>
<ol>
<li>確認該區塊的哈希數是否符合當下難度的規範</li>
<li>如果符合就把該區塊內的交易(<code>pending_transaction</code>)自等待中的交易內移除</li>
<li>結束目前的挖礦</li>
<li>把新的交易放置入新的區塊中</li>
<li>開始挖掘新區塊</li>
</ol>
<p>但在步驟進行過程中，礦池的算力是停擺的，但是礦機卻仍然在持續運行著。因此有些礦池會為了節省時間與能源，在尚未接收到整個區塊的廣播時就直接開始挖掘下一塊，但也因為如此礦池根本不知道這區塊內有哪些交易，也因此無法確認哪些等待中的交易(<code>pending_transaction</code>)是已經被打包進去/交易過的，所以在下一區塊的挖掘中礦池無法加入任何交易紀錄，所以即便礦池真的挖掘出新區塊，裏頭也沒有任何交易，俗稱空區塊，他們接收到廣播的區塊後的方式如下。</p>
<ol>
<li>確認該區塊的哈希數是否符合當下難度的規範</li>
<li>不置入任何交易就開始挖掘新區塊</li>
</ol>
<p>因為少了確認交易內容、打包新交易的過程，所以挖空塊能夠比正常挖礦者更快進入nonce值的計算階段，但此時的區塊卻沒有辦法驗證任何人的交易。所以有些人會覺得礦池為了自身利益不打包其他人的交易實在是母湯的行為。更多挖空塊的細節可以參考<a href="https://zhuanlan.zhihu.com/p/46372884">這裡</a>。</p>
<h3 id="跳跳池"><a class="header" href="#跳跳池">跳跳池</a></h3>
<p>在講跳跳池前就必須先談礦池的運作與分潤方式：可以把礦池想像成接受到難題後，就把該難題拆解成許多小難題分派給參與的礦工，每當礦工解決完一個小難題後便回傳給礦池，此時稱為一個<code>share</code>，主流幾種礦池在出塊後與礦工們的分潤方式：</p>
<h4 id="rbppsround-base-pay-per-share"><a class="header" href="#rbppsround-base-pay-per-share">RBPPS(Round Base Pay Per Share)</a></h4>
<p>RBPPS是當礦池挖掘到新區塊後，就立刻把新區塊的收益根據這段時間的大家的<code>share</code>數目來分派收益，因此礦工本身也承擔了風險，如果多出塊，礦工就多賺；沒出塊，礦工就會虧錢。</p>
<h4 id="ppspay-per-share"><a class="header" href="#ppspay-per-share">PPS(Pay Per Share)</a></h4>
<p>PPS的方式是不論礦池出塊與否，礦池都會根據礦工所解決的<code>share</code>數目給礦工應當的收益，因此出塊與否的風險是由礦池承擔的，如果礦池運氣好多出幾塊礦池就會大賺，但如果運氣不好就會大虧了。</p>
<h4 id="pplnspay-per-last-n-share"><a class="header" href="#pplnspay-per-last-n-share">PPLNS(Pay Per Last N Share)</a></h4>
<p>PPLNS是只根據礦池出塊後過去的N個<code>share</code>數目給礦工應當的收益，至於為什麼會這樣設計是為了避免跳跳池的礦工(以下說明))。</p>
<h4 id="跳跳池-1"><a class="header" href="#跳跳池-1">跳跳池</a></h4>
<p>了解跳跳池的原理前先來了解一個值：<code>幸運值</code>。根據礦池持有的算力佔全網算力的比例可以算出預期的出塊時間，比方說Ethereum大約每15秒會出一塊，如果礦池持有總算力的1%，則平均下來大概每25分鐘可以出一塊，計算方式如下：</p>
<blockquote>
<p>出塊時間15秒/持有算力1% = 預期出塊時間1500秒 = 25分鐘</p>
</blockquote>
<p>幸運值的意思是現在的挖掘時間是預期出塊時間的多少百分比，也就是說長時間平均下來，大約幸運值累積到100%就能夠出一塊，如果幸運值小於100%時就挖到區塊，代表礦池的運氣很好，礦工們的收益會高於預估；但如果幸運值大於100%才出塊，代表礦池的運氣不好，得花費比期望值高的算力才能夠出塊。</p>
<blockquote>
<p>幸運值 = 已挖掘區塊時間/預期出塊時間 * 100%</p>
</blockquote>
<p>在<a href="http://tweth.tw/">臺灣乙太幣礦池</a>中的幸運值就在預期出塊那裏(下圖)，也可以透過使用者介面發現臺灣乙太幣礦池是修改我們幾天前介紹的<a href="https://github.com/sammy007/open-ethereum-pool">Open source礦池程式碼</a>而來。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day20_1.JPG" alt="Lucky" /></p>
<p>而跳跳池的做法就是：當幸運值小於100%時進入RBPPS的礦池，等到幸運值大於100%的時候就轉出到其他礦池以獲取更大的收益。乍聽之下好像很不合理，畢竟挖礦的時間不是都一樣嗎？為什麼跳來跳去能夠取得較大的收益？</p>
<p>要理解這個原因可以從期望值的問題下手：<strong>每留在礦池中的固定一段時間能夠獲得多少收益？</strong></p>
<p>因為每段時間的出塊機率是固定的，當礦池的幸運值為X%時，如果挖出區塊，便需要跟前面X%所累積出來的<code>share</code>數目均分出塊收益，因此留在礦池繼續挖一段時間的收益期望值便是<code>PPS收益/X</code>。</p>
<p>由此可見，當X小於100%時，留在RBPPS的礦池的收益會大於PPS池，但當X大於100%時，留在RBPPS的礦池的收益就會小於PPS池，所以當幸運值小於100%時進入RBPPS礦池、當幸運值大於100%時退出RBPPS礦池便能夠獲取更高的收益。為了避免這種情形才會衍伸出第三種PPLNS的礦池分潤：只根據前面N個share進行分潤，若礦工中途退出，則之前的收益全數歸零。</p>
<p>這裡我們可以做一個小實驗，假設有兩人持有同樣算力，其中一人老實地挖完全程，另一人只挖到幸運值100%後就轉去PPS池(這裡我們都以1%為單位，每經過1%幸運值就會有1%機率挖到)：</p>
<ol>
<li>
<p>對於始終留在同一個RBPPS、而且沒有礦工提前跳走的的礦池而言，礦工的收益跟預期差不多。</p>
<pre><code>pool_reward = 0
try_times = 10000
mine_time = 0

# RBPPS Miner
for i in range(try_times):
    luck = 1
    while(True):
        if random.randint(0,100) == 0:
            # Mine Block!
            pool_reward += 100
            mine_time += luck
            break
        luck += 1
print(f"Expect RBPPS miner: {pool_reward/mine_time}")
</code></pre>
</li>
</ol>
<blockquote>
<p>Expect RBPPS miner: 0.9913583294422519</p>
</blockquote>
<ol start="2">
<li>
<p>但如果有礦工每到幸運值100%便跳去另外一個PPS池，即便在原本RBPPS池的收益會減少成<code>200*(100/(100+luck))</code>但同時也會增加PPS的收益<code>luck - 100</code>，另外因為礦工在幸運值100%後便離開，在幸運值100%之後的出塊機率也會變成1/2，因此要多篩一次<code>random.randint(0,1) == 0</code>：</p>
<pre><code>miner_reward = 0
pool_reward = 0
mine_time = 0
# RBPPS + PPS Miner and Pool
for i in range(try_times):
    luck = 1
    while(True):
        if random.randint(0,100) == 0:
            # Mine Block!
            if luck &lt; 100:
                miner_reward += 100
                pool_reward += 100
                mine_time += luck
                break
            else:
                if random.randint(0,1) == 0:
                    miner_reward += 200*(100/(100+luck))
                    pool_reward += 200*(luck/(100+luck))
                    miner_reward += luck - 100
                    mine_time += luck
                    break
        luck += 1
print(f"Expect RBPPS + PPS miner: {miner_reward/mine_time}")
print(f"Expect RBPPS + PPS pool: {pool_reward/mine_time}")
</code></pre>
</li>
</ol>
<blockquote>
<p>Expect RBPPS + PPS miner: 1.1591529571485477<br />
Expect RBPPS + PPS pool: 0.8354135084376128</p>
</blockquote>
<p>可以發現採用跳跳池的礦工可以高出近20%的收益，而留在原池的礦工則會減少近20%的收益，兩者一來一往就差了將近40%！</p>
<h2 id="扣塊攻擊"><a class="header" href="#扣塊攻擊">扣塊攻擊</a></h2>
<p>另一種礦池間的攻擊手法就是利用PPS的漏洞：動用手下的算力去幫別人礦池挖礦，但只發送沒挖掘成功的share，一但確認自己挖到正確的share之後卻不廣播給礦池，所以送出的share都是無效的！但因為PPS分潤制的關係，導致礦池仍然要配發無效share的收益給該名礦工，長期下來礦池配發的收益會與挖掘到的收益不合比例，而導致PPS制礦池的倒閉。</p>
<p>既然有這麼明顯的漏洞，為什麼還是有礦池使用PPS制呢？因為當礦池規模小時，為了吸引礦工們前來礦池只能使用PPS制(出塊機率太低、預期出塊時間太長，礦工沒有耐心等待)來固定配發收益給前來的礦工們。</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，至於今天模擬跳跳池收益的程式碼則放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day19.py">這裡</a>。</p>
<h1 id="ref-17"><a class="header" href="#ref-17">Ref:</a></h1>
<ul>
<li><a href="https://www.chainnews.com/articles/806780761278.htm">打压对手，让其他矿池倒闭，神鱼所说的扣块攻击究竟是什么？</a></li>
<li><a href="https://justhodl.blogspot.com/2018/04/pooled-mining.html">淺談礦池挖礦機制 (Pooled Mining)</a></li>
<li><a href="https://medium.com/taipei-ethereum-meetup/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3%E8%88%87%E4%BB%96%E5%80%91%E7%9A%84%E7%94%A2%E5%9C%B0-21a52c51427f">加密貨幣與他們的產地</a></li>
<li><a href="https://www.chainnews.com/articles/210557815167.htm">POW 矿池挖空块原理和解决方案</a></li>
<li><a href="https://www.chainnews.com/articles/445562632637.htm">神鱼发怒，揭露矿圈“扣块攻击”，矿池江湖暗流涌动</a></li>
<li><a href="https://m.mifengcha.com/news/5bbd7a3a22285b8f5a903bb5">科普入门 | 空块是什么？为什么矿工要挖空块？</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day20p2p網路1p2p網路基礎知識"><a class="header" href="#day20p2p網路1p2p網路基礎知識">Day20|P2P網路(1)：P2P網路基礎知識</a></h1>
<h1 id="傳統的網路架構"><a class="header" href="#傳統的網路架構">傳統的網路架構</a></h1>
<p><img src="images/day20_35224.png" alt="Client–server model" /></p>
<p>圖片來源：<a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">Wikipedia</a></p>
<p>傳統的網路架構是每一張圖片、影片、網站、APP都會有存放的伺服器(<code>server</code>)，每個伺服器會有自己像門牌一般的ip位址，當我們(<code>client</code>)瀏覽網頁時，其實就是透過ip位址向伺服器發出請求(request)，再由伺服器回傳我們瀏覽網頁上的資源(圖片、影片、html等)給我們。可以說伺服器本身掌控了話語權，也決定了我們能看到甚麼。</p>
<p>因此傳統的架構又稱為<code>Client–Server model</code>。</p>
<p>以facebook為例，你在facebook的所有帳戶、照片、好友資料通通都存在facebook的伺服器中，facebook也有權力決定要給你看到/看不到甚麼，所以與其說是你的帳戶，不如說是facebook擁有你自願上傳的資訊，當你有需求時再順道回傳給你一份罷了。</p>
<p><img src="https://www.dcsorg.com/images/centralized-management.jpg" alt="Centralized" /></p>
<p>圖片來源：<a href="https://www.dcsorg.com/centralized-management.php/">Digital Currency Systems</a></p>
<p>所以傳統的中心化架構就是所有使用者的請求都會被送到同一個伺服器處理。另一個中心化的例子就是銀行的金流系統，當我們要匯款時便是向銀行的伺服器發出請求，請伺服器驗證我們的身分並且針對我們的請求加以處理，同時我們也信任伺服器的處理結果，整個流程都由銀行端完成。</p>
<p>這種架構的優點就是處理迅速，我們只需要等待單一伺服器的回應就可以知道結果。但其中卻有兩大缺陷：</p>
<h2 id="scalability"><a class="header" href="#scalability">Scalability</a></h2>
<p>Scalability代表的是可擴充性，也就是當使用者的數目成長時，系統接收並處理請求的伺服器數目卻是固定的，固定的伺服器規格代表能處理的使用者數目或是單位時間內的請求數是會有上限的，如果想要拉高上限，代表的是營運成本也會跟著上升(但其實近年因為硬體的進步與分散式系統的發達已經很大解決Scalability的問題了)。</p>
<h2 id="reliability"><a class="header" href="#reliability">Reliability</a></h2>
<p>Reliability代表的是系統的可靠度，也就是系統的妥善率有多少。傳統的<code>Client–Server model</code>仰賴單一伺服器與節點的運行，所以一旦伺服器出錯或是維修，整個服務就會終止，也因如此我們偶爾還是會聽到facebbok斷線或是銀行服務會有固定的停止服務時間等等。</p>
<h1 id="peer-to-peerp2p網路"><a class="header" href="#peer-to-peerp2p網路">Peer to Peer(P2P)網路</a></h1>
<p>傳統的網站架構是把所有的資源都放置在同一台伺服器上，有需要的用戶再向伺服器檢索。Peer to Peer(P2P)網路則是網路上的所有人都負責儲存了全部或部分的所有資料，除了向其他IP位址發起請求外，本身也需要負責處理收到的請求，<strong>自身既是Client也是Server</strong> 。</p>
<p>但其實P2P網路並非是非常新的概念，在常聽到的<a href="https://zh.wikipedia.org/zh-tw/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">TCP/IP通訊協定</a>中其實就是一種終端到終端(end to end)的概念，通訊的兩端是彼此平等不分client與server的！只是因為實務上我們上網幾乎都是在檢索其他網站的資料，為了效率與實務上應用的考量網站經營者才會把所有資源集中存放與處理。</p>
<p><img src="https://www.skalex.io/wp-content/uploads/2017/06/p2p-web-model-transparent.png" alt="P2P" /></p>
<p>圖片來源：<a href="https://www.skalex.io/blockchain-p2p-web/">https://www.skalex.io</a></p>
<p>P2P網路在Scalability與Reliability都具有很大的優勢，因為每個獨立的終端都可以視作Server，當終端數目增加，Server數目也隨之增加，所有可運用的硬體資源與網路頻寬也隨之增加，在Scalability會具有很大的優勢。而Reliability的部分因為每個終端都可以獨立運作，所以不存在傳統中心化架構中一旦單一伺服器停擺就會造成整個服務中斷的問題。</p>
<p>除了Scalability與Reliability外，P2P網路也因為沒有中心化的伺服器，而讓資料沒有被中心化機構掌控或修改的可能，也確保了資訊的安全。</p>
<h2 id="p2p網路的難題"><a class="header" href="#p2p網路的難題">P2P網路的難題</a></h2>
<p>雖然P2P網路可以有效解決傳統中心化網路在Scalability與Reliability的問題，但在技術上因為需要參照與協調許多終端所以技術的複雜度會比傳統Client–Server model複雜。以下簡述幾種P2P網路實作上的難題。</p>
<h3 id="工作的分配"><a class="header" href="#工作的分配">工作的分配</a></h3>
<p>雖然P2P網路的硬體資源與頻寬會隨著終端數目的增加而增加，但如何配置與分享彼此間閒置的資源是一大難題，畢竟即便資源增加，若沒有好好地被分配與利用也是徒然。以下簡述幾種工作分配的方式：</p>
<h4 id="opportunistic-load-balancingolb"><a class="header" href="#opportunistic-load-balancingolb">Opportunistic Load Balancing(OLB)</a></h4>
<p>Opportunistic Load Balancing是將目前的工作隨意分配給一台閒置的電腦，目標是讓所有的電腦都處於工作的狀態，但因為沒有考量每個工作的工作量與每台電腦獨立且不同的運算能力，所以不適用於由異質終端所構成的P2P網路。</p>
<h4 id="minimum-execution-timemet"><a class="header" href="#minimum-execution-timemet">Minimum Execution Time(MET)</a></h4>
<p>Minimum Execution Time是不考慮電腦目前的工作狀態，直接把這項工作分配給執行時間最短的電腦，但缺點是會造成負載的不平衡，運算能力最強的電腦會被分派到最多工作，運算能力最弱的就會一直閒置，所以同樣不適用於由異質終端所構成的P2P網路。</p>
<h4 id="minimum-completion-timemet"><a class="header" href="#minimum-completion-timemet">Minimum Completion Time(MET)</a></h4>
<p>Minimum Completion Time是根據電腦的最小完成時間(目前的工作要多久才會結束)來分派工作，越快結束的電腦就會被優先指派然後計算，所以並不保證執行時間(Execution Time)會最短。</p>
<h4 id="min-min"><a class="header" href="#min-min">Min-Min</a></h4>
<p>Min-Min是根據工作在每一台電腦預估可以完成的時間，所以也會將電腦目前的工作狀態列入考量。完成時間的意思便是等待時間加上執行時間(上面的Execution Time)，所以雖然能確保工作能在最短時間內被完成，但預估完成時間也是難事。</p>
<h3 id="節點的搜尋"><a class="header" href="#節點的搜尋">節點的搜尋</a></h3>
<p>既然P2P網路是由許多獨立的Peer所構成，那要怎麼知道參與網路的節點確切的ip位址呢？你只能透過一些中心化的網站或是上網搜尋其他人提供的節點位置，比方說<a href="https://bitnodes.earn.com/">這個網站</a>就記錄了Bitcoin網路線上的所有節點(下圖)，找到節點們的資訊後你才能參與整個P2P網路的運作。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day21_1.JPG" alt="Peer Location" /></p>
<p>圖片擷取自：<a href="https://bitnodes.earn.com/">bitnodes</a></p>
<h3 id="取得peer間的共識"><a class="header" href="#取得peer間的共識">取得Peer間的共識</a></h3>
<p>另一個P2P網路的難題是要取得終端/節點間的共識，P2P網路間必須共享同一份資料與彼此間的資訊才能夠協作，且因為TCP/IP的網路是兩兩連接而成的，由簡單的排列組合可以得知當節點有N個時，所有節點可以組成的連線個數便是CN取2，就是N*(N-1)，大約取決於N^2，這在節點數一多的狀況下要取得Peer間的共識會非常困難，更何況有時候會有惡意的節點加入並且散步造假過的資訊，我們明日會在根據拜占庭將軍問題詳談如何解決這個問題。</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=C%5EN_2%3DN!%2F(k*(N-2)!)%3DN*(N-1)" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=C%5EN_2%3DN!%2F(k*(N-2)!)%3DN*(N-1)" /></p>
<h3 id="無法徹底去中心化"><a class="header" href="#無法徹底去中心化">無法徹底去中心化</a></h3>
<p>最後一個問題是P2P網路雖然可以稍微擺脫被單一中心化機構掌控資源的風險，但實際上P2P網路沒有辦法達到完全的去中心化，原因是網路提供商ISP或是<a href="https://zh.wikipedia.org/zh-tw/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">DNS</a>還是掌控在中心化機構手中，像是上面節點的搜尋也需要仰賴別人提供的資訊，因此充其也只是最後資訊的儲存與處理是去中心化，底層的通訊還是得仰賴特殊的機構完成。</p>
<h3 id="資料的重複儲存與不穩定性"><a class="header" href="#資料的重複儲存與不穩定性">資料的重複儲存與不穩定性</a></h3>
<p>因為P2P網路的節點是可以自由加入與退出的，也就是每個節點的穩定性並無法確認，也無法得知每個節點可存續的時間，為了求取資料的安全便需要在複數個位置上儲存同樣的資料，相較於中心化網路會多耗費許多空間，即便如此在儲存使用者分享的檔案時也無法確保該檔案能存在多久。</p>
<h2 id="p2p網路的分類"><a class="header" href="#p2p網路的分類">P2P網路的分類</a></h2>
<p>根據P2P網路處理資訊與分配工作的方式大致又可以分成三種：</p>
<p><img src="https://www.researchgate.net/profile/Taoufik_Yeferny/publication/332539196/figure/fig2/AS:749686013034497@1555750482262/P2P-architectures-at-a-glance-a-Centralized-architecture-b-Pure-P2P-architecture.png" alt="P2P Category" /></p>
<p>圖片來源：<a href="https://www.researchgate.net/figure/P2P-architectures-at-a-glance-a-Centralized-architecture-b-Pure-P2P-architecture_fig2_332539196">P2P architectures at a glance.</a></p>
<h3 id="中央式p2p"><a class="header" href="#中央式p2p">中央式P2P</a></h3>
<p>也就是上圖的(a)，代表整個P2P有一個中心伺服器專責處理工作的分派與分流，也會記錄節點們的清單與位置，但中心節點並不實際處理資訊或是資料的儲存，只負責節點間的溝通與工作的調度。</p>
<h3 id="純p2p"><a class="header" href="#純p2p">純P2P</a></h3>
<p>純P2P代表整個P2P網路中的節點都是平等的，彼此並沒有工作或是權力上的分別，也就是上圖的(b)。</p>
<h3 id="混合-p2p"><a class="header" href="#混合-p2p">混合 p2p</a></h3>
<p>混合式P2P很像是中央式P2P，但其跟中央式P2P網路不同的地方是它擁有複數個中心伺服器負責資訊的轉發與協調，<a href="https://eos.io/">EOS</a>本身就擁有了21個超級節點。</p>
<h1 id="p2p與區塊鏈"><a class="header" href="#p2p與區塊鏈">P2P與區塊鏈</a></h1>
<p>整個Bitcoin全節點可以看作是一種純P2P網路，節點間並沒有先來後到之分，但為了保持資料的一致性(所有節點手上的帳本必須同步)，所以在傳遞或廣播上必須考量到效率與攻擊者假造節點的狀況，因此我們明天就要來介紹究竟在P2P網路中要如何確保節點間的同步與讓正確的共識被形成呢？</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-18"><a class="header" href="#ref-18">Ref:</a></h1>
<ul>
<li><a href="https://sls.weco.net/node/12916">Peer-to-Peer (P2P) System</a></li>
<li><a href="http://bm.nsysu.edu.tw/tutorial/htt/dkl/SearchEngine-nsysu041230.pdf">P2P-顛覆網際網路傳統觀念</a></li>
<li><a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">Wikipedia-Client–server model</a></li>
<li><a href="https://dannylin3000.pixnet.net/blog/post/31271397-p2p%E7%9A%84%E7%B6%B2%E8%B7%AF%E5%85%B1%E4%BA%AB%E4%B8%96%E7%95%8C">P2P的網路共享世界</a></li>
<li><a href="https://www.itread01.com/content/1546608974.html">P2P對等網路技術原理整合</a></li>
<li><a href="https://blog.csdn.net/qq_33850438/article/details/79700133">P2P原理以及如何实现（整理）</a></li>
<li><a href="http://ir.lib.cyut.edu.tw:8080/bitstream/310901800/6479/1/Two+phases+scheduling+in+P2P.pdf">以兩階段排程演算法提昇動態階層式點對點網路拓樸之負載平衡</a></li>
<li><a href="https://www.itread01.com/content/1545529340.html">詳解區塊鏈P2P網路</a></li>
<li><a href="https://slideplayer.com/slide/4806764/">Towards Efficient Simulation of Large Scale P2P Networks</a></li>
<li><a href="https://www.shs.edu.tw/works/essay/2008/10/2008103101062756.pdf">點對點網際網路技術(P2P)和軟體之概論</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day21p2p網路2共識拜占庭將軍問題"><a class="header" href="#day21p2p網路2共識拜占庭將軍問題">Day21|P2P網路(2)：共識─拜占庭將軍問題</a></h1>
<h1 id="拜占庭將軍問題"><a class="header" href="#拜占庭將軍問題">拜占庭將軍問題</a></h1>
<p>拜占庭將軍問題在<a href="https://zh.wikipedia.org/zh-tw/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">維基百科</a>中的說明如下：</p>
<blockquote>
<p>一組拜占庭將軍分別各率領一支軍隊共同圍困一座城市。為了簡化問題，將各支軍隊的行動策略限定為進攻或撤離兩種。因為部分軍隊進攻部分軍隊撤離可能會造成災難性後果，因此各位將軍必須通過投票來達成一致策略，即所有軍隊一起進攻或所有軍隊一起撤離。因為各位將軍分處城市不同方向，他們只能通過信使互相聯絡。在投票過程中每位將軍都將自己投票給進攻還是撤退的資訊通過信使分別通知其他所有將軍，這樣一來每位將軍根據自己的投票和其他所有將軍送來的資訊就可以知道共同的投票結果而決定行動策略。</p>
</blockquote>
<p><img src="images/day21_58031.jpg" alt="Byzantine Generals" /></p>
<p>圖片來源：<a href="https://steemit.com/blockchain/@dantheman/the-problem-with-byzantine-generals">steemit</a></p>
<p>拜占庭將軍問題的背景可以簡化成三件事情：</p>
<ol>
<li>將軍中可能出現叛徒，故意投不適當的策略，也不會依照投票的結果行動</li>
<li>傳遞過程中叛徒可能會以其他將軍的身分傳遞假資料給其他忠誠的將軍</li>
<li>傳遞過程中的信使可能會被攔截</li>
</ol>
<p>因此拜占庭將軍問題的核心就是如何在有叛徒或是資訊有可能遺失的情形下，找出方法讓忠誠的將軍們仍然可以<strong>不受叛徒影響取得共識並且發動集體一致的行動</strong> 。</p>
<h1 id="拜占庭將軍問題與區塊鏈"><a class="header" href="#拜占庭將軍問題與區塊鏈">拜占庭將軍問題與區塊鏈</a></h1>
<p>那麼拜占庭將軍問題究竟跟區塊鏈有甚麼關係呢？</p>
<h2 id="女巫攻擊sybil-attack"><a class="header" href="#女巫攻擊sybil-attack">女巫攻擊(Sybil Attack)</a></h2>
<p>還記得我們在<a href="https://ithelp.ithome.com.tw/articles/10216373">Day07|打造一個簡易的區塊鏈(6)：節點間的同步與廣播</a>中有寫到節點的加入是完全自由、不需要任何人允許，但這樣自由開放、沒有審核的環境就可能會有攻擊者冒充節點並且廣播對自己有利的資訊。</p>
<p>就像1973年的小說《Sybil》裏頭化名Sybil Dorsett的女主角因為認同障礙有16種人格一樣，單一攻擊者可以假冒惡意節點，並且分裂出多重身份藉此向其他正常節點提供大量不正確的資訊以癱瘓網路或是取得利益，這類在P2P網路中偽造多重身分藉此發動攻擊的方式又稱為<code>女巫攻擊(Sybil Attack)</code>。</p>
<p>為了對抗女巫攻擊，區塊鏈上的節點們必須在節點裏藏有攻擊者的狀況下加以應對並且求取正常節點間的共識；所以，區塊鏈或P2P網路中求取共識的本質便跟拜占庭將軍問題一樣。</p>
<p><img src="images/day21_08155.jpg" alt="Sybil Attack" /></p>
<p>圖片來源：<a href="https://www.yourgenome.org/facts/what-is-clone-by-clone-sequencing">yourgenome</a></p>
<h2 id="誰有權利投票"><a class="header" href="#誰有權利投票">誰有權利投票?</a></h2>
<p>為了對抗女巫攻擊，最基礎的方式就是讓<strong>P2P網路中的廣播與投票是有成本的</strong> ，也就是你必須持有特定東西去證明你有廣播與投票的權利，至於用甚麼東西來證明自己主要又可以區分成兩種方式：</p>
<h3 id="工作量證明proof-of-workpow-1"><a class="header" href="#工作量證明proof-of-workpow-1">工作量證明(Proof of Work，POW)</a></h3>
<p><code>工作量證明</code>指的是如果你想要廣播或是投票，你手中必須持有一定的運算力，回憶一下我們之前挖掘區塊的過程：</p>
<pre><code>while new_block.hash[0: self.difficulty] != '0' * self.difficulty:
    new_block.nonce += 1
    new_block.hash = self.get_hash(new_block, new_block.nonce)
</code></pre>
<p>如果節點需要廣播資訊，它必須透過不斷搜尋nonce值來完成要求，也就是透過自身的工作量來證明自己廣播的權力，即便生成一個假冒節點的成本低廉，攻擊者可以藉此偽造無數個節點，但產生出的假節點會因為沒有運算力支持無法進行廣播，如果攻擊者想要發動女巫攻擊就必須耗費大量硬體資源取得運算力，大大提高了女巫攻擊的難度。</p>
<p>雖然工作量證明能夠有效地抵制女巫攻擊，但在區塊鏈上也會產生未來發展路線被礦池/礦工把持的問題，也就是說你手上的幣未來會如何是完全被礦工/礦池決定的，一般持有幣的人並沒有辦法參與或是決定，這就利益的考量而言是衝突的，因為通常持有幣的人才會擁有動機去維持區塊鏈的可靠與可信度，如果礦工手上沒有幣，或是未來挖礦的利潤不斷下滑，就有可能發生礦工反過來攻擊區塊鏈一次獲取超額利潤殺雞取卵的事件。</p>
<h3 id="權益證明proof-of-stakepos"><a class="header" href="#權益證明proof-of-stakepos">權益證明(Proof of Stake，POS)</a></h3>
<p>因此另一種<code>權益證明</code>便應運而生，權益證明的目的是把廣播與投票的權力改成由持幣者來行使，也就是你手上持有的幣數越多，你會越有權力去廣播與投票，藉此透過自身的利益來維護區塊鏈的穩定。關於POS的詳情我們之後會另外開一章單獨說明。</p>
<h1 id="拜占庭容錯bft演算法"><a class="header" href="#拜占庭容錯bft演算法">拜占庭容錯(BFT)演算法</a></h1>
<p>Leslie Lamport在1982年發表 <em>The Byzantine Generals Problem</em>(<a href="https://people.eecs.berkeley.edu/~luca/cs174/byzantine.pdf">論文連結</a>)，提出了一個虛構模型來模擬異質系統中共識的形成，並且提出了拜占庭容錯演算法試圖在節點中求取共識。</p>
<p>因為Bitcoin中的節點彼此間是完全相同的，舉個例子：目前存在有三個獨立的節點，其中一個是由攻擊者(叛徒)假冒成的，但接收指令的正常節點(忠誠)並沒有能力區分此時的真實命令為何。</p>
<p><img src="http://www.lkm543.site/it_iron_man/day22_1.JPG" alt="BFT Demo 1" /></p>
<p>但若存在有四個獨立的節點，其中只有一個是由攻擊者(叛徒)假冒成的，此時接收指令的正常節點(忠誠)有能力區分此時的真實命令為何、並且找出哪個節點是由攻擊者假冒而成的。</p>
<p><img src="http://www.lkm543.site/it_iron_man/day22_2.JPG" alt="BFT Demo 2" /></p>
<p>傳統拜占庭容錯演算法是透過節點兩兩間的聯繫來確認彼此的共識，問題就是<strong>需要的運算量非常龐大而難以被實用</strong> ：以昨天提到的CN取2為例，假設目前有N個節點，每個節點都需要取得其他N-1個節點的訊息才能夠確認下一步的動作，也就是整個網路需要<code>N*(N-1)</code>的溝通數目才能進行下一步動作。也就是演算法中的O(n*n)：當節點數目數目變成N倍，整體運算量就會變成N^2倍。</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=C%5EN_2%3DN!%2F(k*(N-2)!)%3DN*(N-1)" alt="https://chart.googleapis.com/chart?cht=tx&amp;chl=C%5EN_2%3DN!%2F(k*(N-2)!)%3DN*(N-1)" /></p>
<p>在此補充一點，在Bitcoin的工作量證明機制下，上述的節點都必須有相同的運算能力，也就是拜占庭容錯演算法提供了工作量證明外的另一層安全保障。</p>
<h2 id="證明拜占庭容錯機制"><a class="header" href="#證明拜占庭容錯機制">證明拜占庭容錯機制</a></h2>
<p>Leslie Lamport等人在1980年發表<a href="https://lamport.azurewebsites.net/pubs/reaching.pdf">《Reaching agreement in the presence of faults》</a>中證明，當網路中由攻擊者假冒的節點不超過1/3時，拜占庭容錯演可以有效揪出由攻擊者假冒的節點。但如果由攻擊者假冒的節點超過總數的1/3，就無法保證正常節點間能夠達到共識。換算成數學式就是：</p>
<blockquote>
<p>N≧3F+1</p>
</blockquote>
<p>其中N代表節點總數，F則是攻擊者假冒的節點數目，如果N大於或等於3F+1，則拜占庭容錯演算法便可以揪出整個網路的異常。我們可以做個簡單證明，此時根據提案方式可以分成兩種情形：</p>
<ul>
<li>發起行動者(提案節點)是由正常節點</li>
<li>發起行動者(提案節點)是由攻擊者假冒</li>
</ul>
<p>當提案節點是正常節點時，當它把提案廣播出去時，整個網路會有至少N-F份正常訊息與至多F份錯誤訊息在網路中流傳，此時正確訊息必須多餘假冒的訊息N-F&gt;F，也就是N必須大於2F</p>
<blockquote>
<p>N&gt;2F</p>
</blockquote>
<p>但當提案節點是由攻擊者假冒時，攻擊者會盡量拆散正常節點所接受到的資訊，也就是其中一半的正常節點(N-F)/2會接收到提案、另外一半的節點(N-F)/2卻會收到相反的提案，至於剩餘的攻擊者F-1的訊息是不確定的(攻擊者會干擾共識的形成)。為了達成共識，正常節點此時必須詢問其他節點所收到的資訊為何來確認共識與該訊息是否是被攻擊者偽造出來的，要使共識形成必須讓正常節點收到資訊多餘被偽造出來的，也就是N-F個正常節點減去F個假資訊後仍然必須大於F個假節點，(N-F)-F&gt;F，所以可以導出總節點個數N必須大於3倍的假節點F。</p>
<blockquote>
<p>(N-F)-F&gt;F</p>
</blockquote>
<p>確切的證明可以參考<a href="https://lamport.azurewebsites.net/pubs/reaching.pdf">論文原文</a>。</p>
<h1 id="實用拜占庭容錯pbft"><a class="header" href="#實用拜占庭容錯pbft">實用拜占庭容錯(PBFT)</a></h1>
<p>Miguel Castro和Barbara Liskov在1999年發表了<a href="http://www.pmg.csail.mit.edu/papers/bft-tocs.pdf">《Practical Byzantine Fault Tolerance and Proactive Recovery》</a>，其中提出的<code>實用拜占庭容錯(PBFT)演算法</code>把拜占庭容錯演算法的運算複雜度從指數降低到了多項式級，複雜度的大幅度降低讓拜占庭容錯演算法有實際應用的機會。</p>
<h2 id="實用拜占庭容錯pbft的步驟"><a class="header" href="#實用拜占庭容錯pbft的步驟">實用拜占庭容錯(PBFT)的步驟</a></h2>
<p>實用拜占庭容錯(PBFT)演算法改善了傳統必須彼此迭代詢問彼此收到資訊的情形，透過三階段投票與回應的設計，大幅度減少需要使用的運算量。</p>
<p><img src="images/day21_49233.jpg" alt="PBFT" /></p>
<p>圖片來源：<a href="https://itsblockchain.com/practical-byzantine-fault-tolerance-algorithm-pbft-consensus/">itsblockchain</a></p>
<p>以下以區塊鏈為例簡述三個PBFT的步驟：</p>
<h3 id="pre-prepare"><a class="header" href="#pre-prepare">Pre-prepare</a></h3>
<p>由客戶端(<code>Client</code>)向其中一個節點發起交易的請求，接收到請求的節點會傳遞交易請求給其餘節點，並且經過自己私鑰的數位簽章(我們之前提到的非對稱加密)來證明該訊息是由自己發出的，發送後進入就位(<code>Pre-prepare</code>)狀態，此時的資訊是由單一節點傳達給全部節點的。</p>
<h3 id="prepare"><a class="header" href="#prepare">Prepare</a></h3>
<p>當其餘節點收到發出的就位(<code>Pre-prepare</code>)訊息後必須馬上決定是否同意這個請求，如果同意就同樣利用自身的私鑰簽章後發出自己的預備(<code>Prepare</code>)給其他將軍，不同意就不做任何事情。如果自其他節點那收到足夠多的預備(<code>Prepare</code>)就代表，此後進入已預備(<code>Prepared</code>)的階段。</p>
<h3 id="commit"><a class="header" href="#commit">Commit</a></h3>
<p>如果已預備(<code>Prepared</code>)的節點準備執行該請求，就發送自身私鑰簽數位簽章執行(<code>Commit</code>)訊息給所有節點並進入執行階段，若各節點收到執行(<code>Commit</code>)訊息就執行該請求的內容，並且達成共識。</p>
<h2 id="pbft的小總結"><a class="header" href="#pbft的小總結">PBFT的小總結</a></h2>
<p>上述的<code>Pre-prepare</code>階段可以看做單一節點對所有節點的廣播與提案，<code>Prepare</code>階段可以看做是每個節點是否同意這個請求，而每個階段所收到的回應個數至少需要超過前面所提到的總節點數目的2/3。那為什麼是三階段而不是兩階段(Pre-prepare跟Prepared)後行動呢？</p>
<p>這必須考慮到<code>視域變換(View-change)</code>，也就是避免發起者是攻擊者造假的，必須不停更換每一輪行動的最初發起者，因此Commit階段的目的便是要避免因為網路傳遞的延遲而使得部分節點進入視域變換的過程而導致錯誤的行動。詳細資訊可以參考<a href="https://medium.com/taipei-ethereum-meetup/intro-to-pbft-31187f255e68">Taipei Ethereum Meetup</a>的專欄。</p>
<h1 id="共識的形成與岔開"><a class="header" href="#共識的形成與岔開">共識的形成與岔開</a></h1>
<p>今天提到的都是節點間要如何產生行動上一致的共識，通常是在往常的交易或挖掘新區塊而需要達到彼此的一致性，但有時候會因為網路延遲的關係產生短暫的分裂，又或是社群意見的分裂使得此時並不需要繼續再按照節點間的共識採取行動，如何應對這些不同種類的分岔就是我們明後天要討論的議題了！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-19"><a class="header" href="#ref-19">Ref:</a></h1>
<ul>
<li><a href="https://medium.com/loom-network-chinese/%E4%BA%86%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%9F%BA%E6%9C%AC-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99-byzantine-fault-tolerance-8a1912c311ba">了解区块链的基本（第一部分）：拜占庭容错(Byzantine Fault Tolerance)</a></li>
<li><a href="https://zh.wikipedia.org/zh-tw/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">維基百科-拜占庭將軍問題</a></li>
<li><a href="https://www.binance.vision/zt/blockchain/byzantine-fault-tolerance-explained">拜占庭容錯的解釋</a></li>
<li><a href="https://medium.com/mibinews/%E7%BE%85%E6%96%AF%E7%A6%8F%E5%B0%88%E6%AC%84-%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%87%E8%BB%8D%E6%80%8E%E9%BA%BC%E6%89%93%E7%9A%84%E5%8B%9D%E4%BB%97-a51f6c39a760">【羅斯福專欄】拜占庭將軍怎麼打的勝仗？以鋼鐵人為例</a></li>
<li><a href="https://kknews.cc/zh-tw/history/ng3vj55.html">聽過拜占庭將軍問題，有聽過拜占庭容錯算法嗎？</a></li>
<li><a href="https://steemit.com/blockchain/@dantheman/the-problem-with-byzantine-generals">The Problem with Byzantine Generals</a></li>
<li><a href="https://medium.com/taipei-ethereum-meetup/intro-to-pbft-31187f255e68">若想搞懂區塊鏈就不能忽視的經典：PBFT</a></li>
<li><a href="https://poweichen.gitbook.io/blockchain-guide-zh/">區塊鏈技術指南</a></li>
<li><a href="https://kknews.cc/zh-tw/news/5bgk993.html">什麼是Sybil Attack女巫攻擊？</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day22p2p網路3暫時性分岔與叔塊獎勵"><a class="header" href="#day22p2p網路3暫時性分岔與叔塊獎勵">Day22|P2P網路(3)：暫時性分岔與叔塊獎勵</a></h1>
<h1 id="共識未能形成的小插曲分岔"><a class="header" href="#共識未能形成的小插曲分岔">共識未能形成的小插曲：分岔</a></h1>
<p>分岔指的是在區塊鏈進行過程中因為某些特定原因沒能達成一致性的狀態，根據分岔的原因與相容性又可以分成暫時性分岔、軟分岔、硬分岔三種。首先我們先來談<code>暫時性分岔</code>：</p>
<h1 id="暫時性分岔temporary-fork"><a class="header" href="#暫時性分岔temporary-fork">暫時性分岔(Temporary Fork)</a></h1>
<p>在P2P網路中節點間必須達成共識，並且每個節點所儲存的資料必須一致，而我們在昨天的<code>拜占庭將軍問題</code>中已經稍微講述了共識間的求取方式，但實際上網路資訊的廣播並不是即時的，其中的步驟可以簡化成：</p>
<ol>
<li>挖掘到新區塊</li>
<li>廣播新區塊</li>
<li>其他節點收到廣播的新區塊</li>
<li>其他節點開始驗證新區塊</li>
<li>其餘節點接受區塊後放棄目前挖掘的區塊，開始挖掘下一塊</li>
</ol>
<p><img src="http://www.lkm543.site/it_iron_man/day23_1.jpg" alt="Temporary Fork" /></p>
<p>因為網路與驗證哈希的運算都需要時間，因此在挖掘到新區塊到其餘節點驗證並接受該區塊會有一段時間上的落差，如果在這時間落差中有節點恰恰挖掘到另一個區塊(回憶一下挖礦所找尋的nonce並非是單一解)，整個區塊鏈網路就會進入<code>暫時性分岔</code>的階段，可以回憶一下之前的這張圖。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day7_2.jpg" alt="Temporaily Fork" /></p>
<p>那既然暫時性分岔是POW機制與網路延遲下無可避免的結果，那區塊鏈該如何解決暫時性分岔並且回到同步的共識呢？</p>
<h2 id="bitcoin中的最長鏈機制"><a class="header" href="#bitcoin中的最長鏈機制">Bitcoin中的最長鏈機制</a></h2>
<p>Bitcoin的解決方式是<code>Winner Takes All</code>，最後只有一條最長的鏈會被當作主鏈，在工作量證明的機制下，通常擁有最多算力的那條鏈同時會擁有最快的出塊速度而成為最長鏈。</p>
<p><img src="images/day22_48661.png" alt="Longest Chain" /></p>
<p>圖片來源：<a href="https://www.mangoresearch.co/blockchain-forks-explained/">mangoresearch</a></p>
<p>那其餘因為太短被捨棄的區塊又稱為<code>孤兒塊(Orphan Block)</code>，挖到孤兒塊的節點會因為最後未能成為主鏈的一部分而被捨棄，其上的所有交易也會因此通通不算數，自然也沒有產生區塊的獎勵了！</p>
<h2 id="ethereum中的叔塊uncle-block機制"><a class="header" href="#ethereum中的叔塊uncle-block機制">Ethereum中的叔塊(Uncle block)機制</a></h2>
<p>但Bitcoin的平均出塊時間設定在十分鐘、Ethereum設定在15秒，兩者間的差距代表Ethereum出現暫時性分岔的機會與次數會遠遠多於Bitcoin。可以假設區塊從廣播到被接受都需要大概1秒的話，那麼Bitcoin出現孤兒塊的機會是1/600、Ethereum出現孤兒塊的機會是1/15。</p>
<p>Ethereum為了加速交易的認證與提升TPS而降低了出塊時間，也導致了孤塊比例的上升(實際上Ethereum的孤塊比例約落在6-8%上下，你可以到<a href="https://www.etherchain.org/">這裡</a>查看最新的孤塊比例。)，所以如果同樣採用Bitcoin的最長鏈機制會造成礦工間的不公平，畢竟所挖出的區塊實際上也是合法的，只是因為廣播稍慢而沒辦法成為最長鏈。所以Ethereum透過的是另一種機制<code>叔塊(Uncle block)</code>來給予挖出叔塊的礦工比正常塊略少的獎勵。</p>
<h3 id="叔塊如何被定義"><a class="header" href="#叔塊如何被定義">叔塊如何被定義</a></h3>
<p>首先我們必須定義叔塊是甚麼與叔塊名稱的由來，我們可以把暫時性分叉後主鏈所產生的第一個區塊稱為<code>父塊</code>，緊接著父塊的便是<code>子塊</code>，而暫時性分岔的支鏈上第一個區塊因為對於子塊來說是與父塊同輩份的，所以也稱為<code>叔塊</code>，但叔塊還有另一個條件就是<strong>叔塊必須被後面的子區塊採用入主鏈</strong> 才能算是叔塊，否則便只能被丟棄而形成孤兒塊。：</p>
<p><img src="http://www.lkm543.site/it_iron_man/day23_2.jpg" alt="Uncle Block" /></p>
<p>那為什麼會有人想把叔塊採用入主鏈？因為在主鏈上每採用一塊叔塊的礦工都能夠獲取<code>1/32</code>的出塊獎勵，透過獎勵機制去鼓勵主鏈上的礦工吸納叔塊！但Ethereum也限制每個區塊最多採用兩個叔塊為限。</p>
<h3 id="如何計算叔塊獎勵"><a class="header" href="#如何計算叔塊獎勵">如何計算叔塊獎勵</a></h3>
<p>至於挖掘叔塊的礦工獎勵是如何計算的呢？這關係到叔塊是否有在暫時性分叉後的六代內被採納入主鏈，只有差距在六代內的叔塊會獲得獎勵，每間隔一層所獲得的出塊獎勵就會減少12.5%。</p>
<ol>
<li>間隔一層：87.5%出塊獎勵</li>
<li>間隔兩層：75.0%出塊獎勵</li>
<li>間隔三層：62.5%出塊獎勵</li>
<li>間隔四層：50.0%出塊獎勵</li>
<li>間隔五層：37.5%出塊獎勵</li>
<li>間隔六層：25.0%出塊獎勵</li>
</ol>
<p>關於代數的計算可以參考下圖：</p>
<p><img src="http://www.lkm543.site/it_iron_man/day23_3.jpg" alt="Uncle Block" /></p>
<p>但因為採納叔塊對於主鏈上的礦工也有益處，所以通常在兩至三代內叔塊就會被收入主鏈中，在<a href="https://eth.nanopool.org/blocks">Nanopool</a>的出塊清單中你也可以看到由nanopool挖出的區塊中有哪些是叔塊、第幾代叔塊，其中<code>區塊序號_u代數</code>代表的便是叔塊(u即是Uncle的縮寫)！你也可以在<a href="https://etherscan.io/chart/uncles">Etherscan</a>上看到每天產出叔塊的個數，平均每天會產出500塊左右的叔塊，高峰期甚至會超過一天2000塊。</p>
<h3 id="叔塊對整體礦工的利益是好的嗎"><a class="header" href="#叔塊對整體礦工的利益是好的嗎">叔塊對整體礦工的利益是好的嗎？</a></h3>
<p>回憶一下我們在<a href="https://ithelp.ithome.com.tw/articles/10215089">Day04|打造一個簡易的區塊鏈(3)：難度調整與確認哈希鏈</a>有寫到如何調控出塊難度：</p>
<pre><code>if average_time_consumed &gt; self.block_time:
    self.difficulty -= 1
else:
    self.difficulty += 1
</code></pre>
<p>也就是當實際的出塊時間長於設定值便減低難度，若短於設定值便增加難度；而Ethereum出塊難度的調控是根據<strong>主鏈的出塊時間</strong> 來調控的，叔塊的礦工並不會被記入難度的調整之中，因此若有礦工挖掘叔塊便可以提升整體礦工的利益！</p>
<p>口說無憑，我們來做個簡單的計算：</p>
<h4 id="全部礦工只挖掘主鏈也不採納叔塊"><a class="header" href="#全部礦工只挖掘主鏈也不採納叔塊">全部礦工只挖掘主鏈、也不採納叔塊</a></h4>
<p>出塊獎勵為R，假設在全部礦工只挖掘主鏈時的出塊時間為T，單位時間內的總利益便是<code>R/T</code>，如果持有算力的N%，則單位時間的預期收益便是<code>R/T*N/100</code>。</p>
<h4 id="有x的礦工專門挖掘叔塊"><a class="header" href="#有x的礦工專門挖掘叔塊">有x%的礦工專門挖掘叔塊</a></h4>
<p>為了方便計算，我們這裡假設每一區塊在下一代便後被收入主鏈中，對於挖掘出叔塊的礦工而言獎勵便是0.875*R，因為有x%在負責挖掘叔塊，剩下(100-x)%便是在挖掘主鏈。對於兩種礦工而言：</p>
<ul>
<li>專門挖掘主鏈的礦工</li>
</ul>
<p>剩下(100-x)%在挖掘礦工會因為只剩下(100-x)/100的總算力在挖掘主鏈，持有算力的N%的礦工預期出塊收益就會變成：<code>R/T*100/(100-x)*N/(100-x)</code>。另外每在主鏈上產生一個區塊後，平均會產生x/(100-x)個叔塊，因此外加採納叔塊的獎勵為<code>R/T/32*x/(100-x)*N/(100-x)</code>。</p>
<p>總收益<code>R/T*100/(100-x)*N/(100-x)+R/T/32*x/(100-x)*N/(100-x)</code>會大於原本的<code>R/T*N/100</code></p>
<ul>
<li>專門挖掘叔塊的礦工</li>
</ul>
<p>對於在側鏈上專門挖掘叔塊的礦工而言，同樣每在主鏈上產生一個區塊後，平均會產生<code>x/(100-x)</code>個叔塊，因此在側鏈上持有總算力的N%的礦工挖掘叔塊的獎勵為<code>R/T*0.875*x/(100-x)*N/x</code>，約分後可以得到<code>R/T*0.875/(100-x)*N</code>。</p>
<p>也就是當<strong>挖掘叔塊的算力超過12.5%時</strong> ，挖掘叔塊的礦工也能夠取得比原本大家都擠在主鏈上更多的收益。</p>
<h2 id="51攻擊"><a class="header" href="#51攻擊">51%攻擊</a></h2>
<p>其中一種攻擊區塊鏈的方式便是透過暫時性分岔的特性，也就是先在主鏈上付款給別人後後迅速使用過半的算力挖掘另一個區塊，使的原本包含付款交易的區塊之後因為長度小於主鏈而被遺棄成為孤兒塊，裏頭付款的交易自然就不算數了。詳細運作流程可以參考下圖：</p>
<p><img src="images/day22_25108.png" alt="51% Attack" /></p>
<p>圖片來源：<a href="https://medium.com/coinmonks/what-is-a-51-attack-or-double-spend-attack-aa108db63474">Blockchain: how a 51% attack works (double spend attack)</a></p>
<p>51%攻擊需要取得整條鏈過半的算力才有可能達成，在<a href="https://www.exaking.com/51">這個網站</a>中你可以看到每發起一小時51%攻擊所需要的成本，鏈上擁有的算力越多會造成攻擊者為了攻擊所需購入算力的成本越高，所以通常51%攻擊都是針對較為小眾的區塊鏈攻擊。</p>
<p>像是ETC便因為算力不足曾經被51%攻擊過(<a href="https://blockcast.it/2019/01/10/gateio-confirms-51-percent-attack-on-etc-promises-refunds/">相關報導</a>)，也因為算力的租借是以時間為單位的，增加入賬時所需要的確認區塊數可以有效增加發動51%攻擊的成本，但也會增加使用者所需要的等待時間。</p>
<p>暫時性分岔的講解就到此為止，明天我們就要進入到區塊鏈升級過程中必定會經歷的軟分岔與硬分岔！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-20"><a class="header" href="#ref-20">Ref:</a></h1>
<ul>
<li><a href="https://kknews.cc/zh-tw/tech/3v35yzg.html">以太坊為什麼要設置區塊的叔塊獎勵？</a></li>
<li><a href="https://blog.ethereum.org/2016/10/31/uncle-rate-transaction-fee-analysis/">Uncle Rate and Transaction Fee Analysis</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28928827">以太坊(Ethereum ETH)的奖励机制</a></li>
<li><a href="https://medium.com/taipei-ethereum-meetup/%E6%AF%94%E7%89%B9%E5%B9%A3-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E5%95%8F%E9%A1%8C%E4%BB%8B%E7%B4%B9-%E4%B8%80-5f4e07b9ca71">比特幣、以太坊的一些問題介紹(一)</a></li>
<li><a href="https://bitslog.com/2016/04/28/uncle-mining-an-ethereum-consensus-protocol-flaw/">Uncle Mining, an Ethereum Consensus Protocol Flaw</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day23p2p網路4升級之路上的岔路口-軟分岔與硬分岔"><a class="header" href="#day23p2p網路4升級之路上的岔路口-軟分岔與硬分岔">Day23|P2P網路(4)：升級之路上的岔路口-軟分岔與硬分岔</a></h1>
<h1 id="升級之路上的岔路口"><a class="header" href="#升級之路上的岔路口">升級之路上的岔路口</a></h1>
<p><img src="images/day23_78481.jpg" alt="Fork Road" /></p>
<p>圖片來源：<a href="https://www.danblewett.com/the-necessity-of-failure-the-fork-in-the-road/">danblewett</a></p>
<p>昨天我們提到網路廣播的延遲會產生不可避免的<code>暫時性分岔</code>，而今天要提的分岔則跟整個P2P網路的軟體升級有關。一般網站或APP升級都會由中心化伺服器負責軟體更新，或是派送新版本的軟體到用戶端要求用戶安裝。但去中心化的P2P網路則不同，因為每個節點都是獨立平等的存在，所以如果要更新目前運作的軟體版本，節點也有可能拒絕或是選擇另一個版本繼續運作，因此根據新版本在原本P2P網路中是否會互相排斥或是相容就會分成<code>軟分岔(Soft Fork)</code>與<code>硬分岔(Hard Fork)</code>。</p>
<p>軟分岔(Soft Fork)與硬分岔(Hard Fork)跟暫時性分岔有一個很大的不同：暫時性分岔不牽涉到程式碼或是協定的更動，只是因為網路延遲造成短期間無法同步所有資料的現象，而軟分岔(Soft Fork)與硬分岔(Hard Fork)則會<strong>永久更動現行運作的程式碼</strong> 。更動程式碼的原因有很多，最常見的幾種分別是：</p>
<ol>
<li>新增過去沒有的功能：</li>
</ol>
<p>2012年3月份Bitcoin根據BIP16新增了<a href="https://www.binance.vision/zt/security/what-is-a-multisig-wallet">多重簽名</a>的付款方式，詳情可以參考<a href="https://en.bitcoin.it/wiki/Pay_to_script_hash">這裡</a>。</p>
<ol start="2">
<li>回溯過去的資料：</li>
</ol>
<p>2016年DAO(the Decentralized Autonomous Organization)被盜走了360萬顆ETH，為了追回被盜取的ETH，採取硬分岔的方式回溯到資產轉移之前，相關<a href="https://www.ithome.com.tw/news/107405">新聞報導</a>。</p>
<ol start="3">
<li>修改某部分運行的參數：</li>
</ol>
<p>XMR為了對抗ASIC固定每半年會更新一次挖礦的參數。</p>
<p>既然軟分岔(Soft Fork)與硬分岔(Hard Fork)都跟節點運行的軟體升級有關，那麼首先來談談節點們又是如何決定升級的方向與內容呢？</p>
<h2 id="從社群提案到接受"><a class="header" href="#從社群提案到接受">從社群提案到接受</a></h2>
<p>去中心化的區塊鏈並沒有權威的中心機構來決定未來升級的方向與內容，因此未來升級方向的提案、討論、決定都是仰賴社群意見的協助，為了凝聚社群共識與方便大家提案，社群也會在Github上開啟專門的Repository來標示各提案的內容，有意參與討論的人都可以在下自由留言。</p>
<h3 id="bipbitcoin-improvement-proposals"><a class="header" href="#bipbitcoin-improvement-proposals">BIP(Bitcoin Improvement Proposals)</a></h3>
<p>Bitcoin的改善協議稱為<code>Bitcoin Improvement Proposals(BIP)</code>，你可以到<a href="https://github.com/bitcoin/bips">Github</a>上看到Bitcoin至今的所有BIP與社群的意見。BIP是社群間彼此溝通想法的方式，一旦議題被社群廣泛接受就會被收入BIP，下圖便是BIP收入後大致的運作流程與可能結果。</p>
<p><img src="images/day23_33978.png" alt="BIP" /></p>
<p>圖片來源：<a href="https://en.bitcoin.it/wiki/Bitcoin_Improvement_Proposals">Bitcoin Wiki</a></p>
<p>每個BIP在被當作草稿(<code>Draft</code>)提出後會有四種可能：被廣泛接受後被實作在鏈上(<code>Accepted</code>)、被社群拒絕(<code>Rejected</code>)、發起者自己撤銷提案(<code>Withdrawn</code>)、推遲提案(<code>Deferred</code>)。值得一提的是或許是開源社群的習慣，社群很少直接拒絕(Reject)某個提案，而通常以推遲(Deferred)或自行撤回(Withdrawn)的方式結束，少數幾個被Rejected例外就是想把區塊容量依照中本聰原本的想法擴容至2MB的<a href="https://github.com/bitcoin/bips/blob/master/bip-0109.mediawiki">BIP109</a>，提出BIP109的是與中本聰一起參與過的Gavin Andresen，該次Reject也間接導致後續Bitcoin社群的分裂與BCH的分岔，甚至還有專人架設<a href="http://bip109.com/">網站</a>聲援Bitcoin應該要照原本中本聰理想的實行BIP109。</p>
<h3 id="eipethereum-improvement-proposals"><a class="header" href="#eipethereum-improvement-proposals">EIP(Ethereum Improvement Proposals)</a></h3>
<p>與Bitcoin的BIP類似，社群經過提案後會產生相對應的<code>Ethereum Improvement Proposals(EIP)</code>，Ethereum主要由乙太坊基金會在開發與維持社群，因此與Bitcoin不同的是在營運上較為中心化，官方對於EIP會發出相應的ERC討論。</p>
<p>ERC的全名是<code>Ethereum Request for Comments</code>，就是徵求社群間的意見，此時ERC的編號與EIP通常會一致，最有名的EIP與ERC莫過於<a href="https://medium.com/myethacademy/%E5%88%B0%E5%BA%95%E4%BB%80%E9%BA%BC%E6%98%AFerc-20-49d052e8d290">ERC20</a>成為代幣的標準並引發2017-2018年間的ICO熱潮，在<a href="https://eips.ethereum.org/">這裡</a>你也可以看到所有的EIP列表。</p>
<h2 id="軟分岔soft-fork與硬分岔hard-fork"><a class="header" href="#軟分岔soft-fork與硬分岔hard-fork">軟分岔(Soft Fork)與硬分岔(Hard Fork)</a></h2>
<p>在P2P網路中每個節點對於是否要接受新提案都是自由的，也就是每個節點所運行的區塊鏈版本不一定一致，在P2P網路中也可能會有多個版本共存，根據<strong>是否要接受過去版本的資訊可以分成軟分岔(Soft Fork)與硬分岔(Hard Fork)</strong> 。</p>
<ul>
<li>軟分岔(Soft Fork)─更新後仍然可以接受與過去版本間形成部份的共識</li>
<li>硬分岔(Hard Fork)─更新後完全無法與舊版本形成共識</li>
</ul>
<p>如果你對軟體有點概念的話，軟體開發中所講到的<strong>向後相容</strong> 的概念(對過去的版本相容)就是軟分岔！</p>
<h2 id="軟分岔soft-fork"><a class="header" href="#軟分岔soft-fork">軟分岔(Soft Fork)</a></h2>
<p>軟分岔(Soft Fork)的定義是舊節點不升級也可以相容於部分的共識，因為共識可以在新舊版本間形成，所以<strong>新舊版本可以共存在同一條鏈之上</strong> 。</p>
<p><img src="https://bitcoin.org/img/dev/en-soft-fork.svg" alt="Soft Fork" /></p>
<p>圖片來源：<a href="https://www.mycryptopedia.com/hard-fork-soft-fork-explained/">mycryptopedia</a></p>
<p>軟分岔以<strong>功能的更新</strong> 居多，亦即雖然可以相容在同一條鏈上，但舊版本會沒有辦法使用新版本所推出的功能，就像是你可以使用Word2017去開啟Word2013的檔案，但如果你仍然在使用Word2013就會沒辦法使用某些Word2017才有的新功能了。</p>
<h2 id="硬分岔hard-fork"><a class="header" href="#硬分岔hard-fork">硬分岔(Hard Fork)</a></h2>
<p>硬分岔(Hard Fork)的定義是舊節點不升級就無法相容於新節點產生的共識，因為共識不能在新舊版本間形成，所以<strong>新舊版本不能共存在同一條鏈之上</strong> ，所以一旦網路中還有兩種版本在運行，則兩種版本就會岔開分成兩條獨立的鏈，各走各的路。</p>
<p><img src="https://bitcoin.org/img/dev/en-hard-fork.svg" alt="Soft Fork" /></p>
<p>圖片來源：<a href="https://www.mycryptopedia.com/hard-fork-soft-fork-explained/">mycryptopedia</a></p>
<p>之所以新舊版本不能共存的原因通常在於<strong>共識規則的更新</strong> ，如果未更新成新的共識規則會導致舊版本無法驗證新版本所產生的區塊。</p>
<h3 id="ifoinitail-fork-offering"><a class="header" href="#ifoinitail-fork-offering">IFO(Initail Fork Offering)</a></h3>
<p>因為P2P網路可自由進出的關係，單一節點也可以採取自行開發的新硬分岔版本而跟多數節點脫離。任何人也都可以分岔出屬於自己的區塊鏈，因此有一陣子因為ICO被法令限制的關係，IFO成為某些人手中的印鈔機─你可以可以輕易的分岔出一條區塊鏈然後把部分的挖礦所得直接配給自己(在<a href="https://medium.com/@jordan.baczuk/how-to-fork-bitcoin-part-1-397598ef7e66">這裡</a>及<a href="https://medium.com/@jordan.baczuk/how-to-fork-bitcoin-part-2-59b9eddb49a4">這裡</a>你可以學到如何岔出一條自己的Bitcoin)，雖然硬分岔在技術上是容易的，但分岔出的幣種市場是否能接受則仰賴市場上的共識了！實際上這些幣多半會因為流通量太低而成為一攤死水沒人理睬。</p>
<p><img src="images/day23_19576.jpg" alt="XMR Fork" /></p>
<p>圖片來源：<a href="https://steemit.com/monero/@cryptocurrencyhk/monero-monero">steemit</a></p>
<p>像是為了因應XMR修改演算法對抗比特大陸的ASIC，許多社群與礦機商分岔出了Monero Classic(XMC)、Monero-Classic(XMC)、Monero 0(XMZ)及Monero Original(XMO)，不過這些分岔出的幣多半都在一攤死水的狀態了。在<a href="https://steemit.com/monero/@cryptocurrencyhk/monero-monero">這裡</a>你可以看到更多進一步的消息。</p>
<h3 id="歷史上知名的硬分岔"><a class="header" href="#歷史上知名的硬分岔">歷史上知名的硬分岔</a></h3>
<p>歷史上最知名的兩次硬分岔莫過於<a href="https://ethereumclassic.github.io/">Ethereum Classic(ETC)</a>自Ethereum分岔出與<a href="https://www.bitcoincash.org/">Bitcoin Cash(BCH)</a>自Bitcoin分岔出的這兩段故事了。</p>
<h4 id="etc的分岔"><a class="header" href="#etc的分岔">ETC的分岔</a></h4>
<p>ETC的分岔起因於Ethereum為了拯救在2016年6月17日<a href="https://www.ithome.com.tw/news/106614">DAO被駭走的360萬顆ETH</a>而採取硬分岔回溯的行為，ETC的支持者認為這違反了區塊鏈不可竄改的精神，於是拒絕了Ethereum的提案留在舊鏈形成了Ethereum Classic(ETC)，真的說起來的話Ethereum Classic(ETC)才是真正的Ethereum。</p>
<h4 id="bch的分岔"><a class="header" href="#bch的分岔">BCH的分岔</a></h4>
<p>BCH的分岔則是因為不認同目前把持Bitcoin發展方向的Core所規劃的未來藍圖(<a href="https://www.blocktempo.com/lightning-network/">閃電網路</a>、<a href="https://www.blocktempo.com/understand-segwit-in3mins/">隔離驗證</a>等方向)，認為透過增加區塊容量到8MB就可以很容易解決目前TPS(Transactions per Second)過低的問題，也因此BCH新的共識規則便是8MB的區塊大小，但既然共識規則改變了，BCH新的共識規則自然無法相容於舊Bitcoin的1MB容量，於是兩者就分岔出不同鏈各走各的路了！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-21"><a class="header" href="#ref-21">Ref:</a></h1>
<ul>
<li><a href="https://www.mycryptopedia.com/hard-fork-soft-fork-explained/">BlockchainHard ForkSoft Fork Blockchain Soft Fork &amp; Hard Fork Explained</a></li>
<li><a href="https://medium.com/@crypto.peng/%E4%BB%80%E9%BA%BC%E6%98%AF%E5%8D%80%E5%A1%8A%E9%8F%88%E5%88%86%E5%8F%89-%E4%BB%80%E9%BA%BC%E5%8F%88%E6%98%AF%E7%A1%AC%E5%88%86%E5%8F%89-%E8%BB%9F%E5%88%86%E5%8F%89-2246d1d28d84">什麼是區塊鏈分叉? 什麼又是硬分叉/軟分叉?</a></li>
<li><a href="https://www.inside.com.tw/article/13733-fork-soft-hard">【硬塞科技字典】區塊鏈的分叉是什麼？還分為軟的和硬的？</a></li>
<li><a href="https://medium.com/@jordan.baczuk/how-to-fork-bitcoin-part-1-397598ef7e66">How to Fork Bitcoin — Part 1</a></li>
<li><a href="https://medium.com/@jordan.baczuk/how-to-fork-bitcoin-part-2-59b9eddb49a4">How to Fork Bitcoin — Part 2</a></li>
<li><a href="https://bitcointalk.org/index.php?topic=225690.0">Complete Guide on How to Create a New Alt Coin</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_bitcoin_forks">Wikipedia-List of bitcoin forks</a></li>
<li><a href="https://kknews.cc/zh-tw/finance/mkbayb6.html">一文讀懂BIP、EIP、ERC等相關概念</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day24現實中的區塊鏈1區塊鏈與代幣的發展"><a class="header" href="#day24現實中的區塊鏈1區塊鏈與代幣的發展">Day24|現實中的區塊鏈(1)：區塊鏈與代幣的發展</a></h1>
<h1 id="區塊鏈102030"><a class="header" href="#區塊鏈102030">區塊鏈1.0、2.0、3.0</a></h1>
<p>在提完前面對於區塊鏈架構、密碼學、挖礦、P2P網路的理論簡介之後，我們緊接著來介紹現實中的區塊鏈是如何運行的，其中又會以目前最主流的<code>Bitcoin</code>與<code>Ethereum</code>兩種為主，順帶一提的是區塊鏈並非一成不變的技術，在近10年的發展過程中也逐漸因應需要而不斷擴充功能，因此在明天正式開始介紹Bitcoin與Ethereum前我們先來闡述區塊鏈的發展沿革。</p>
<h2 id="區塊鏈10bitcoin"><a class="header" href="#區塊鏈10bitcoin">區塊鏈1.0─Bitcoin</a></h2>
<p><img src="images/day24_83452.svg" alt="Bitcoin" /></p>
<p>圖片來源:<a href="https://bitcoin.org/zh_TW/">Bitcoin.org</a></p>
<p><code>區塊鏈1.0</code>是由中本聰所開啟的區塊鏈浪潮，正如我們在<a href="https://ithelp.ithome.com.tw/articles/10215061">Day01|前言：區塊鏈的誕生</a>所提到的一樣是以<a href="https://wiki.mbalib.com/zh-tw/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B4%A6%E6%9C%AC%E6%8A%80%E6%9C%AF">分散式帳本</a>的技術為基礎完成<code>去中心化</code>，並且搭配密碼學的技術解決共識與信任的問題並且同時具有<code>不可竄改</code>的特性，有了這些區塊鏈上的才能夠取得人們的信任，並且取得作為交易媒介的資格。</p>
<p>因此區塊鏈1.0的概念相對單純，希望透過分散式帳本的技術與概念來打造一個不需仰賴政府跟金融機構的金流系統，在這個金流系統之上任何人都可以自由地創建帳戶與交易，無須受任何監管或限制，同時所有人也都必須服從區塊鏈上的規則無法任意增發貨幣。</p>
<p>如果要用一句話概括區塊鏈1.0的願景的話，便是<code>Be your own bank.</code>。</p>
<h2 id="區塊鏈20ethereum"><a class="header" href="#區塊鏈20ethereum">區塊鏈2.0─Ethereum</a></h2>
<p><img src="https://s.yimg.com/ny/api/res/1.2/79GZvpsBiB0w.4UMxQEijw--~A/YXBwaWQ9aGlnaGxhbmRlcjtzbT0xO3c9ODAw/http://media.zenfs.com/en-US/homerun/coin_rivet_596/45607ac1ecdfb82f720db97b79887702" alt="Ethereum" /></p>
<p>圖片來源: <a href="https://finance.yahoo.com/news/reasons-invest-ethereum-131930828.html">Yahoo Finance</a></p>
<p>隨著區塊鏈的發展，區塊鏈能做到的事情也不再只有是單純的金流與記帳，其中在早期有個叫做Vitalik Buterin的年輕人，期初他只是個普通的Bitcoin愛好者，但他認為除了單純的金流外，區塊鏈的技術應該能夠做到更多樣化的事情，因此他在2013年發表了Ethereum的白皮書<a href="http://blockchainlab.com/pdf/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf">A Next-Generation Smart Contract and Decentralized Application Platform</a>，主要認為可以透過區塊鏈技術打造一個平台讓大家可以在上面運行程式，讓區塊鏈除了儲存資料外也多了運算的功能。跟一般中心化的程式相比，在區塊鏈上可以確保程式的不可竄改，只要滿足在智能合約設定的條件就會自動觸發與執行事件，。</p>
<p><img src="images/day24_87790.png" alt="Smart Contract" /></p>
<p>圖片來源: <a href="https://medium.com/@ksin751119/ethereum-dapp%E5%88%9D%E5%BF%83%E8%80%85%E4%B9%8B%E8%B7%AF-3-%E7%B0%A1%E4%BB%8Bethereum-%E4%B9%99%E5%A4%AA%E5%9D%8A-smart-contract-%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84-7a0dfd32662f">Ethereum Dapp初心者之路(3): 簡介Ethereum(乙太坊)、Smart Contract(智能合約)</a></p>
<p>以下面這句話取自<a href="http://blockchainlab.com/pdf/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf">Ethereum白皮書</a>的例子為例：</p>
<blockquote>
<p>A can withdraw up to X currency units per day, B can withdraw up to Y per day, A and B together can withdraw anything, and A can shut off B's ability to withdraw.</p>
</blockquote>
<p>誰可以提領多少、何時可以提領、誰有權限限制別人提領通通都可以透過簡單的邏輯判斷來達成，因此透過Ethereum的智能合約可以達到可靠的信任─你不信任發行者沒關係，但你可以信任程式碼吧?而程式碼是不可以被竄改的。</p>
<p>用一句話來描述Ethereum願景的話就是：<code>Be the world's computer.</code></p>
<h2 id="區塊鏈30iota"><a class="header" href="#區塊鏈30iota">區塊鏈3.0─IOTA?</a></h2>
<p>至於Ethereum之後的區塊鏈3.0目前定調為何其實還沒有完整的共識，目前最多人認為的3.0是把類似分散本技術應用到更多領域與場景，其中最有名的便是<a href="https://www.iota.org/">IOTA</a>。</p>
<p><img src="images/day24_62471.jpg" alt="IOTA" /></p>
<p>圖片來源： <a href="https://www.forbes.com/sites/geraldfenech/2018/11/20/iota-fulfilling-the-promise-of-blockchain/#3b757e5a5735">Forbes</a></p>
<p>IOTA期望落實在物聯網的場景之中，也就是平常我們所使用的家電、交通工具、機器都能夠連上網路並且彼此交換訊息，IOTA期望盡可能地壓低機器間交換資訊的門檻與花費，並且極小化安裝所需要的硬體資源，所以可以說IOTA便是為了物聯網專門被設計出來的。</p>
<p>一個常被舉的應用上的例子便是二手車的買賣，如果車子的狀況能夠透過物聯網與IOTA隨時被記錄的話，那麼保養的車廠或是有意願購買二手車的買家便會多一層保障。抑或是如果車子可以分享目前的位置與速度等資訊到交通調度中心，則交通調度中心便可以有效掌握目前的交通狀況，為了回饋回傳資料的車子，交通調度中心可以支付少許的IOTA作為報酬。</p>
<p>但區塊鏈上的每一筆交易或傳輸所耗費的成本非常高，能容納的交易次數也相當有限，而IOTA的應用場景是大量、微型化的機器，在不久的將來全世界聯網的機器數目就會超過100億(下圖)，所以實際上IOTA並不採用區塊鏈架構，而是<code>Tangle</code>架構。</p>
<p><img src="https://iot-analytics.com/wp/wp-content/uploads/2018/08/Number-of-global-device-connections-2015-2025-Number-of-IoT-Devices.png" alt="IOT" /></p>
<p>圖片來源: <a href="https://iot-analytics.com/state-of-the-iot-update-q1-q2-2018-number-of-iot-devices-now-7b/">IoT Analytics</a></p>
<p>Tangle架構採用了之前提到的有向無環圖作為驗證，發起每一筆交易的同時也必須驗證前面兩筆資料的真偽，也因此每個機器除了發起交易外也必須擔當驗證交易的責任，在這種分工之下交易是不需要任何手續費的，同時只要採用IOTA的機器數目越多，單位時間內能容納的交易次數也越高。如果對Tangle架構有興趣的話這裡有更多<a href="https://hackmd.io/@blockchain/rkpoORY4W/%2Fs%2FryriSgvAW?type=book">參考資料</a>。</p>
<h1 id="區塊鏈上代幣的實務發展"><a class="header" href="#區塊鏈上代幣的實務發展">區塊鏈上代幣的實務發展</a></h1>
<p>其中發展最快的與五花八門的便是代幣經濟的發展(原因無它就是有利可圖)，其中根據代幣的來源與發展又可以分為：</p>
<h2 id="initial-coin-offeringico"><a class="header" href="#initial-coin-offeringico">Initial Coin Offering(ICO)</a></h2>
<p>在2017年大流行的<code>Initial Coin Offering(ICO)</code>多半是透過Ethereum上智能合約功能來發行ERC20代幣，在ERC20的程式碼裏頭(下)發行總數、轉移、餘額等等的皆是被事前定義好，ERC20為代幣發行方提供了一個統一完整的介面，因此日後交易所也只需要支援相同的介面就可以讓所有ERC20的代幣上架流通。</p>
<p>要發行ICO不難，複製幾行程式碼便行，購買方式其實也可以透過智能合約來完成，也就是綁定與ETH的匯率，當有人匯入ETH後便給予相對應代幣作為兌換，發行與購買的方便也造成了2017的ICO狂潮，浮濫發行的結果就是ICO項目的陣亡率往往逼近98-99%。但其實這麼高的陣亡率並不全然是ICO的錯，畢竟新創公司的陣亡率高於90%也是很平常的事情。</p>
<p>除了陣亡率過高導致後續投資人的興趣大減外，各國政府後續也對這類形式的募資採取封禁的態度，也因此許多項目的ICO也在後來直接禁止如美國人民的投資。</p>
<p>順帶一提，我認為法規的限制在保護散戶方面是正面的，比方說在股票金融市場炒作或內線交易皆是違法的金融重罪，但是在ICO這裡卻是完全無法可管也無任何責任。</p>
<pre><code>interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
</code></pre>
<h2 id="initial-exchange-offeringieo"><a class="header" href="#initial-exchange-offeringieo">Initial Exchange Offering(IEO)</a></h2>
<p>ICO的浮濫發行導致投資人的大量損失─因為並不是所有ICO最後都能夠上到交易所被交易，如果買到的代幣最後未能上交易所的話，代幣的投資人將面臨無處兌現的窘境，因此由交易所擔保並發行的代幣就稱為<code>Initial Exchange Offering(IEO)</code>，這類代幣發行後會由交易所直接上架交易流通，為投資人免除了買到的代幣無處可交易的風險，有些交易所甚至會為募資的項目方鎖定資本，採取定期定額或是社群監管的方式逐步釋放資金給項目方。</p>
<h2 id="initial-fork-offeringifo"><a class="header" href="#initial-fork-offeringifo">Initial Fork Offering(IFO)</a></h2>
<p><code>Initial Fork Offering(IFO)</code>便是我們之前提到透過分岔產出的新幣種，這類幣種在技術上的難度較ERC20代幣高上許多，與ERC20不同的是IFO的產生也代表背後會產出一條全新的公鏈，該代幣也由公鏈所支持。</p>
<h2 id="security-token-offeringsto"><a class="header" href="#security-token-offeringsto">Security Token Offering(STO)</a></h2>
<p><code>Security Token Offering(STO)</code>是把現實中的資產或證券加以代幣化，持有STO的同時也代表具有現實世界中某部分的產權或股權，這類形式的STO其實跟股票相當類似，與股票相比受到的法規限制與監管較少，透過區塊鏈的流通性也較高，可以輕易地在世界各地被交易。</p>
<p>雖然STO的發行相較傳統股票發行方便許多，但這些傳統法規上其實很大一部分都是為了保護你我這些投資的散戶避免被不良分子作為惡性吸金的工具，STO在監管上力道上的相對彈性也表示投資的風險相較一般股票來的大，如果有興趣查閱金管會對於STO的規定的話可以參考<a href="https://www.fsc.gov.tw/ch/home.jsp?id=96&amp;parentpath=0,2&amp;mcustomize=news_view.jsp&amp;dataserno=201906270004&amp;aplistdn=ou=news,ou=multisite,ou=chinese,ou=ap_root,o=fsc,c=tw&amp;dtable=News">這裡</a>。</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-22"><a class="header" href="#ref-22">Ref:</a></h1>
<ul>
<li><a href="https://medium.com/@ksin751119/ethereum-dapp%E5%88%9D%E5%BF%83%E8%80%85%E4%B9%8B%E8%B7%AF-3-%E7%B0%A1%E4%BB%8Bethereum-%E4%B9%99%E5%A4%AA%E5%9D%8A-smart-contract-%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84-7a0dfd32662f">Ethereum Dapp初心者之路(3): 簡介Ethereum(乙太坊)、Smart Contract(智能合約)</a></li>
<li><a href="https://medium.com/@reyesale/ethereum-the-world-computer-fb7b58948280">Ethereum — The World Computer</a></li>
<li><a href="https://www.bnext.com.tw/article/47256/iota-blockchain-iot-dlt">為物聯網量身設計「區塊鏈3.0」IOTA——專訪年僅23歲技術傳教士</a></li>
<li><a href="https://joyso.io/from-bitcoin-to-blockchain-3-0/?lang=zh-hant">從比特幣到區塊鏈3.0</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day25現實中的區塊鏈2bitcoin與ethereum的交易架構"><a class="header" href="#day25現實中的區塊鏈2bitcoin與ethereum的交易架構">Day25|現實中的區塊鏈(2)：Bitcoin與Ethereum的交易架構</a></h1>
<h1 id="bitcoin與ethereum的架構"><a class="header" href="#bitcoin與ethereum的架構">Bitcoin與Ethereum的架構</a></h1>
<p>昨天我們提到了區塊鏈與代幣的發展，今天我們會來解說目前最主流的兩大公鏈─Bitcoin與Ethereum。還記得我們在Day02-Day07有嘗試寫出一個最基本的區塊鏈嗎？稍後我們在講解架構時也會拿我們之前所寫的簡易區塊鏈做個簡單對照。</p>
<h1 id="bitcoin與ethereum的交易格式"><a class="header" href="#bitcoin與ethereum的交易格式">Bitcoin與Ethereum的交易格式</a></h1>
<p>回憶一下我們之前所寫的<code>get_balance</code>是專門用來取得某特定帳戶的餘額，因為區塊鏈上的代幣只會有三種來源：挖礦獎勵、挖到區塊中的手續費總和、收到別人的匯款款項，因此我們可以利用這三個來源把該帳戶的餘額統整起來。</p>
<pre><code>def get_balance(self, account):
    balance = 0
    for block in self.chain:
        # Check miner reward
        miner = False
        if block.miner == account:
            miner = True
            balance += block.miner_rewards
        for transaction in block.transactions:
            if miner:
                balance += transaction.fee
            if transaction.sender == account:
                balance -= transaction.amounts
                balance -= transaction.fee
            elif transaction.receiver == account:
                balance += transaction.amounts
    return balance
</code></pre>
<p>只是這樣並沒有辦法預防<code>雙花攻擊(Double Spending)</code>，也就是我們的確可以知道發起交易當下的用戶資產是否足夠，但卻無法保證使用者的餘額是否會被重複花用，因此只要交易紀錄尚未被寫進區塊內，<code>get_balance</code>所取得的餘額永遠不會減少，使用者可以無限制的發起交易並放置入<code>pending_transactions</code>等待礦工驗證。</p>
<p>即便是下面礦工打包交易所用的<code>add_transaction</code>函式中檢查餘額也只是檢查之前所有區塊的餘額，當下區塊的交易支出並沒有被計算進去，因此同一筆交易可以在新區塊中中不停出現而且不會被扣款。</p>
<pre><code>def add_transaction(self, transaction, signature):
    public_key = '-----BEGIN RSA PUBLIC KEY-----\n'
    public_key += transaction.sender
    public_key += '\n-----END RSA PUBLIC KEY-----\n'
    public_key_pkcs = rsa.PublicKey.load_pkcs1(public_key.encode('utf-8'))
    transaction_str = self.transaction_to_string(transaction)
    if transaction.fee + transaction.amounts &gt; self.get_balance(transaction.sender):
        return False, "Balance not enough!"
    try:
        # 驗證發送者
        rsa.verify(transaction_str.encode('utf-8'), signature, public_key_pkcs)
        self.pending_transactions.append(transaction)
        return True, "Authorized successfully!"
    except Exception:
        return False, "RSA Verified wrong!"
</code></pre>
<p>因此區塊鏈上所使用的交易格式必須能夠有效對抗這類的<code>雙花攻擊(Double Spending)</code>，另外也因為日常使用必須頻繁地確認帳戶餘額，同時交易格式的設計也要考量到盡可能地減少查閱餘額所需要的運算量。</p>
<h2 id="bitcoin的utxounspent-transaction-output架構"><a class="header" href="#bitcoin的utxounspent-transaction-output架構">Bitcoin的UTXO(Unspent Transaction Output)架構</a></h2>
<p>Bitcoin採用的是<code>UTXO(Unspent Transaction Output)架構</code>，直接翻譯過來便是還沒被用來支付的交易。你可以先把UTXO看作是一連串支票的集合，每張支票上面的數目不一，當你匯款給別人時，其實就是開給別人一張尚未支付的支票(UTXO)，接著如果別人想要使用，就把支票(UTXO)拿去匯款生成另一張尚未支付的UTXO給被匯款者，如果匯款後自身仍然有餘額便會再生成一張支票(UTXO給自己)</p>
<p><img src="http://www.lkm543.site/it_iron_man/day26_2.JPG" alt="UTXO" /></p>
<p>以上圖為例，當Bob收到別人所支付的5BTC時，就相當於收到別人給的5BTC的支票(UTXO)，如果Bob日後匯款2BTC給Ally，就等於利用這張5BTC的支票開給Ally一張價值2BTC的UTXO，至於剩下的3BTC則會生成另一張支票(UTXO給自己)，這個方式也能夠有效對抗雙花攻擊，因為每一張UTXO最多只能被使用一次。</p>
<p><img src="http://www.lkm543.site/it_iron_man/day26_3.JPG" alt="blockstream" /></p>
<p>圖片來源: <a href="https://blockstream.info">blockstream</a></p>
<p>在<a href="https://blockstream.info">這裡</a>你可以看到每個區塊中的交易，上圖便是一筆交易動用了兩個UTXO後，生成四個新的UTXO給不同的對方，會使用到兩個UTXO代表單一UTXO並無法支應全部的開銷。</p>
<p><img src="http://www.lkm543.site/it_iron_man/day26_4.jpg" alt="blockstream" /></p>
<p>圖片來源: <a href="https://blockstream.info">blockstream</a></p>
<p>展開交易紀錄你也可以直接看到哪幾個UTXO是處在尚未被使用(Unspent)的狀態，因此帳戶目前可以動用餘額(Balance)其實就是所有持有UTXO的金額總和！</p>
<p>打開Bitcoin的<a href="https://www.blockchain.com/explorer">區塊鏈瀏覽器</a>你更可以看到目前總共有大約6000萬個<a href="https://utxo-stats.com/">UTXO</a>，至於目前Transaction的總數目大約落在5億左右(<a href="https://www.quandl.com/data/BCHAIN/NTRAT-Bitcoin-Total-Number-of-Transactions">參考資料</a>)。</p>
<h3 id="utxo如何預防雙花攻擊"><a class="header" href="#utxo如何預防雙花攻擊">UTXO如何預防雙花攻擊</a></h3>
<p>UTXO如同支票一般，限制了每張支票(UTXO)都只能夠被使用一次，透過了限制UTXO的使用次數來避免雙花攻擊。但UTXO有個缺陷就是在交易被納入區塊前，該UTXO是可以無限制地被使用的，至於哪筆交易會實際被礦工採納則視交易手續費決定，因此在收款前請務必確認UTXO已被礦工打包進入區塊中。</p>
<h3 id="utxo的優點"><a class="header" href="#utxo的優點">UTXO的優點</a></h3>
<h4 id="scalability-1"><a class="header" href="#scalability-1">Scalability</a></h4>
<p>UTXO的架構是以UTXO為單位進行交易，因此可以同時發起複數個交易給不同的收款方，在擴展性上有優勢。</p>
<h4 id="privacy"><a class="header" href="#privacy">Privacy</a></h4>
<p>雖然Bitcoin並沒有辦法做到完全的資訊隱藏，但在UTXO架構下以支票為單位作為交易相較容易保障雙方的隱私。</p>
<h2 id="ethereum的account架構"><a class="header" href="#ethereum的account架構">Ethereum的Account架構</a></h2>
<p>上頭提到UTXO的架構有個缺陷是在UTXO正式進入區塊前該UTXO可被使用無數次，因此匯款方可以使用同一個UTXO重複付款，一但收款方沒有仔細確認是否已經被區塊打包就可能受騙上當，在Ethereum的白皮書<a href="http://blockchainlab.com/pdf/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf">A Next-Generation Smart Contract and Decentralized Application Platform</a>中是這樣舉例的：</p>
<blockquote>
<p>If one entity has 50 BTC, and simultaneously sends the same 50 BTC to A and to B, only the transaction that gets confirmed first will process.</p>
</blockquote>
<p>因此Ethereum採用的是Account架構，也就是相當於銀行的簽帳卡，每張簽帳卡都有對應到帳戶的餘額，每次發送交易前也都會再次確認餘額是否足夠，Ethereum上同時也會記錄每個錢包地址目前的餘額。</p>
<p><img src="http://www.lkm543.site/it_iron_man/day26_5.JPG" alt="Etherscan" /></p>
<p>圖片來源: <a href="https://etherscan.io/address/0xc88f7666330b4b511358b7742dc2a3234710e7b1">etherscan</a></p>
<p>在<a href="https://etherscan.io/">Etherscan</a>上，任意點開一個地址(上圖)，便可以發現裏頭清楚記錄了關於這個地址每一筆交易的相關細節，像是收款方、匯款方、金額、或手續費等。這便是我們提到的Account架構─每個帳戶都清楚記錄了目前的狀態，交易明細也只要簡單記錄收款與匯款方即可。</p>
<h3 id="account架構如何預防雙花攻擊"><a class="header" href="#account架構如何預防雙花攻擊">Account架構如何預防雙花攻擊</a></h3>
<p>為了避免雙花攻擊，Ethereum會給單一Account發出的交易一個逐漸遞增的nonce值，也就是下圖中的紅色框框，nonce值較小的交易便會優先執行，因此收款方便可以透過查閱該帳戶所有簽發過的交易次序來事先確認該交易的優先順序為何。</p>
<p><img src="http://www.lkm543.site/it_iron_man/day26_6.JPG" alt="Etherscan" /></p>
<p>圖片來源: <a href="https://etherscan.io/tx/0x5b9e49b7d8f1a8709ab8f334691c4152ea395ada213159679ff3292f1dcd3a76">etherscan</a></p>
<h3 id="input-data"><a class="header" href="#input-data">Input Data</a></h3>
<p>如果你有仔細看的話應該會發現Ethereum的交易紀錄中有一欄<code>Input Data</code>，該欄位也可以拿來觸發過幾天後我們會提到的智能合約的功能，透過Input Data告知區塊鏈上的礦工我們想要觸發智能合約裡的哪個函式，或是可以用來記錄這筆交易的用途，有時候甚至會利用區塊鏈的不可竄改特性特意遺留某些文字在區塊鏈上。</p>
<p>比方說在<a href="https://etherscan.io/tx/0xf56d81301da93f71368ad7f8d605648d77be6edb13e8875cf3e5906f38d1b548">這裡</a>你可以看到由Ryu Gi-hyeok寫入的南北韓和平宣言(下圖)，或是由不知名人士為避免政府封鎖所寫入的<a href="https://etherscan.io/tx/0x2d6a7b0f6adeff38423d4c62cd8b6ccb708ddad85da5d3d06756ad4d8a04a6a2">北大性侵案</a>。要觀看這些文字只需要簡單按下Click to see More，並再View input as那欄選擇UTF-8便可以用文字的形式閱讀。</p>
<p><img src="http://www.lkm543.site/it_iron_man/day26_7.JPG" alt="Etherscan" /></p>
<p>圖片來源: <a href="https://etherscan.io/tx/0xf56d81301da93f71368ad7f8d605648d77be6edb13e8875cf3e5906f38d1b548">etherscan</a></p>
<h3 id="account架構的優點"><a class="header" href="#account架構的優點">Account架構的優點</a></h3>
<h4 id="simplicity"><a class="header" href="#simplicity">Simplicity</a></h4>
<p>Account架構的優點就是簡單明瞭，跟我們平常生活中所使用的銀行、金融卡原理上是一致的，相較容易被大眾理解與接受。</p>
<h4 id="efficiency"><a class="header" href="#efficiency">Efficiency</a></h4>
<p>Account架構的另一個優點是在簡單、一對一的交易中效率較高，只需要單純對兩方的餘額做增減，並不需要產生額外的UTXO即可完成。</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-23"><a class="header" href="#ref-23">Ref:</a></h1>
<ul>
<li><a href="https://medium.com/@sunflora98/utxo-vs-account-balance-model-5e6470f4e0cf">UTXO vs Account/Balance Model</a></li>
<li><a href="https://steemit.com/cn-cryptocurrency/@antonsteemit/utxo">比特幣UTXO模型介紹-如何解讀比特幣交易</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/57272282">UTXO 和 Account 模型对比</a></li>
<li><a href="https://www.blocktempo.com/historic-korean-peace-declaration-recorded-on-ethereum-blockchain/">【以太坊區塊鏈】紀錄歷史性的一刻：南北韓和平宣言</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day26現實中的區塊鏈3bitcoin的發展與路線之爭"><a class="header" href="#day26現實中的區塊鏈3bitcoin的發展與路線之爭">Day26|現實中的區塊鏈(3)：Bitcoin的發展與路線之爭</a></h1>
<h1 id="bitcoin的發展"><a class="header" href="#bitcoin的發展">Bitcoin的發展</a></h1>
<p>自中本聰在2009年1月正式推出Bitcoin以來，為了擴展交易速度或增加實用性，也經歷了不少次的版本升級，今天我們便來介紹其中三個較為人知也影響較大的發展項目：多重簽名、隔離驗證、閃電網路。</p>
<h1 id="多重簽名"><a class="header" href="#多重簽名">多重簽名</a></h1>
<p>我們在之前談到非對稱加密時有提到非對稱加密會產生一對公私鑰，透過私鑰簽署、公鑰驗證的過程我們便可以讓礦工驗證這筆交易的確是由我們發出的。但是這種交易方式完全仰賴於單一金鑰，如果持有金鑰的人是單一行為人，那麼對於公司或企業的資產保障都是不足的，因此多重簽名的功能便是讓資產的動用必須經過多重的核可才能夠進行。</p>
<h2 id="多重簽名的原理"><a class="header" href="#多重簽名的原理">多重簽名的原理</a></h2>
<p>在<a href="https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki">BIP11</a>中，是這樣介紹多重簽名的：</p>
<blockquote>
<p>This BIP proposes M-of-N-signatures required transactions as a new 'standard' transaction type.</p>
</blockquote>
<p>這裡的N代表所有的公鑰數目，M代表的是要取得其中多少公鑰的驗證後才能准許這筆交易，也就是當同意這筆交易的公鑰數目≧當初所設定的公鑰門檻M時，該交易才會被執行，舉例來說如果公司的董事會有八人，必須取得過半數(五人)才能夠移動資產的話，這時候的交易便是5-of-8-signatures。</p>
<h2 id="pay-to-multi-signaturep2ms"><a class="header" href="#pay-to-multi-signaturep2ms">Pay to Multi Signature(P2MS)</a></h2>
<p><code>Pay to Multi Signature(P2MS)</code>顧名思義就是開立一張必需有多人簽名才能動用的支票(UTXO)，在這裡如果我們想要開立一張總人數為n，而且至少要取得其中m個簽名才能動支的UTXO我們可以這樣實作，：</p>
<pre><code>m {pubkey_1} {pubkey_2}...{pubkey_n} n OP_CHECKMULTISIG
</code></pre>
<p>如果要動支這筆UTXO，只需要取得這n個公鑰背後的私鑰簽章即可動支這筆UTXO！</p>
<pre><code>OP_0 {signature_1} {signature_2}
</code></pre>
<p>順帶一提，目前n個公鑰的上限為15個喔！</p>
<h2 id="pay-to-script-hashp2sh"><a class="header" href="#pay-to-script-hashp2sh">Pay to Script Hash(P2SH)</a></h2>
<p>但P2MS有一個重大缺陷就是付款方必須使用特別的交易格式或軟體，同時付款的交易非常的冗長，比方說如果客戶要付款給公司帳戶，而公司帳戶的動支規定為八個董事中超過五個同意才能動支的話，這筆交易的付款方式對客戶而言就是：</p>
<pre><code>5
1FAnKjxL3u1skWqwZaJnPpHe6hCL89Dgr3 19rpuEq7vviLu4S4vUVHqKhB16ws7dx23W
15BSBGRBh7WFsz4RESK6EXhtRZAPDkRPtY 19EWhNncVwGn4Bg1nS6pHL5XY4xSzanDHG
1DxXFUr79TJD7Vth4rRVa7S1uLqCmvbGYb 1JbMgzWWPY4eG1m6b5a6ZSJwf5a4dnZB4m
15cJgaTYikDChKUL6feNQjY5KjawwLJF4f 15TG8KCtqeu5qEj6Bp6L1BpJK1MTZ59UCi
14sCN3g5YqLds9mGUa3GtkoSvgW4mNSLwc 1NsshQhjptKTJy8gRVJP2ZV6nVz8LuDh6o 
8 OP_CHECKMULTISIG
</code></pre>
<p>不只如此，當這筆交易送上鏈去給礦工驗證時也會佔去相對應的空間，因此在<a href="https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki">BIP13</a>中所描述的<code>Pay to Script Hash(P2SH)</code>便應運而生，它把其中的P2MS的指令(script)編碼成20Bytes的大小，像是編碼成3aaaf9a2c06124ad1bf433ba9b2f78634b81e77b，這樣付款方就可以直接把多重簽名的付款當作是一般的付款來執行了！</p>
<p>除此之外因為經過P2SH的編碼開頭都是3，所以如果你看到3開頭的地址就可以知道這是P2SH的地址了！實際上你到交易所或是<a href="https://www.bitmex.com/">Bitmex大賭場</a>上的入金地址大部分都是3開頭的便是這個原因。</p>
<pre><code>OP_HASH160 3aaaf9a2c06124ad1bf433ba9b2f78634b81e77b OP_EQUAL
</code></pre>
<p>這樣對於付款方而言不就簡單多了嗎？除此之外對於減少區塊鏈上的工作與儲存量也會大有幫助！</p>
<h1 id="隔離驗證segregated-witnesssegwit"><a class="header" href="#隔離驗證segregated-witnesssegwit">隔離驗證(Segregated Witness，Segwit)</a></h1>
<p><code>隔離驗證(Segregated Witness，Segwit)</code>提供了一種方案把交易時鏈上所需要占用的空間減少，總地來說它只會降低交易所需的費用，對於區塊鏈整體的架構或共識並沒有很大的更動，因此也屬於軟分岔的一種。</p>
<p>在<a href="https://blockstream.info">Blockstream</a>裏頭如果點開任何一筆交易便可以看到下面這段文字：</p>
<p><img src="https://www.lkm543.site/it_iron_man/day27_1.JPG" alt="Segwit@blockstream" /></p>
<p>圖片擷取自: <a href="https://blockstream.info">Blockstream</a></p>
<p>意即Segwit大約可以為每筆交易節省約1/3的手續費費用，節省手續費費用也代表所需佔用的鏈上空間減少，單一區塊內能夠容納更多的交易，讓Bitcoin有更高的TPS(Transaction per Second)。那麼Segwit是如何在不變動區塊大小的情形下做到這件事情的呢？</p>
<p>在最初始的Bitcoin中，每一筆交易都會搭配由公鑰持有人簽章的數位簽章，而Segwit則是把數位簽章移到區塊的最末端(下圖)，這些數位簽章可以稱為<code>Witness Data</code>，也因為把這些Witness Data隔離出來所以才稱這種方式為<code>Segregated Witness</code>。</p>
<p><img src="https://i1.wp.com/ethereumworldnews.com/wp-content/uploads/2019/05/segwit-coin-explained-1024x506.png" alt="Segwit" /></p>
<p>圖片來源：<a href="https://ethereumworldnews.com/bitcoin-core-0-18-0-bets-on-segwit-adoption-and-hints-at-offline-tx-signing/">ethereumworldnews</a></p>
<p>一旦礦工在計算1MB的區塊大小時不計入Witness Data的大小，只存放交易的紀錄，那麼同一區塊內能夠存放的交易數目就變多了！但Witness Data的大小也必須被限制，因此出現另外一個詞叫做<code>Block weight</code>，對於Block weight的容量計算與限制是這樣的：</p>
<blockquote>
<p>Block weight = 去掉Witness Data的交易空間大小*3 + 交易空間大小 ≦ 4MB</p>
</blockquote>
<p>因此對於一個沒有使用隔離見證的區塊而言，Block weight的上限大約就是原本區塊容量1MB的四倍=4MB，但如果裏頭含有隔離見證的資料，那麼Block weight的大小上限就會小於4MB。</p>
<p>與原本的區塊容量比較，在完全沒有隔離驗證的情形下會變成下面：</p>
<blockquote>
<p>4*交易空間大小 ≦ 4MB</p>
</blockquote>
<p>也就是說即便你尚未完成Segwit的升級，那麼也不會影響原本區塊大小的限制(1MB)，所以Segwit為軟分岔。</p>
<p>至於實際上的交易容量中大約2/3的大小都被拿來用作儲存Witness Data之用，把2/3這個數據套入上面的公式可以得到：</p>
<blockquote>
<p>Block weight = 1/3<em>交易空間大小</em>3 + 交易空間大小 = 2*交易空間大小 ≦ 4MB</p>
</blockquote>
<blockquote>
<p>交易空間大小 ≦ 2MB</p>
</blockquote>
<blockquote>
<p>區塊大小 = 1/3*交易空間大小 ≦ 1MB</p>
</blockquote>
<p>也就是說如果交易全部採用隔離見證方式的話，大約相較傳統方式可以提升區塊兩倍的交易量，同時也可以符合原先區塊容量1MB的限制！。</p>
<h2 id="為什麼不直接加大區塊"><a class="header" href="#為什麼不直接加大區塊">為什麼不直接加大區塊</a></h2>
<p>既然隔離見證可以提升區塊兩倍的交易量，那麼為什麼不直接提升區塊容量的限制到2MB就好？答案是可以的，只是路線的方法不同，然後支持直接擴容到2MB方案的派系輸了......</p>
<p>反對擴容方的意見則是認為目前Visa的交易吞吐量約為1700 TPS(<a href="https://hackernoon.com/the-blockchain-scalability-problem-the-race-for-visa-like-transaction-speed-5cce48f9d44">來源</a>)，如果要把目前Bitcoin大約7 TPS擴充到跟VISA類似規模的話需要讓區塊大小達到200-300MB之多，對於儲存或許不是困難，這在網路廣播區塊時會非常遲緩，因為挖礦的算力必須基於新區塊才能被視為有效算力，假設目前傳遞1MB區塊的資料到全網平均需要1秒，那傳遞250MB的區塊大小大約平均需要4分鐘，但在平均出塊時間只有10分鐘的情形下，大約40%的算力會被視為無效算力間接導致區塊鏈的安全風險，也因如此他們認為區塊大小不能無限制的膨脹，遲早得走其他的路。</p>
<h1 id="閃電網路lightning-network"><a class="header" href="#閃電網路lightning-network">閃電網路(Lightning Network)</a></h1>
<p>因為區塊鏈本身的特性，把交易上鏈的成本非常高、耗時也長，如果要把全部交易上鏈那麼勢必無法完成即時或是手續費低的要求，因此閃電網路提供的解決方案就是鏈下擴容─把微小的支付交易都移到鏈下，等到要結算時再統一上鏈，另外推行隔離驗證的其中一個目的是為了之後的閃電網路鋪路。</p>
<p>閃電網路的概念就是如果是小額、頻繁地消費的話那麼這些瑣碎的交易並不會送到鏈上，而是先到鏈上去開閃電支付的通道，接著到鏈下去把簽署過的交易資訊給對方，等到想要結算時在把所有交易都上鏈。</p>
<p>比方說你每天都會到家裡巷口的超商買東西，那麼為了避免每次小額支付都必須要支付高額的手續費與等待交易上鏈，那麼你可以跟便利超商開出一個鏈下支付通道，每次支付就相當於發出一個交易並簽發一個數位簽章給對方，等到想結算時再一起把這段時間所有的交易結果上鏈。</p>
<p>除此之外閃電網路還可以支援間接傳遞，比方說A&lt;-&gt;B、B&lt;-&gt;C之間各有一個閃電支付的通道，那麼即便A與C之間沒有任何通道，但A仍然可以透過抵押BTC的方式要求B利用自身的通道轉給C，也就是說只要你與別人建立了支付通道，那麼就可以如同網路一樣連結到對方所有可用的支付通道，而這些都是不需要支付任何手續費的！所以只要支付通道越多，閃電網路的威力與便利性就會進一步增強。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day27_2.jpg" alt="Lightning Network_ABC" /></p>
<p>你可以到<a href="https://graph.lndexplorer.com/">Lightning Network Visualizer</a>這個網站上看目前閃電網路的圖形化介面，只要你與上頭的任何一個節點開啟支付通道，那麼你便可以與節點上連接的所有閃電網路進行無延遲、無手續費的交易！</p>
<p><img src="https://www.lkm543.site/it_iron_man/day27_3.JPG" alt="Lightning Network" /></p>
<p>圖片擷取自: <a href="https://graph.lndexplorer.com/">Lightning Network Visualizer</a></p>
<p>在<a href="https://1ml.com/">這裡</a>你也可以看到閃電網路的支付通道數目，其中又以美國居多。</p>
<p>但閃電網路也有其缺點，為了確保所有人有足夠的資金進行最後的結算，在開啟閃電通道的同時你必須抵押相對應的資產(BTC)才能進行後續的交易，比方說你抵押了3BTC在通道的開啟上，那麼這3BTC在結算前都會被鎖死，而你最多也只能在鏈下的支付通道中支付3BTC，這有點像是你必須事先把悠遊卡儲值後才能夠進行後續的消費。</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-24"><a class="header" href="#ref-24">Ref:</a></h1>
<ul>
<li><a href="https://aaron67.cc/2018/12/29/bitcoin-transaction-p2ms-p2sh/">[学习笔记] “付款到多重签名” 和 “付款到脚本哈希”</a></li>
<li><a href="https://www.binance.vision/zt/security/what-is-a-multisig-wallet">什麼是多重簽名錢包？</a></li>
<li><a href="https://bitcoin.stackexchange.com/questions/14057/how-exactly-does-bip11-work-and-how-can-it-be-used-particularly-with-without-p">How exactly does BIP11 work, and how can it be used, particularly with/without P2SH?</a></li>
<li><a href="https://medium.com/@wilsonhuang/mastering-bitcoin-%E7%AD%86%E8%A8%98-standard-transactions-undone-bfb9b4ed0ed8">[Mastering Bitcoin 筆記] Standard Transactions</a></li>
<li><a href="https://github.com/bitcoinbook/bitcoinbook">Mastering Bitcoin</a></li>
<li><a href="https://www.blocktempo.com/understand-segwit-in3mins/">【三分鐘內就看懂】什麼是Segwit隔離見證？</a></li>
<li><a href="https://blockcast.it/2017/04/24/what-is-scalability-issue-and-segregated-witness/">不可不知 擴容與隔離見證（SegWit）</a></li>
<li><a href="https://medium.com/@jimmysong/understanding-segwit-block-size-fd901b87c9d4">Understanding Segwit Block Size</a></li>
<li><a href="https://www.blocktempo.com/lightning-network/">【動區專題】五分鐘就看懂：圖說閃電網路</a></li>
<li><a href="https://www.moneybar.com.tw/News/91864">什麼是閃電網路？白話版解釋「閃電網路原理」</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day27現實中的區塊鏈4用command-line操作bitcoin"><a class="header" href="#day27現實中的區塊鏈4用command-line操作bitcoin">Day27|現實中的區塊鏈(4)：用Command Line操作Bitcoin</a></h1>
<h1 id="操作bitcoin"><a class="header" href="#操作bitcoin">操作Bitcoin</a></h1>
<p>在提完Bitcoin的交易架構與幾個重要發展後，我們來實際體驗如何操作Bitcoin的匯款與收款。因為使用圖形化介面(GUI)相較容易，但卻不利於後續的二次開發、使用上也較不彈性，因此我們今天主要是講解如何直接使用Command Line來進行Bitcoin上的各式交易與匯款。</p>
<h1 id="圖形化介面"><a class="header" href="#圖形化介面">圖形化介面</a></h1>
<p>如果你沒有二次開發或是發送一些特殊交易的需求，那麼使用一般的圖形化介面(GUI)進行收款或匯款就可以了，至於要選擇使用何種程式，你可以到<a href="https://bitcoin.org/en/">bitcoin.org</a>根據你的要求選擇，選擇過程中(下圖)你也可以看到我們昨天講到的<code>多重簽名(Multisig)</code>或是<code>隔離見證(SegWit)</code>的功能，在這裡可以都勾起來，畢竟不確定之後何時會使用到。</p>
<p><img src="http://www.lkm543.site/it_iron_man/day28_1.JPG" alt="Multisig&amp;Segwit" /></p>
<p>圖片擷取自: <a href="https://bitcoin.org/en/">bitcoin.org</a></p>
<p>最後<a href="https://bitcoin.org/en/">bitcoin.org</a>推薦我用<a href="https://electrum.org/#download">electrum</a>這套軟體，下載安裝後打開，可以選擇想要開啟的錢包種類。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day28_2.JPG" alt="Wallet Tye" /></p>
<p>圖片擷取自: <a href="https://electrum.org">electrum</a></p>
<p>最後開完錢包就大功告成啦！下圖是它的介面，有收款與付款兩大功能可以選擇，裏頭還蠻清楚的，因此就不另外詳述如何使用了。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day28_3.JPG" alt="UI" /></p>
<p>圖片擷取自: <a href="https://electrum.org">electrum</a></p>
<h1 id="bitcoin-core"><a class="header" href="#bitcoin-core">Bitcoin-core</a></h1>
<p>我們今天主要的重點是<code>Bitcoin-core</code>的安裝與使用，<code>Bitcoin-core</code>是Bitcoin目前最主流與廣泛使用的主程式，裏頭包含了bitcoind、bitcoin-qt與bitcoin-cli三隻程式，先就這三個做簡單介紹。</p>
<ul>
<li>
<p>bitcoind<br />
<code>bitcoind</code>的字尾d可以看作是develop的縮寫，這隻城市的特色就是可以透過<a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">RPC</a>呼叫裏頭的子程式，可以把它看作是client-server架構下的server，所以特別適合用來做比特幣相關服務的二次開發或營運。跟我們之前寫的簡易區塊鏈比較，就是節點端的程式，功能也是負責接收外界的請求。</p>
</li>
<li>
<p>bitcoin-qt<br />
<code>bitcoin-qt</code>的特色就是提供了圖形化前端介面(下圖)，讓一般非程式開發者也可以很容易地使用。</p>
</li>
</ul>
<p><img src="https://en.bitcoinwiki.org/upload/en/images/6/62/Bitcoin-qt.png" alt="bitcoin-qt" /></p>
<p>圖片來源: <a href="https://en.bitcoinwiki.org/wiki/Bitcoin-Qt">Wikipedia</a></p>
<ul>
<li>bitcoin-cli<br />
<code>bitcoin-cli</code>的字尾cli是client客戶端的縮寫，它允許你直接發送<a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">RPC</a>給bitcoind，可以把它看作是client-server架構下的client，可以讓你在沒有營運一個完整節點的情形下仍然可以向其他節點發出交易或查詢的請求。跟我們之前寫的簡易區塊鏈比較，就是客戶端的程式，功能是向節點發出查詢餘額或是交易請求。</li>
</ul>
<h2 id="環境設定"><a class="header" href="#環境設定">環境設定</a></h2>
<p>我測試的環境是在win10下開一個Ubuntu的子系統，如果你也想在win10下測試的話可以參考<a href="https://zhuanlan.zhihu.com/p/62658094">這裡</a>進行安裝。安裝後你就你可以到<a href="https://bitcoin.org/en/download">bitcoin.org</a>找最新版本的Bitcoin-core來下載，你可以先開個資料夾後再下載並且展開。</p>
<pre><code>mkdir bitcoin
wget https://bitcoin.org/bin/bitcoin-core-0.18.1/bitcoin-0.18.1-x86_64-linux-gnu.tar.gz
tar xf bitcoin-0.18.1-x86_64-linux-gnu.tar.gz
</code></pre>
<p>安裝完後記得把bin資料夾放入環境變數(PATH)中，因為我安裝在d槽下，所以我的路徑是<code>/mnt/d/bitcoin/bitcoin-0.18.1/bin/</code></p>
<pre><code>export PATH=$PATH:/mnt/d/bitcoin/bitcoin-0.18.1/bin/
</code></pre>
<p>在Linux系統下，上面三隻程式的設定值都會在下面這個檔案中</p>
<blockquote>
<p>$HOME/.bitcoin/bitcoin.conf</p>
</blockquote>
<p>以nano打開後</p>
<pre><code>nano $HOME/.bitcoin/bitcoin.conf
</code></pre>
<p>可以在裏頭設定RPC用的密碼，但我們之後的測試是在模擬環境下測試，所以不設定也沒關係</p>
<pre><code>rpcpassword=YOUR_PASSWORD
</code></pre>
<p>在這裡另外說明一下，測試的方式有兩種：<code>Testnet</code>或<code>Regtest</code>，Testnet是連上比特幣的測試網路，也就是外網；而Regtest則是在本機端開啟一個完全私人的環境來做測試，目前主流的開發都是用Regtest了，因此我們之後的示範也會使用Regtest，但如果想要用testnet的話就在<code>$HOME/.bitcoin/bitcoin.conf</code>裏頭新增這一行就可以了。</p>
<pre><code>testnet=1
</code></pre>
<p>另外修改權限只有我們能夠讀寫這個檔案</p>
<pre><code>chmod 600 bitcoin.conf
</code></pre>
<p>到此就設定完畢了！</p>
<h2 id="啟動與停止"><a class="header" href="#啟動與停止">啟動與停止</a></h2>
<p>在開始使用前先把bitcoind打開(如果使用testnet則不需要加-regtest)</p>
<pre><code>bitcoind -regtest -daemon
</code></pre>
<p>接著你就會看到下面這行字，代表成功開啟了</p>
<pre><code>Bitcoin server starting
</code></pre>
<p>要停止也很容易，下stop指令便行了。</p>
<pre><code>bitcoin-cli stop
</code></pre>
<p>成功結束你會看到</p>
<pre><code>Bitcoin server stopping
</code></pre>
<h2 id="挖掘新區塊-1"><a class="header" href="#挖掘新區塊-1">挖掘新區塊</a></h2>
<p>創建新錢包的方式是透過<code>getnewaddress</code>指令</p>
<pre><code>bitcoin-cli -regtest getnewaddress
</code></pre>
<p>因為regtest模式下block需要經過100個確認後才能夠花用裏頭的餘額，所以我們可以用<code>generatetoaddress</code>使產出的地址挖掘101個區塊，確保我們有50BTC可以用於後續的交易。</p>
<pre><code>bitcoin-cli -regtest generatetoaddress 101 $(bitcoin-cli -regtest getnewaddress)
</code></pre>
<p>挖掘出來後你就可以利用<code>getbalance</code>查詢目前可支用的餘額</p>
<pre><code>bitcoin-cli -regtest getbalance
</code></pre>
<p>就會發現裏頭有50元可以使用了！</p>
<pre><code>50.00000000
</code></pre>
<h2 id="發起交易-1"><a class="header" href="#發起交易-1">發起交易</a></h2>
<p>發起交易前我們先創建一個新的收款錢包</p>
<pre><code>bitcoin-cli -regtest getnewaddress
</code></pre>
<blockquote>
<p>2N1yF65i3KfXHJ7Pv6oxBeGoUSnGK2idzuQ</p>
</blockquote>
<p>接著就可以利用<code>sendtoaddress</code>匯款給對方了</p>
<pre><code>bitcoin-cli -regtest sendtoaddress 2N1yF65i3KfXHJ7Pv6oxBeGoUSnGK2idzuQ 5.00
</code></pre>
<p>匯款完後看到的這一連串Bytes便是我們的Transaction id!</p>
<pre><code>7862877e89f9b2e14c42e508f31646c68f38d99e404c335769ad1092c9b33822
</code></pre>
<p>交易完之後記得再挖掘出一個新區塊，我們的交易才會被打包進去喔</p>
<pre><code>bitcoin-cli -regtest generatetoaddress 1 $(bitcoin-cli -regtest getnewaddress)
</code></pre>
<h2 id="手動簽發一筆交易"><a class="header" href="#手動簽發一筆交易">手動簽發一筆交易</a></h2>
<p>上面的交易其實省略了相當多步驟，也沒有逐步的簽署，所以我們來試試怎麼一步步從初始化交易到使用私鑰來簽發這比交易！但如果手動簽發出錯的話，手上的BTC可能會永久遺失，所以使用上請務必小心。</p>
<h3 id="查詢utxo"><a class="header" href="#查詢utxo">查詢UTXO</a></h3>
<p>輸入<code>listunspent</code>指令就可以查詢目前還沒被使用的UTXO。</p>
<pre><code>bitcoin-cli -regtest listunspent
</code></pre>
<p><img src="http://www.lkm543.site/it_iron_man/day28_4.JPG" alt="UTXO" /></p>
<h3 id="初始化一筆交易"><a class="header" href="#初始化一筆交易">初始化一筆交易</a></h3>
<p>假設我們現在想要動用3ab2be755f676c9978c6a3bf42f87cfcb8f7393d10cf5c962a1590e3449c38d4這筆UTXO，那麼我們可以先設定：</p>
<blockquote>
<p>UTXO_ID=3ab2be755f676c9978c6a3bf42f87cfcb8f7393d10cf5c962a1590e3449c38d4<br />
UTXO_VOUT=0</p>
</blockquote>
<p>接著我們利用<code>createrawtransaction</code>來初始化一筆交易，txid指我們想動用的UTXO編號，vout可以想成這筆UTXO的次序(可以在UTXO列表中找到這個值)。第二個JSON則是收款地址以及收款金額，注意收款金額與UTXO餘額的差就是手續費，兩者的差距必須小於0.1否則便會報錯。</p>
<pre><code>bitcoin-cli -regtest createrawtransaction '''
    [
      {
        "txid": "'$UTXO_ID'",
        "vout": '$UTXO_VOUT'
      }
    ] 
    ''' '''
    {
      "2MyFEzBFSYb5PimVKGmeehY9MrxHJQrhGZF": 44.998
    }
    '''
</code></pre>
<p>接著就可以得到這筆交易的編碼後的資料了！</p>
<pre><code>0200000001d4389c44e390152a965ccf103d39f7b8fc7cf842bfa3c678996c675f75beb23a0000000000ffffffff01c07f350c0100000017a91441d196828171b72dd14bf48378b5659bfde9e6ab8700000000
</code></pre>
<p>你可以用<code>decoderawtransaction</code>指令來看原本的交易內容</p>
<pre><code>bitcoin-cli -regtest decoderawtransaction 0200000001d4389c44e390152a965ccf103d39f7b8fc7cf842bfa3c678996c675f75beb23a0000000000ffffffff01c07f350c0100000017a91441d196828171b72dd14bf48378b5659bfde9e6ab8700000000
</code></pre>
<p><img src="http://www.lkm543.site/it_iron_man/day28_5.JPG" alt="UTXO" /></p>
<h3 id="簽署這筆交易"><a class="header" href="#簽署這筆交易">簽署這筆交易</a></h3>
<p>用<code>signrawtransactionwithwallet</code>指令來簽署這筆交易</p>
<pre><code>bitcoin-cli -regtest signrawtransactionwithwallet 0200000001d4389c44e390152a965ccf103d39f7b8fc7cf842bfa3c678996c675f75beb23a0000000000ffffffff01c07f350c0100000017a91441d196828171b72dd14bf48378b5659bfde9e6ab8700000000
</code></pre>
<p>可以得到下面的回應，其中hex裏頭就是我的數位簽章了！你也可以發現它比交易的資料長非常多，這也是我們昨天有提到數位簽章的資料通常會佔到整體資料大小的2/3以上。</p>
<pre><code>{
  "hex": "02000000000101d4389c44e390152a965ccf103d39f7b8fc7cf842bfa3c678996c675f75beb23a0000000017160014d3c8facb4eb70ba6b14992951c1bb7260a759118ffffffff01c07f350c0100000017a91441d196828171b72dd14bf48378b5659bfde9e6ab870247304402204031dd9a2c8e78d4c41e8e758d2c33518f75012551793d086213f74edebe8efa0220161919fc3743dcbdfabf1f2ea44464bd59437cec2c225c0e27685e2d8cc4245b012103518af844b06091b5bed9ee5cf50ea372af8a1425afba9142a71d27b5ee38642a00000000",
  "complete": true
}
</code></pre>
<p>把數位簽章儲存成變數</p>
<blockquote>
<p>SIGNATURE=02000000000101d4389c44e390152a965ccf103d39f7b8fc7cf842bfa3c678996c675f75beb23a0000000017160014d3c8facb4eb70ba6b14992951c1bb7260a759118ffffffff01c07f350c0100000017a91441d196828171b72dd14bf48378b5659bfde9e6ab870247304402204031dd9a2c8e78d4c41e8e758d2c33518f75012551793d086213f74edebe8efa0220161919fc3743dcbdfabf1f2ea44464bd59437cec2c225c0e27685e2d8cc4245b012103518af844b06091b5bed9ee5cf50ea372af8a1425afba9142a71d27b5ee38642a00000000</p>
</blockquote>
<p>最後就可以利用<code>sendrawtransaction</code>指令與我們剛剛簽發的數位簽章、想要動用的UTXO來交易了！</p>
<pre><code>bitcoin-cli -regtest sendrawtransaction $SIGNATURE
</code></pre>
<p>你就可以得到一筆Transaction ID了</p>
<blockquote>
<p>1089bff77424764ffadfaac6f12683b1c2265ebe0726598ee0cb28cf02dd017a</p>
</blockquote>
<p>一樣挖掘新區塊後，就可以查詢有沒有新的UTXO生成</p>
<pre><code>bitcoin-cli -regtest generatetoaddress 1 $(bitcoin-cli -regtest getnewaddress)
bitcoin-cli -regtest listunspent
</code></pre>
<p>新生成的UTXO結果如下</p>
<pre><code> {
    "txid": "1089bff77424764ffadfaac6f12683b1c2265ebe0726598ee0cb28cf02dd017a",
    "vout": 0,
    "address": "2MyFEzBFSYb5PimVKGmeehY9MrxHJQrhGZF",
    "label": "",
    "redeemScript": "0014eac13ffacbced6b25fe7262ff14d8c4ffcf6b229",
    "scriptPubKey": "a91441d196828171b72dd14bf48378b5659bfde9e6ab87",
    "amount": 44.99800000,
    "confirmations": 1,
    "spendable": true,
    "solvable": true,
    "desc": "sh(wpkh([e6960773/0'/0'/2']038906fb9fb8259c15978872e186bc21897f4b51c01834f90ad53ed3056f44a328))#02k7gp80",
    "safe": true
  }
</code></pre>
<h2 id="多重簽名-1"><a class="header" href="#多重簽名-1">多重簽名</a></h2>
<h3 id="創設多重簽名的付款帳號"><a class="header" href="#創設多重簽名的付款帳號">創設多重簽名的付款帳號</a></h3>
<p>多重簽名的交易方法跟上面很類似，假設我們要創建一個2 of 3多重簽名的支付，利用<code>addmultisigaddress</code>指令：</p>
<pre><code>bitcoin-cli -regtest addmultisigaddress 2 "
    [\"2MwgVmbPVRF9a44ar9AUB7sCHCrdDf81oxL\",
     \"2MwgVmbPVRF9a44ar9AUB7sCHCrdDf81oxL\", 
     \"2N1yF65i3KfXHJ7Pv6oxBeGoUSnGK2idzuQ\"
    ]
    "
</code></pre>
<p>就可以得到P2SH的新多重簽名收款地址了：</p>
<pre><code>{
  "address": "2MxKFjxNftmEnCJE2tmTktwVJKUqMAPQ1K3",
  "redeemScript": "522103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc92103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc921036874be266591da071920e700514ddc4571c67f465787888d4f16b1ce06e2decd53ae"
}
</code></pre>
<p>要付款給多重簽名的地址也只要把它當一般地址便可以了。</p>
<blockquote>
<p>bitcoin-cli -regtest sendtoaddress 2MxKFjxNftmEnCJE2tmTktwVJKUqMAPQ1K3 10.00</p>
</blockquote>
<h3 id="動用多重簽名的資金"><a class="header" href="#動用多重簽名的資金">動用多重簽名的資金</a></h3>
<p>首先一樣先利用下面這個指令把我們想要花用的UTXO編號找出來：</p>
<blockquote>
<p>bitcoin-cli -regtest listunspent</p>
</blockquote>
<pre><code>{
    "txid": "241bb7af4262e475ee2bff4586a3b1c0b4a2f9efb8cb0901f5e16d7794451b83",
    "vout": 0,
    "address": "2MxKFjxNftmEnCJE2tmTktwVJKUqMAPQ1K3",
    "label": "",
    "redeemScript": "0020809d97cffc439727dd9fd38548c0e9c5a576e90f9ef11d99ef15635516453bcc",
    "witnessScript": "522103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc92103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc921036874be266591da071920e700514ddc4571c67f465787888d4f16b1ce06e2decd53ae",
    "scriptPubKey": "a914379bc18d46b35fed27f75c1128a8f36659615d5e87",
    "amount": 10.00000000,
    "confirmations": 1,
    "spendable": true,
    "solvable": true,
    "desc": "sh(wsh(multi(2,[e6960773/0'/0'/0']03ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc9,[e6960773/0'/0'/0']03ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc9,[e6960773/0'/0'/1']036874be266591da071920e700514ddc4571c67f465787888d4f16b1ce06e2decd)))#ys6kgphk",
    "safe": true
  }
</code></pre>
<p>一樣先初始化交易，假設我們要把裏頭的資金移轉到2NFZxvqDfa9EKvw7bMaBpRkAUfJZKUVCiKV</p>
<pre><code>bitcoin-cli -regtest createrawtransaction '''
[
  {
    "txid": "241bb7af4262e475ee2bff4586a3b1c0b4a2f9efb8cb0901f5e16d7794451b83",
    "vout": 0
  }
]
''' '''
{
 "2NFZxvqDfa9EKvw7bMaBpRkAUfJZKUVCiKV": 9.998
}'''
</code></pre>
<blockquote>
<p>RAW_TX=0200000001831b4594776de1f50109cbb8eff9a2b4c0b1a38645ff2bee75e46242afb71b240000000000ffffffff01c0bc973b0000000017a914f4de1976c0e707fadff4a908f271d7091032268a8700000000</p>
</blockquote>
<p>接著利用<code>dumpprivkey</code>把其中兩個私鑰取出，因為是2 of 3多重簽名，所以至少要經過兩個私鑰的簽署</p>
<pre><code>bitcoin-cli -regtest dumpprivkey 2MwgVmbPVRF9a44ar9AUB7sCHCrdDf81oxL
bitcoin-cli -regtest dumpprivkey 2N1yF65i3KfXHJ7Pv6oxBeGoUSnGK2idzuQ
</code></pre>
<p>得到兩把私鑰</p>
<blockquote>
<p>cVaV7TWQodB8DhhMe4fiNtfV9paFpBmupQsbyWnwdBhN15EUhW9P<br />
cN3gCnSnyENguQQ49zyQ4SPrucTrCHVapvqq5qaYKVueSmTGpCoZ</p>
</blockquote>
<p>接著先用第一把私鑰利用<code>signrawtransactionwithkey</code>簽署，並填入相對應的txid、vout、scriptPubKey、redeemScript、amount</p>
<pre><code>bitcoin-cli -regtest signrawtransactionwithkey $RAW_TX '''
    [
      "cVaV7TWQodB8DhhMe4fiNtfV9paFpBmupQsbyWnwdBhN15EUhW9P"
    ]''' ''' 
    [
      {
        "txid": "241bb7af4262e475ee2bff4586a3b1c0b4a2f9efb8cb0901f5e16d7794451b83",
        "vout": 0,
        "redeemScript": "0020809d97cffc439727dd9fd38548c0e9c5a576e90f9ef11d99ef15635516453bcc",
        "witnessScript": "522103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc92103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc921036874be266591da071920e700514ddc4571c67f465787888d4f16b1ce06e2decd53ae",
        "scriptPubKey": "a914379bc18d46b35fed27f75c1128a8f36659615d5e87",        
        "amount": 10.00000000
      }
    ]
    '''
</code></pre>
<p>就可以得到以第一把私鑰簽過的數位簽章</p>
<pre><code>{
  "hex": "02000000000101831b4594776de1f50109cbb8eff9a2b4c0b1a38645ff2bee75e46242afb71b240000000023220020809d97cffc439727dd9fd38548c0e9c5a576e90f9ef11d99ef15635516453bccffffffff01c0bc973b0000000017a914f4de1976c0e707fadff4a908f271d7091032268a870400473044022047587f7a10c0f2107fa88bedb5268fbcbc6406d1cd14ae11dc90bed57dd5a849022070f6654daee33ee65e088754c54d301cf062f8fb434053617db82b6f3b42d5a301473044022047587f7a10c0f2107fa88bedb5268fbcbc6406d1cd14ae11dc90bed57dd5a849022070f6654daee33ee65e088754c54d301cf062f8fb434053617db82b6f3b42d5a30169522103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc92103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc921036874be266591da071920e700514ddc4571c67f465787888d4f16b1ce06e2decd53ae00000000",
  "complete": true
}
</code></pre>
<blockquote>
<p>FIRST_SIGNATURE=02000000000101831b4594776de1f50109cbb8eff9a2b4c0b1a38645ff2bee75e46242afb71b240000000023220020809d97cffc439727dd9fd38548c0e9c5a576e90f9ef11d99ef15635516453bccffffffff01c0bc973b0000000017a914f4de1976c0e707fadff4a908f271d7091032268a870400473044022047587f7a10c0f2107fa88bedb5268fbcbc6406d1cd14ae11dc90bed57dd5a849022070f6654daee33ee65e088754c54d301cf062f8fb434053617db82b6f3b42d5a301473044022047587f7a10c0f2107fa88bedb5268fbcbc6406d1cd14ae11dc90bed57dd5a849022070f6654daee33ee65e088754c54d301cf062f8fb434053617db82b6f3b42d5a30169522103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc92103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc921036874be266591da071920e700514ddc4571c67f465787888d4f16b1ce06e2decd53ae00000000</p>
</blockquote>
<p>接著拿來簽章第二把</p>
<pre><code>bitcoin-cli -regtest signrawtransactionwithkey $FIRST_SIGNATURE '''
    [
      "cN3gCnSnyENguQQ49zyQ4SPrucTrCHVapvqq5qaYKVueSmTGpCoZ"
    ]''' ''' 
    [
      {
        "txid": "241bb7af4262e475ee2bff4586a3b1c0b4a2f9efb8cb0901f5e16d7794451b83",
        "vout": 0,
        "redeemScript": "0020809d97cffc439727dd9fd38548c0e9c5a576e90f9ef11d99ef15635516453bcc",
        "witnessScript": "522103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc92103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc921036874be266591da071920e700514ddc4571c67f465787888d4f16b1ce06e2decd53ae",
        "scriptPubKey": "a914379bc18d46b35fed27f75c1128a8f36659615d5e87",        
        "amount": 10.00000000
      }
    ]
    '''
</code></pre>
<p>得到最後簽署的結果了！</p>
<pre><code>{
  "hex": "02000000000101831b4594776de1f50109cbb8eff9a2b4c0b1a38645ff2bee75e46242afb71b240000000023220020809d97cffc439727dd9fd38548c0e9c5a576e90f9ef11d99ef15635516453bccffffffff01c0bc973b0000000017a914f4de1976c0e707fadff4a908f271d7091032268a870400473044022047587f7a10c0f2107fa88bedb5268fbcbc6406d1cd14ae11dc90bed57dd5a849022070f6654daee33ee65e088754c54d301cf062f8fb434053617db82b6f3b42d5a301473044022047587f7a10c0f2107fa88bedb5268fbcbc6406d1cd14ae11dc90bed57dd5a849022070f6654daee33ee65e088754c54d301cf062f8fb434053617db82b6f3b42d5a30169522103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc92103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc921036874be266591da071920e700514ddc4571c67f465787888d4f16b1ce06e2decd53ae00000000",
  "complete": true
}
</code></pre>
<p>把最後的結果用<code>sendrawtransaction</code>發送出去，便可以移動資產了！</p>
<blockquote>
<p>bitcoin-cli -regtest sendrawtransaction 02000000000101831b4594776de1f50109cbb8eff9a2b4c0b1a38645ff2bee75e46242afb71b240000000023220020809d97cffc439727dd9fd38548c0e9c5a576e90f9ef11d99ef15635516453bccffffffff01c0bc973b0000000017a914f4de1976c0e707fadff4a908f271d7091032268a870400473044022047587f7a10c0f2107fa88bedb5268fbcbc6406d1cd14ae11dc90bed57dd5a849022070f6654daee33ee65e088754c54d301cf062f8fb434053617db82b6f3b42d5a301473044022047587f7a10c0f2107fa88bedb5268fbcbc6406d1cd14ae11dc90bed57dd5a849022070f6654daee33ee65e088754c54d301cf062f8fb434053617db82b6f3b42d5a30169522103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc92103ad88fdadd957df816e167d6598aad34f4b82cdc537b820b75fbe03e8e48c5cc921036874be266591da071920e700514ddc4571c67f465787888d4f16b1ce06e2decd53ae00000000</p>
</blockquote>
<p>一樣交易後會得到一個交易id</p>
<blockquote>
<p>fd06828e8443aaa3e587e870c78752184a9a3712560c2fc666e3882778c825a0</p>
</blockquote>
<p>這樣一來就完成多重簽名了，而且簽名的過程中可以分別在不同的本機簽署以避免私鑰外流的資安疑慮！另外一提，<a href="https://bitcoin.org/en/developer-examples#testing-applications">bitcoin.org</a>裏頭的教學很多都是舊版的，如果用最新版(0.18.1)的話要注意一下寫法是不同的(踩了不少坑QQ)。</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-25"><a class="header" href="#ref-25">Ref:</a></h1>
<ul>
<li><a href="https://github.com/ChristopherA/Learning-Bitcoin-from-the-Command-Line">Learning-Bitcoin-from-the-Command-Line</a></li>
<li><a href="https://blog.csdn.net/a013152/article/details/81668629">比特币bitcoin-cli转账与交易的api使用总结</a></li>
<li><a href="https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_calls_list">Original Bitcoin client/API calls list</a></li>
<li><a href="https://blog.51cto.com/11975865/2384841">bitcoin全节点部署及bitcoind bitcoin-cli命令使用解释</a></li>
<li><a href="https://bitcoin.org/en/developer-examples#testing-applications">Bitcoin Developer Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day28現實中的區塊鏈5ethereum的evm與智能合約"><a class="header" href="#day28現實中的區塊鏈5ethereum的evm與智能合約">Day28|現實中的區塊鏈(5)：Ethereum的EVM與智能合約</a></h1>
<h1 id="ethereum"><a class="header" href="#ethereum">Ethereum</a></h1>
<p>在經過昨天的操作之後，應該也可以發現Bitcoin的使用相對簡單，主要都是圍繞在金流的交易與驗證上，而今天與明天要來解說的Ethereum則著重在智能合約的實作上，但因為篇幅有限，所以主要重點會放置在合約的運行方式與架構上。</p>
<h2 id="圖靈完備性"><a class="header" href="#圖靈完備性">圖靈完備性</a></h2>
<p>Ethereum與Bitcoin最大的不同就是具備了<code>圖靈完備性</code>，在提到圖靈完備性之前就必須先提到圖靈機─圖靈機簡單而言可以看作是一個依據幾個簡單、基本的指令來執行工作的機器，理想上的圖靈機具有無限大的儲存空間與運算能力，所有計算上的工作都可以被這台圖靈機解決。如果你有學習過<a href="https://zh.wikipedia.org/zh-tw/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">組合語言</a>的話，那麼這些簡單指令集你就可以把它視做組合語言。</p>
<p><img src="http://b.blog.xuite.net/b/b/5/2/11519069/blog_33884/txt/32646708/6.jpg" alt="Turing Machine" /></p>
<p>圖片來源: <a href="https://blog.xuite.net/wellsli/002/32646708-%E8%A8%88%E7%AE%97%E6%A9%9F%E7%90%86%E8%AB%96%E7%9A%84%E5%A7%8B%E7%A5%96---%E5%9C%96%E9%9D%88%E6%A9%9F">計算機理論的始祖---圖靈機</a></p>
<p>因此圖靈完備性指的是如果我們可以將所有可計算的問題丟給機器去解決，那麼這台機器就稱為有圖靈完備性。而Ethereum則是具有圖靈完備性的區塊鏈，如果把Ethereum想像成一台電腦，那麼你可以把所有想要解決的問題都丟上Ethereum去執行與求解。</p>
<h2 id="ethereum-virtual-machineevm"><a class="header" href="#ethereum-virtual-machineevm">Ethereum Virtual Machine(EVM)</a></h2>
<p>但為了確保區塊鏈上的各個節點能夠對同樣一段程式碼產出同樣的結果，所以Ethereum的程式碼中也內建了可以用來執行指令的<code>Ethereum Virtual Machine(EVM)</code>，這裡的EVM具有圖靈完備性，理論上你可以把任何計算上的問題通通丟給EVM去解決，並且由於區塊鏈不可竄改的特性，在執行結果上也是可靠的，所有人都得依據同樣的邏輯或原則來做事，執行完的結果也會被送入區塊鏈永久儲存。至於EVM裏頭有哪些指令可以使用你可以參考下圖。</p>
<p><img src="images/day28_49840.png" alt="EVM" /></p>
<p>圖片來源: <a href="https://medium.com/mycrypto/the-ethereum-virtual-machine-how-does-it-work-9abac2b7c9e">Medium</a></p>
<p>EVM的另一個好處是提供了一個像是<a href="https://zh.wikipedia.org/zh-tw/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8)">沙盒(Sandbox)</a>的環境，意旨所有在沙盒裏頭執行的指令都會像監牢一樣被隔離開來無法影響到外界區塊鏈的運作，這保障了在區塊鏈上執行程式碼時的安全性。</p>
<p>雖然說EVM具備了圖靈完備性，但因為區塊鏈的特性讓世界上所有人共用一個電腦，會導致每個人能夠使用到的運算量十分有限，實務上使用通常不會拿來計算複雜的數學問題，而是僅作基本的四則或邏輯運算。為了控管每個人能夠用的運算量，EVM導入了Gas機制來透過自由經濟的方式來限制使用。</p>
<p>對於EVM的架構有興趣深入探討的話，<a href="https://fullstacks.org/materials/ethereumbook/14_evm.html">這裡</a>是一個很好的參考來源。</p>
<h2 id="ethereum的gas機制"><a class="header" href="#ethereum的gas機制">Ethereum的Gas機制</a></h2>
<p>區塊鏈上的運算資源與空間都是寶貴了，為了避免一般使用者濫用，Ethereum使用<code>Gas</code>機制來限制每個區塊內所能允許的運算量與手續費多寡。Gas的由來就跟名字一樣，與加油雷同，所以等等在舉例上就會以加油站為例。</p>
<p><img src="https://www.insuredasap.com/wp-content/uploads/sites/77/2017/12/gas-station-insurance-chicago-illinois.jpg" alt="Gas station" /></p>
<p>圖片來源: <a href="https://www.insuredasap.com/business/auto-service-dealerships/gas-station-insurance-get-quote/">insuredasap</a></p>
<p>在講Gas之前我們先來介紹ETH的計量單位：</p>
<blockquote>
<p>1 Ether = 1,000,000,000,000,000,000 Wei (10^18)<br />
1 Gwei = 1,000,000,000 Wei (10^9)</p>
</blockquote>
<p>在Gas機制下有三個主要名詞：Gas、Gas Price、Gas Limit：</p>
<ul>
<li>Gas<br />
Gas相當於汽油幾公升，在EVM的執行過程中每一個指令都需要耗費相對應的Gas，越複雜的邏輯需要花費的Gas也就越多。</li>
<li>Gas Price<br />
Gas Price意思就是你願意為每個Gas付出多少錢，單位是Gwei。</li>
<li>Gas Limit<br />
Gas Limit是你願意為這筆交易最多購買多少Gas，會有Gas Limit的限制是因為在智能合約真正被執行前，沒有人會知道執行過程中究竟會耗去多少Gas作為運算用，所以Gas Limit的限制就是為了讓每次執行的智能合約都有手續費的上限。</li>
</ul>
<p>以台北開車到高雄為例，Gas Price便是你願意為每公升的汽油付出多少費用、Gas Limit就是你願意為這趟旅程最多花幾公升的汽油，因此這一趟旅程的花費(手續費)上限就是。</p>
<blockquote>
<p>手續費上限 = Gas Limit * Gas Price</p>
</blockquote>
<p>但這只是手續費上限，沒有用到的Gas是可以退還的，所以這趟旅程真正要繳納的手續費是：</p>
<blockquote>
<p>手續費 = Gas Used * Gas Price</p>
</blockquote>
<p>但如果手續費不足導致旅途(交易)失敗，那麼已花去的手續費是不會退還的，畢竟礦工已經嘗試幫你執行怎可讓人白做工！</p>
<p>至於怎麼樣判別每個步驟的手續費多寡呢？在<a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum的黃皮書</a>(下圖)裡，其實就有定義了每個步驟所需要耗去的Gas數目，比方說大家最常用的交易所需要耗費的Gas為21000個。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day29_1.JPG" alt="Gas" /></p>
<p>圖片來源: <a href="https://ethereum.github.io/yellowpaper/paper.pdf">insuredasap</a></p>
<p>實際上Ethereum規定了每個區塊的Gas上限是<code>800萬Gas</code>，就相當於打包每個區塊的礦工都有800萬Gas可供販售，至於販售給誰就完全根據誰出的Gas Price較高來決定，與Gas Limit毫無關係。就好比每個加油站(新區塊)都有800萬公升(Gas)可供販售，要優先販售給誰就由大家願意出的單價(Gas Price)來決定，所以出的Gas Price越高，你的交易就能夠越快被打包進入區塊。</p>
<p>至於如何決定現在應該要出多少Gas Price?</p>
<p>在<a href="https://ethgasstation.info/">ethgasstation</a>中你可以查閱到目前多少的Gas Price可以在多久內被打包:</p>
<p><img src="https://www.lkm543.site/it_iron_man/day29_2.JPG" alt="Gas" /></p>
<p>圖片來源: <a href="https://ethgasstation.info/">ethgasstation</a></p>
<p>比方說這筆交易有點急，你想要在2分鐘內被打包的話，那麼建議你出的Gas Price便是8 Gwei/Gas，至於你實際會支出的手續費多寡以現在約ETH市價約185 USD來計算便是:</p>
<blockquote>
<p>手續費 = 21000 Gas * 8 Gwei/Gas * 10^(-9) * 185(USD/ETH) ~ 0.031 USD</p>
</blockquote>
<p>上圖的0.031 USD就是這樣被計算出來的！</p>
<h2 id="智能合約smart-contract"><a class="header" href="#智能合約smart-contract">智能合約(Smart Contract)</a></h2>
<p><code>智能合約</code>通常指的是之後在EVM裡被執行的程式碼，一個常見智能合約的比喻是自動販賣機：定義了你按下甚麼按鈕、投了多少錢後發生甚麼結果，這些邏輯都可以寫成智能合約後送上Ethereum。另一個例子是資產轉移的智能合約(<a href="https://blockgeeks.com/guides/different-smart-contract-platforms/">來源</a>)，我們可以讓智能合約在收到足夠的款項之後自動轉移不動產的產權。</p>
<p><img src="https://blockgeeks.com/wp-content/uploads/2018/05/image7.png" alt="Smart contract" /></p>
<p>圖片來源: <a href="https://blockgeeks.com/guides/different-smart-contract-platforms/">blockgeeks</a></p>
<p>在智能合約送上Ethereum前都會先被編譯成Bytecode，常見的Bytecode列表你可以在<a href="https://ethervm.io/#opcodes">ethervm</a>看到所有的opcode。你也可以嘗試直接使用<a href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-23smart-contract-%E5%88%9D%E6%8E%A2%E5%BE%9E-bytecode-%E5%88%B0-solidity/">Bytecode</a>來撰寫智能合約。</p>
<p>至於實際執行智能合約會需要耗費多少Gas? 你可以在<a href="https://docs.google.com/spreadsheets/d/1n6mRqkBz3iWcOlRem_mO09GtSKEKrAsfO7Frgx18pNU/edit#gid=0">這裡</a>查詢到在智能合約編譯成Bytecode後執行每一單一指令所需要耗費的Gas數目，下表是一些簡單指令所需要耗費的Gas數目(<a href="https://ethereum.stackexchange.com/questions/72211/setting-array-in-solidity/72225">來源</a>)，如果智能合約牽涉到的運算越複雜、查詢的資料越多，那麼需要花費的Gas數目也越多。比方說加減指令只需要3 Gas便可以完成，但是查詢Account的餘額需要400 Gas，而開創一個新的Account甚至需要花費32000個Gas！</p>
<pre><code>Operation         Gas           Description
ADD/SUB           3             Arithmetic operation
MUL/DIV           5             Arithmetic operation
ADDMOD/MULMOD     8             Arithmetic operation
AND/OR/XOR        3             Bitwise logic operation
LT/GT/SLT/SGT/EQ  3             Comparison operation
POP               2             Stack operation 
PUSH/DUP/SWAP     3             Stack operation
MLOAD/MSTORE      3             Memory operation
JUMP              8             Unconditional jump
JUMPI             10            Conditional jump
SLOAD             200           Storage operation
SSTORE            5,000/20,000  Storage operation
BALANCE           400           Get balance of an account
CREATE            32,000        Create a new account using CREATE
CALL              25,000        Create a new account using CALL
</code></pre>
<h2 id="decentralized-applicationdapp"><a class="header" href="#decentralized-applicationdapp">Decentralized Application(DAPP)</a></h2>
<p><code>Decentralized Application(DAPP)</code>指的是智能合約與前端集合在一起供使用者使用的APP，相較於一般APP有中心化的Server與營運方負責維護，DAPP的使用與運算通常是由智能合約負責，主要的資料也是從區塊鏈中所取得，也因此日後的使用與營運一般都交由礦工來負責執行，除非有寫特定的後門，否則沒有人可以上去竄改資料或合約執行的結果，使用者一般使用Ethereum的錢包便可以參與互動。</p>
<p><img src="images/day28_29244.png" alt="DAPP" /></p>
<p>圖片來源: <a href="https://towardsdatascience.com/what-is-a-dapp-a455ac5f7def">What is a DAPP?</a></p>
<p>雖然DAPP相較一般APP容易讓人信賴，但區塊鏈本身有令人詬病的兩大缺陷：</p>
<ul>
<li>無法即時交易、每次指令都需要耗去手續費</li>
<li>UX體驗不良</li>
</ul>
<p>無法即時交易是因為需要等待礦工打包上鏈後才能確保指令的確進入區塊鏈，但即便是平均出塊時間只有15秒的Ethereum，每次下完指令後平均也要等待1~2分鐘才能夠知道指令的執行結果，並且每次指令都需要花去相對應的ETH，長時間的等待與頻繁地花費是DAPP的致命傷─並不是所有人都有耐心等待也願意花手續費的。也因此側鏈、鏈下交易的技術也在蓬勃發展中，希望能夠解決無法即時交易的致命傷。</p>
<p>另一個是UX體驗不良:在使用DAPP前你必須先擁有區塊鏈的錢包，但目前有接觸並持有錢包的人少之又少，你可以在<a href="https://dappradar.com/">DappRadar</a>中看到全世界每天超過1000人次使用的DAPP大約只有十來個，對比目前Android、IOS上APP動輒百萬起跳的使用頻率差距非常地大。</p>
<p>今天我們講解完了基本Ethereum的架構與手續費計算，明天我們來體驗一下如何撰寫與使用基本的智能合約！</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-26"><a class="header" href="#ref-26">Ref:</a></h1>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA">Wikipedia-圖靈機</a></li>
<li><a href="https://blog.xuite.net/wellsli/002/32646708-%E8%A8%88%E7%AE%97%E6%A9%9F%E7%90%86%E8%AB%96%E7%9A%84%E5%A7%8B%E7%A5%96---%E5%9C%96%E9%9D%88%E6%A9%9F">計算機理論的始祖---圖靈機</a></li>
<li><a href="https://medium.com/@ksin751119/ethereum-dapp%E5%88%9D%E5%BF%83%E8%80%85%E4%B9%8B%E8%B7%AF-3-%E7%B0%A1%E4%BB%8Bethereum-%E4%B9%99%E5%A4%AA%E5%9D%8A-smart-contract-%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84-7a0dfd32662f">Ethereum Dapp初心者之路(3): 簡介Ethereum(乙太坊)、Smart Contract(智能合約)</a></li>
<li><a href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-23smart-contract-%E5%88%9D%E6%8E%A2%E5%BE%9E-bytecode-%E5%88%B0-solidity/">Ethereum 開發筆記 2–3：Smart Contract 初探，從 Bytecode 到 Solidity</a></li>
<li><a href="https://medium.com/mycrypto/the-ethereum-virtual-machine-how-does-it-work-9abac2b7c9e">The Ethereum Virtual Machine — How does it work?</a></li>
<li><a href="https://medium.com/@daniel.mars622/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8D%80%E5%A1%8A%E9%8F%88%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9-b7317347a612">以太坊區塊鏈智能合約基礎介紹</a></li>
<li><a href="https://ethereum.stackexchange.com/questions/72211/setting-array-in-solidity/72225">setting array in Solidity</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day29現實中的區塊鏈6基礎智能合約語法"><a class="header" href="#day29現實中的區塊鏈6基礎智能合約語法">Day29|現實中的區塊鏈(6)：基礎智能合約語法</a></h1>
<h1 id="開發環境與使用"><a class="header" href="#開發環境與使用">開發環境與使用</a></h1>
<p>我們今天的目的是以其他語言作為基礎，加以比較智能合約程式碼的特色。如果你想嘗試學習與開發智能合約，目前Ethereumm上最主流的語言是<code>Solidity</code>，開發智能合約的過程與一般程式類似，都需要經過撰寫程式→編譯的過程，差別就在智能合約最後會把經過編譯的原始碼(Bytecode)以一般交易的形式送上區塊鏈儲存，並等待其他人觸發。</p>
<p><img src="images/day29_43177.png" alt="Compile" /></p>
<p>圖片來源: <a href="https://blog.fukuball.com/ethereum-%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-21ethereum-%E9%96%8B%E7%99%BC%E6%95%B4%E9%AB%94%E8%84%88%E7%B5%A1/">Ethereum 開發筆記 2–1：Ethereum 開發整體脈絡</a></p>
<p>Solidity目前最容易入手的整合開發環境(IDE)是由乙太坊基金會所開法與維護的<a href="https://remix.ethereum.org/">Remix</a>，Remix的優點跟強項是全部網頁化，撰寫智能合約你並不需要安裝任何軟體，只需要點開瀏覽器的網址就可以開始了。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day29_4.JPG" alt="Remix" /></p>
<p>圖片擷取自: <a href="https://remix.ethereum.org/">Remix</a></p>
<p>其他知名與主流的IDE還有<a href="https://www.trufflesuite.com/truffle">Truffle</a>與<a href="https://www.trufflesuite.com/ganache">Ganache</a>，Truffle主要負責智能合約的開發與撰寫，提供了一個類似Django的migration功能，大部分的指令都需要依靠command line進行，而Ganache也是由Truffle團隊開發，提供了圖形化介面方便使用者實際測試。如果你有興趣學習這兩種IDE的話可以參考<a href="https://blog.niclin.tw/2018/08/12/%E7%94%A8-truffle-%E9%96%8B%E7%99%BC-dapp-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8A%95%E7%A5%A8%E7%A8%8B%E5%BA%8F%E6%87%89%E7%94%A8-part-1/">這裡</a>的教學。</p>
<h1 id="基礎智能合約語法"><a class="header" href="#基礎智能合約語法">基礎智能合約語法</a></h1>
<p>如果你完全沒經驗的話，Solidity不該是你的第一門語言，你應該去學Javascript或C/C++之類的語言後才來學習Solidity。另外因為我對C/C++比較熟悉，大部分人應該也都學習過C/C++，所以等等類比或舉例時都會以C/C++為主。</p>
<p>Solidity自5.0後進行了大幅度的<a href="https://solidity.readthedocs.io/en/v0.5.0/050-breaking-changes.html">改版</a>，所以如果你過去有撰寫過Solidity的經驗，記得先去查閱語法的變動。也因為目前Solidity還處在一個迅速發展與更動的狀態，才不建議以Solidity作為你的第一門程式語言。下面是我整理的常用Solidity基本語法，你可以當作cheat sheet來使用，先對基本的語法有些概念後，我們就可以來讀一讀幾個經典的智能合約了。</p>
<h2 id="合約架構"><a class="header" href="#合約架構">合約架構</a></h2>
<p>首先來談合約架構，在一個地址底下的合約通常會有這三個部分:</p>
<h3 id="編譯器版本"><a class="header" href="#編譯器版本">編譯器版本</a></h3>
<p>在合約的一開始請記得指定編義器的版本，如果你要指定成0.5.3的話可以這樣寫</p>
<blockquote>
<p>pragma solidity ^0.5.3</p>
</blockquote>
<p>或是想指定特定的編譯器版本範圍的話你也可以這樣寫</p>
<blockquote>
<p>pragma solidity &gt;=0.4.0 &lt;0.5.0;</p>
</blockquote>
<h3 id="contract"><a class="header" href="#contract">contract</a></h3>
<p>Solidity的基本單位是<code>contract</code>，contract間可以彼此呼叫與使用，一個基本contract寫法會包含變數與函式，如下:</p>
<pre><code>contract ContractDemo {
    variable variable_name_1;
    variable variable_name_2;
    variable variable_name_3;

    function function_name(variable parameter_name, ...) Visibility  {
        codes of this function...
    }

    function function_name(variable parameter_name, ...) Visibility  {
        codes of this function...
    }

    function function_name(variable parameter_name, ...) Visibility  {
        codes of this function...
    }
}
</code></pre>
<h3 id="libraries"><a class="header" href="#libraries">Libraries</a></h3>
<p><code>Library</code>可以視作是函式庫，宣告方式也跟Contract一樣，Library被部署在鏈上後也有一個專屬的address，可以被任何人呼叫，但Library使用上不能儲存Ether與任何資料，裡面只能有函式，所以把它當函式庫來看比較適當。</p>
<pre><code>library Demo {
    function DemoFunction() returns (type) {
        return value_to_return;
    }
}
</code></pre>
<p>寫完library後，可以用using...for的方式在contract中被使用</p>
<blockquote>
<p>using library for another_name;</p>
</blockquote>
<h2 id="變數型別"><a class="header" href="#變數型別">變數型別</a></h2>
<p>Solidity主要的變數型別有以下幾種</p>
<ul>
<li>
<p><code>bool</code>:布林變數，有true/false兩種</p>
</li>
<li>
<p><code>int/uint</code>:int是一般的整數、而uint是unsigned int的縮寫(全正的正整數)，後面加個數字代表所使用的bit空間，宣告的範圍可以從uint8到uint256，如果沒特別寫的話就是指uint256</p>
</li>
<li>
<p><code>bytes</code>:位元組，可以從bytes1~bytes32指定長度，如果只寫byte則代表bytes</p>
</li>
<li>
<p><code>string</code>:字串</p>
</li>
<li>
<p><code>address</code>: 錢包地址</p>
</li>
<li>
<p><code>array</code>: 陣列，跟C++相似的是可以使用new來開出一個新陣列</p>
</li>
</ul>
<blockquote>
<p>uint[] Array = new uint<a href="16"></a></p>
</blockquote>
<ul>
<li><code>mapping</code>:映射，映射是在智能合約裡非常常用的型態，可以用來儲存或查詢使用者的資料，最常見的宣告mapping形式就是查詢使用者的餘額，所以輸入值是一個地址、輸出值是一個uint256(因為餘額不會有負的)。</li>
</ul>
<blockquote>
<p>mapping(address =&gt; uint256) public balance;</p>
</blockquote>
<p>實際使用上很像python裡頭dictionary的用法！</p>
<blockquote>
<p>balances[address] = new_balance;</p>
</blockquote>
<p>最重要的是因為尾數運算總會有誤差的關係，<strong>在solidity裏頭沒有float或double這兩種資料型別！</strong></p>
<h2 id="運算子"><a class="header" href="#運算子">運算子</a></h2>
<p>Solidity支援的常見運算子如下:</p>
<ul>
<li>加減乘除取餘數，+-*/%</li>
<li>次方(<strong>)，a的b次方就是a</strong>b</li>
<li>位元左移右移，&lt;&lt;、&gt;&gt;</li>
<li>複合指定運算子，+=、-=、*=、/=</li>
<li>顯性資料轉型(Explicit Conversion)，與C/C++的寫法類似</li>
</ul>
<blockquote>
<p>uint x = uint(y);</p>
</blockquote>
<ul>
<li>delete，刪除某個變數並且釋放空間，但要注意的是因為mapping無法直接取得所有的key值，所以mapping無法使用delete！</li>
</ul>
<h2 id="函式撰寫"><a class="header" href="#函式撰寫">函式撰寫</a></h2>
<p>函式的撰寫需要以<code>function</code>開頭，寫法如下:</p>
<blockquote>
<p>function (variable) {visibility} {pure|view|payable} returns (type)</p>
</blockquote>
<h3 id="visibility"><a class="header" href="#visibility">visibility</a></h3>
<p>根據合約內的函式是否可被內部呼叫、繼承或外部使用可以區分成四個visibility:<code>internal</code>、<code>external</code>、<code>public</code>、<code>private</code></p>
<p>||internal|external|public|private|<br />
|---|---|---|---|---|<br />
|合約內使用|O|X|O|O|<br />
|可繼承|O|X|O|X|<br />
|外部呼叫|X|O|O|X|</p>
<p>可以發現external就是專門給外界用的，比方說讓外界購買ICO的函式，而internal則跟external完全相反，除了外界外在合約內可以使用、同時也可以被繼承，適合拿來做內部運算的函式，比方說ICO匯率的換算等。而public則是通通都可以、private則限制最嚴格，僅能在目前合約內使用。</p>
<h3 id="純資料讀取"><a class="header" href="#純資料讀取">純資料讀取</a></h3>
<p>區塊鏈上的儲存空間非常珍貴，如果函式只有讀取的需求的化為了避免耗費資源可以宣告成<code>pure</code>或‵<code>view</code>，pure的是該函示不涉及任何合約上變數的讀取，比方說是</p>
<blockquote>
<p>function Demo(uint input) extern pure returns (uint output) { return input * 2; }</p>
</blockquote>
<p>view的意思則是會讀取合約內的變數，但不會改變合約內的值:</p>
<pre><code>contract Demo {
   uint variable;
   function Demo(uint input) extern pure returns (uint output) {
       return input * variable; 
   }
}
</code></pre>
<p>因為只需要讀取區塊鏈上的資料，所以pure跟view都不需要耗費手續費喔!</p>
<p>至於<code>payable</code>則代表這個函式可以接受ETH的匯款!</p>
<h2 id="modifier"><a class="header" href="#modifier">modifier</a></h2>
<p>modifier通常拿來做函式執行前的檢查，通常會檢查使用者的權限或餘額是否足夠，為了方便可以統一寫成modifier，像是為了確認交易發起人是否為合約持有者，我們可以這樣寫:</p>
<pre><code>modifier onlyOwner {
    require(msg.sender == owner, "You are not authorized.");
    _;
}
</code></pre>
<p>使用時也只需要在函式的大括號前面加上modifier就好了!</p>
<pre><code>function Demo() public onlyOwner {
    // Do something.
}
</code></pre>
<h2 id="enum與struct"><a class="header" href="#enum與struct">enum與struct</a></h2>
<p>與C/C++一樣，Solidity也支援了enum與struct的語法。</p>
<pre><code>enum Demo{
    Demo_1,
    Demo_2,
    Demo_3
}



struct Demo {
        address payable Demo;
        uint Demo_uint;
}
</code></pre>
<h2 id="繼承"><a class="header" href="#繼承">繼承</a></h2>
<p>要繼承另外的合約繼續擴充的話，也只需要寫<code>is</code>就可以了!</p>
<pre><code>contract child_contract is parent_contract {
    // Do something......
}
</code></pre>
<h2 id="常用關鍵字"><a class="header" href="#常用關鍵字">常用關鍵字</a></h2>
<p>我列舉了幾個常用的關鍵字，但如果想要知道全部的話可以參考<a href="https://solidity.readthedocs.io/en/v0.5.3/miscellaneous.html">官方文件</a>。</p>
<h3 id="關於發送者"><a class="header" href="#關於發送者">關於發送者</a></h3>
<ul>
<li><code>msg.sender</code>: 這筆交易發起者的錢包地址</li>
<li><code>msg.data</code> (bytes): 這筆交易完整的input data</li>
<li><code>msg.value</code> (uint): 跟這筆交易一起被送出的eth數目(單位:wei)</li>
</ul>
<h3 id="關於區塊"><a class="header" href="#關於區塊">關於區塊</a></h3>
<ul>
<li><code>block.coinbase</code>: 挖掘出目前區塊的礦工</li>
<li><code>block.difficulty</code> (uint): 目前區塊的難度</li>
<li><code>block.gaslimit</code> (uint): 目前區塊的gas容量上限</li>
<li><code>block.number</code> (uint): 現在是第幾個區塊</li>
<li><code>block.timestamp</code> (uint): 目前區塊的時間戳</li>
</ul>
<h2 id="資料儲存"><a class="header" href="#資料儲存">資料儲存</a></h2>
<p>在solidity的函式內如果要宣告變數，有兩種宣告方式<code>storage</code>與<code>memory</code>:</p>
<ul>
<li><code>storage</code>:永久儲存在區塊鏈上，如果沒被初始化就會指向合約本身</li>
<li><code>memory</code>:執行完畢則清空，相當於只存在記憶體裡頭</li>
</ul>
<p>簡而言之storage就是所有觸發合約的交易共用的參數，而memory則是指有這筆交易能夠使用。至於何時該用storage、何時開用memory？你可以參考<a href="https://medium.com/taipei-ethereum-meetup/%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84-storage-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85-99047f6cd4ea">這篇文章</a>。</p>
<h2 id="拋出錯誤"><a class="header" href="#拋出錯誤">拋出錯誤</a></h2>
<p>如果發生錯誤，要立刻中止合約執行的方法有: <code>require</code>、<code>assert</code>、<code>revert</code>，假設我們要判別使用者的權限，如果權限不足就立刻中止合約執行的話下面這三種寫法</p>
<ul>
<li><code>require</code></li>
</ul>
<blockquote>
<p>require(msg.sender == owner);</p>
</blockquote>
<ul>
<li><code>revert</code></li>
</ul>
<blockquote>
<p>if(msg.sender != owner) { revert(); }</p>
</blockquote>
<ul>
<li><code>assert</code></li>
</ul>
<blockquote>
<p>assert(msg.sender == owner);</p>
</blockquote>
<p>require與revert類似，在合約終止後都會退還剩餘手續費用的，但asser就帶有點懲罰的意味，一旦交易失敗，剩餘的手續費是不會被退還的!</p>
<h2 id="eventlog"><a class="header" href="#eventlog">event/log</a></h2>
<p>合約內部的確可以儲存使用者的狀態，但在合約內儲存資料的成本非常高，所以如果只是想要儲存交易的結果的話，那麼可以使用較為便宜的event儲存，event的寫法跟函式一樣相當容易，呼叫時也只需要把引數傳入就可以把這些資料記錄在鏈上了。</p>
<pre><code>event event_demo(address user, uint256 amount);
function function() payable {
    event_demo(msg.sender, msg.value);
}
</code></pre>
<p>但便宜是有代價的，event的資料並不能被智能合約本身讀取喔!通常都是由使用者端的Web3.js(明天會再說明)讀取交易的結果與紀錄之用。</p>
<h2 id="import其他地址中的contractlibrary"><a class="header" href="#import其他地址中的contractlibrary">import其他地址中的contract/library</a></h2>
<p>要import其他地址中的contract/library首先你需要先取得該合約底下函式或變數的介面</p>
<pre><code>contract demo_interface {
  function demo(address _address,uint256 _amonut) external pure returns (bool);
}
</code></pre>
<p>想要使用該合約的話需要先實體化該合約</p>
<blockquote>
<p>demo_interface public demo_obj;</p>
</blockquote>
<p>實體化之後記得把該合約所位於的地址匯入</p>
<blockquote>
<p>demo_obj = demo_interface(contract_ddress);</p>
</blockquote>
<h2 id="常用contractlibrary"><a class="header" href="#常用contractlibrary">常用contract/library</a></h2>
<p>智能合約中最常被使用到的contract/library有兩個: <code>Safemath</code>與<code>Ownable</code>。</p>
<h3 id="safemath"><a class="header" href="#safemath">Safemath</a></h3>
<p>Safemath主要是在協助簡單的四則運算避免出錯，你可以在<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol">Github</a>看到原始碼，我把它節錄在下面，你應該可以發現Safemath主要是為了處理整數運算後溢位的情形。</p>
<pre><code>library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "SafeMath: addition overflow");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        uint256 c = a - b;
        return c;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b &gt; 0, errorMessage);
        uint256 c = a / b;
        return c;
    }
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
</code></pre>
<h3 id="ownable"><a class="header" href="#ownable">Ownable</a></h3>
<p>Ownable則是讓合約持有者擁有某些特殊的權限，我這裡也從<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/ownership/Ownable.sol">Github</a>摘錄了部分程式碼在下，透過Ownable地協助可以讓你自己發出去的合約擁有辨識身分或持有者是誰的能力。</p>
<pre><code>ontract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
    function owner() public view returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
</code></pre>
<h1 id="智能合約範例"><a class="header" href="#智能合約範例">智能合約範例</a></h1>
<p>上面的語法讀完你就可以讀懂八成以上的智能合約了！今天的最後我們來看一下最知名的ERC20-<a href="https://medium.com/@astromnhsu/usdt-price-drop-stablecoins-rise-4177d2e21620">USDT</a>。你在<a href="https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7">Etherscan</a>上可以看到USDT的合約原始碼。</p>
<p>合約的一開始你就可以看到我們剛剛提過的<code>Safemath</code>，接下來你可以看到<code>ERC20Basic</code>的介面定義了USDT的流通量、餘額的查詢、匯款的函式，同時匯款完畢後也會用<code>event</code>記錄下這筆交易的結果。</p>
<pre><code>contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public constant returns (uint);
    function balanceOf(address who) public constant returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}
</code></pre>
<p>其中的餘額你可以發現就是用<code>mapping</code>在做儲存的喔。</p>
<pre><code>function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
}
</code></pre>
<p>接著<code>ERC20</code>繼承了<code>ERC20Basic</code>並且實作出了授權提款的介面。</p>
<pre><code>contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public constant returns (uint);
    function transferFrom(address from, address to, uint value) public;
    function approve(address spender, uint value) public;
    event Approval(address indexed owner, address indexed spender, uint value);
}
</code></pre>
<p>最後你還可以發現USDT有默默做了黑名單的功能，甚至可以把黑名單持有的USDT直接銷毀!</p>
<pre><code>contract BlackList is Ownable, BasicToken {
    function getBlackListStatus(address _maker) external constant returns (bool) {
        return isBlackListed[_maker];
    }
    function getOwner() external constant returns (address) {
        return owner;
    }
    mapping (address =&gt; bool) public isBlackListed;
    function addBlackList (address _evilUser) public onlyOwner {
        isBlackListed[_evilUser] = true;
        AddedBlackList(_evilUser);
    }
    function removeBlackList (address _clearedUser) public onlyOwner {
        isBlackListed[_clearedUser] = false;
        RemovedBlackList(_clearedUser);
    }
    function destroyBlackFunds (address _blackListedUser) public onlyOwner {
        require(isBlackListed[_blackListedUser]);
        uint dirtyFunds = balanceOf(_blackListedUser);
        balances[_blackListedUser] = 0;
        _totalSupply -= dirtyFunds;
        DestroyedBlackFunds(_blackListedUser, dirtyFunds);
    }
    event DestroyedBlackFunds(address _blackListedUser, uint _balance);
    event AddedBlackList(address _user);
    event RemovedBlackList(address _user);
}
</code></pre>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上，至於USDT的程式碼則放在<a href="https://github.com/lkm543/it_iron_man_2019/blob/master/code/day29.sol">這裡</a>。</p>
<h1 id="ref-27"><a class="header" href="#ref-27">Ref:</a></h1>
<ul>
<li><a href="https://medium.com/taipei-ethereum-meetup/ethereum-%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-%E7%B7%A8%E8%AD%AF%E5%92%8C%E9%83%A8%E7%BD%B2%E5%90%88%E7%B4%84%E7%9A%84%E7%AC%AC%E4%B8%80%E7%A8%AE%E5%A7%BF%E5%8B%A2-%E4%BD%BF%E7%94%A8-remix-4528164d0fde">【Ethereum 智能合約開發筆記】編譯和部署合約的第一種姿勢：使用 Remix</a></li>
<li><a href="https://solidity.readthedocs.io/en/latest/">Solidity</a></li>
<li><a href="https://gist.github.com/Ankarrr/b33d388aa4c4411559f74d9814447ff3">【Ethereum 智能合約開發筆記】不用自己跑節點，使用 Infura 和 web3.js 呼叫合約</a></li>
<li><a href="https://www.itread01.com/content/1546054868.html">internal、private、external、public區別</a></li>
<li><a href="https://medium.com/taipei-ethereum-meetup/%E6%AF%94%E8%BC%83-require-assert-%E5%92%8C-revert-%E5%8F%8A%E5%85%B6%E9%81%8B%E4%BD%9C%E6%96%B9%E5%BC%8F-30c24d534ce4">比較 require(), assert() 和 revert()，及其運作方式。</a></li>
<li><a href="https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e">Solidity Learning: Revert(), Assert(), and Require() in Solidity, and the New REVERT Opcode in the EVM</a></li>
<li><a href="https://medium.com/taipei-ethereum-meetup/solidity%E6%92%B0%E5%AF%AB%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84%E8%88%87%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85-%E4%BA%8C-dd915bdeafa0">Solidity撰寫智能合約與注意事項(二)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day30現實中的區塊鏈7智能合約的使用與操作"><a class="header" href="#day30現實中的區塊鏈7智能合約的使用與操作">Day30|現實中的區塊鏈(7)：智能合約的使用與操作</a></h1>
<h1 id="智能合約"><a class="header" href="#智能合約">智能合約</a></h1>
<p>在講解完Ethereum的架構、手續費機制與基本語法後，今天我們來試著在一般網頁上使用簡單的合約，我們的重點會放在智能合約如何使用與運作、以及智能合約在使用時有哪些需要特別注意的地方。</p>
<h2 id="如何觸發智能合約"><a class="header" href="#如何觸發智能合約">如何觸發智能合約</a></h2>
<p>觸發智能合約的方式跟一般交易相當類似，使用者會發出一筆交易到智能合約的地址，而這筆交易通常不帶任何ETH(其實有需求要帶也可以，照昨天所說的加入<code> payable修飾即可</code>)。跟一般交易不同的是該筆交易的<code>input data</code>欄位會指定要執行的函式與欲帶入的引數(下圖紅框處)，礦工打包到這筆交易後便會執行相對應的函式。比方說下圖這筆交易便是觸發<code>transfer</code>(轉移餘額，就是匯款的意思)</p>
<p><img src="https://www.lkm543.site/it_iron_man/day30_1.jpg" alt="Input Data" /></p>
<p>圖片擷取自: <a href="https://etherscan.io/tx/0x43cd813f9a838c300338f6973d103ca660fc0519f160b01d1de6b6f7abb680ed">etherscan</a></p>
<p>你也可以點選Etherscan中Decode input data的按鈕來看編碼後的輸入值，可以看到這筆匯款是匯給 725f78217f20784ccd723be44abe39fc03fd855c、金額則是420348314(換算時記得除以1000000)。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day30_2.JPG" alt="Input Data" /></p>
<p>圖片擷取自: <a href="https://etherscan.io/tx/0x43cd813f9a838c300338f6973d103ca660fc0519f160b01d1de6b6f7abb680ed">etherscan</a></p>
<h2 id="application-binary-interfaceabi"><a class="header" href="#application-binary-interfaceabi">Application Binary Interface(ABI)</a></h2>
<p>前幾天我們有提到智能合約編譯成可以被EVM執行的Bytecode後才會被送上鏈，送上鏈之後便會產生一個特定的合約地址，日後有人想要使用這個合約也只要向這個合約地址發起交易便可以了！但我們要怎麼知道合約有哪些函式、這些函式又需要那些引數呢？</p>
<p>這時候就需要<code>Application Binary Interface(ABI)</code>來告訴我們智能合約的介面了。</p>
<p>如果你也寫過標頭檔(.hpp)或是API文件的話就會很好理解ABI，ABI向標頭檔一樣是個程式介面，其中詳盡規範與說明了合約中每一個函式的使用方式，如果你沒有相關經驗的話，你可以把ABI想像成是該智能合約的操作說明書，你可以到Etherscan上看到某些合約的程式碼與ABI(下圖)。</p>
<p><img src="https://www.lkm543.site/it_iron_man/day30_3.JPG" alt="ABI" /></p>
<p>圖片擷取自: <a href="https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code">etherscan</a></p>
<p>另外注意一件事，實際上智能合約編譯成Bytecode後就很難反編譯回原本的程式碼，同時也無法直接從Bytecode推算出合約的ABI，你可以在<a href="https://etherscan.io/">Etherscan</a>上看到某些智能合約的程式碼與ABI是因為合約持有方對Etherscan提供了合約的原始碼，經過Etherscan編譯後可以編譯出一模一樣的Bytecode，藉此證明該原始碼與合約內容是相符的，同時Etherscan也可以幫助你公開合約的程式碼與ABI供外界檢視與使用。</p>
<p>Solidity的<a href="https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html">官方文件</a>中便有規範ABI裏頭的格式，節錄一段在下面可以參考。</p>
<blockquote>
<p><code>type</code>: "function", "constructor", or "fallback" (the unnamed “default” function);<br />
<code>name</code>: the name of the function;<br />
<code>inputs</code>: an array of objects, each of which contains:<br />
<code>name</code>: the name of the parameter;-<br />
<code>type</code>: the canonical type of the parameter (more below).<br />
<code>components</code>: used for tuple types (more below).<br />
<code>outputs</code>: an array of objects similar to inputs, can be omitted if function doesn’t return anything;<br />
<code>stateMutability</code>: a string with one of the following values: pure (specified to not read - blockchain state), view (specified to not modify the blockchain state), nonpayable (function does not accept Ether) and payable (function accepts Ether);<br />
<code>payable</code>: true if function accepts Ether, false otherwise;<br />
<code>constant</code>: true if function is either pure or view, false otherwise.</p>
</blockquote>
<h1 id="網頁與ethereum的互動"><a class="header" href="#網頁與ethereum的互動">網頁與Ethereum的互動</a></h1>
<p>智能合約目前最大的痛點就是相較一般網頁與APP來說使用門檻極高─區塊鏈上都是以地址為身份辨識進行，所以使用智能合約你必須先安裝/擁有Ethereum的錢包地址才能夠跟智能合約互動。</p>
<h2 id="metamask"><a class="header" href="#metamask">Metamask</a></h2>
<p>目前最主流的網頁錢包就是Chrome的擴充套件<a href="https://metamask.io/">metamask</a>，你可以到<a href="https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=zh-TW">這裡</a>安裝下載，安裝上Metamask後就等於擁有了網頁錢包，也可以透過Metamask對智能合約發起交易。。</p>
<p><img src="images/day30_39088.jpg" alt="Metamask" /></p>
<p>圖片來源: <a href="https://www.ledger.com/metamask/">ledger</a></p>
<h2 id="web3js"><a class="header" href="#web3js">Web3.js</a></h2>
<p>至於要如何讓使用者可以透過網頁與Metamask直接操作錢包呢?目前最主流跟Ethereum溝通的toolkit是由Javascript所撰寫的<code>Web3.js</code>，因為Web3.js由Javascript所撰寫，所以可以直接嵌入網頁的前端中，使用者只需要點選網頁就可以跟智能合約或是Ethereum互動。</p>
<p>如果你不會寫JS的話，到<a href="https://www.codecademy.com/">codecademy</a>可以先學一些javascript語法。下面我簡單列舉了幾項Web3.js的寫法來讓你理解Web3.js是如何工作的。</p>
<h3 id="初始化並連接節點"><a class="header" href="#初始化並連接節點">初始化並連接節點</a></h3>
<p>要連接節點後我們才能查詢資料或發出交易請求，因此這裡我們需要透過API的協助，目前最主流的服務商是<a href="https://infura.io/">infura</a>，你可以到他們的網頁申請帳號後就可以申請到一組API_KEY並且使用他們的服務。</p>
<pre><code>var Web3 = require('web3');

if (typeof web3 !== 'undefined') {
    web3 = new Web3(web3.currentProvider);
} else {
    // set the provider you want from Web3.providers
    web3 = new Web3(new Web3.providers.HttpProvider("https://mainnet.infura.io/v3/YOUR_API_KEY"));
}
</code></pre>
<h3 id="取得錢包餘額"><a class="header" href="#取得錢包餘額">取得錢包餘額</a></h3>
<p>如果要取得錢包餘額的話，可以使用<code>web3.eth.getBalance()</code>來獲取特定地址的ETH餘額，並起透過<code>web3.fromWei(balance, 'ether')</code>換算成ETH，並且取到小數點後三位。</p>
<pre><code>var balance = web3.eth.getBalance(YOUR_ADDRESS);
balance = web3.fromWei(balance, 'ether').toFixed(3);
</code></pre>
<h3 id="匯款"><a class="header" href="#匯款">匯款</a></h3>
<p>匯款的話可以使用<code>web3.eth.sendTransaction()</code>，需要帶入的引數為一個紀錄交易明細的Json，注意匯款的單位是Wei喔。交易完後就可以得到該筆交易的Hash值。</p>
<pre><code>var transaction_obj = {
    "from": sender,
    "to": receipt,
    "value": web3.toWei(1.5, 'ether'),
    "gas": optional,
    "gasPrice": optional,
    "data": optional,
    "nonce": optional
};
web3.eth.sendTransaction(transaction_obj, function(error, result){
    if(error) {
        // 例外處理
    } else {
        var transaction_hash = result;
    }
});
</code></pre>
<h3 id="使用智能合約"><a class="header" href="#使用智能合約">使用智能合約</a></h3>
<p>智能合約的使用你必須先匯入上面我們提到的ABI，接著透過合約地址與ABI就可以接上智能合約在Ethereum上的對口。</p>
<pre><code>const abi = require('./abi.json');
const contract_address = 'CONTRACT_ADDRESS';
contract_instance = new web3.eth.Contract(abi, contract_address);
</code></pre>
<p>使用上有兩種方式<code>call</code>、<code>send</code>，如果你只需要讀取合約上的資料，那麼使用call就可以了，使用call時不需要任何費用，但該函式必須是我們昨天寫的pure、view或是public變數，但如果你想要更動合約上的資料，那麼就必須用send來跟上面一樣發出一筆交易，也會耗去部分的手續費。</p>
<pre><code>contract_instance.FUNCTION_NAME.call(function(error, result) {
    if (error) {
        // 例外處理
    } else {
        // 實際執行
    }
});
</code></pre>
<p>或是你也可以直接透過地址與METHOD_ID來查詢合約裡的變數。</p>
<pre><code>var result = web3.eth.call({
    to: CONTRACT_ADDRESS,
    data: METHOD_ID
});
</code></pre>
<p>如果想要更動合約上的資料，就必須使用<code>web3.eth.sendRawTransaction()</code>來發起一筆交易對合約動作。</p>
<h1 id="推薦的學習資料"><a class="header" href="#推薦的學習資料">推薦的學習資料</a></h1>
<p>上面只是簡單列舉實際在使用時會需要知道的基本知識，如果你想要更進一步了解的話，下面幾個是我接觸過也相當推薦的學習網站。另外<a href="https://www.trufflesuite.com/">Truffle</a>與<a href="https://www.trufflesuite.com/ganache">Ganache</a>也是必學的開發環境。</p>
<h2 id="smart-contract開發"><a class="header" href="#smart-contract開發">Smart contract開發</a></h2>
<ul>
<li><a href="https://solidity.readthedocs.io/en/latest/">Solidity官方文件</a></li>
<li><a href="https://ethereumbuilders.gitbooks.io/guide/content/en/solidity_tutorials.html">Ethereum Builder's Guide</a></li>
<li><a href="https://cryptozombies.io/">cryptozombies</a></li>
</ul>
<h2 id="web3js開發"><a class="header" href="#web3js開發">Web3.js開發</a></h2>
<ul>
<li><a href="https://web3js.readthedocs.io/en/v1.2.1/">Web3.js官方文件</a></li>
<li><a href="https://www.dappuniversity.com/articles/web3-js-intro">Dapp University</a></li>
<li><a href="https://www.trufflesuite.com/tutorials">Truffle Tutorial</a></li>
</ul>
<h2 id="udemy影音推薦"><a class="header" href="#udemy影音推薦">Udemy影音推薦</a></h2>
<ul>
<li><a href="https://www.udemy.com/course/blockchain-and-smart-contracts-a-complete-practical-guide/">Practical Blockchain &amp; Smart Contracts : Ethereum &amp; Solidity</a></li>
<li><a href="https://www.udemy.com/course/ethereum-and-solidity-the-complete-developers-guide/">Ethereum and Solidity: The Complete Developer's Guide</a></li>
<li><a href="https://buildmedia.readthedocs.org/media/pdf/web3js/1.0/web3js.pdf">web3.js Documentation Release 1.0.0</a></li>
</ul>
<h1 id="後記鐵人賽心得"><a class="header" href="#後記鐵人賽心得">後記─鐵人賽心得</a></h1>
<p>三十天的鐵人賽終於告一段落了~在今天與鐵人賽的最後來分享這段時間的感想。</p>
<h2 id="進度配置"><a class="header" href="#進度配置">進度配置</a></h2>
<p>鐵人賽最重要的部分莫過於進度配置，我習慣先用Evernote把這三十天的主題大致先決定好，在9/17(二)開賽前剛好遇到三天的中秋連假，利用中秋連假大概用一篇4~6小時的速度在開賽前完成了快10篇的摳打，但遇到考試、實習與打工，其實到後面這些庫存量是完全不夠用的，在平均一篇要寫4~6小時的狀況下等於整個晚上都會被寫文章耗費掉，在區段考前頂多也只能抽出每天1~2小時來撰寫，幸好結束前又遇到了四天國慶連假補了大概5~6篇進來才能夠順利完賽，如果沒有連假應該會直接GG。</p>
<p>強烈建議如果事前知道自己有哪些天會比較忙碌的話，可以事先把這些天的內容準備好，或是多庫存幾天以免突發狀況(朋友邀約、生病之類的)產生，像是考量到區段考的時間所以我先留了10篇的庫存讓我在這段時間可以專心準備考試。</p>
<h2 id="內容安排"><a class="header" href="#內容安排">內容安排</a></h2>
<p>內容的考驗的是對領域的掌握程度─你要先知道這個領域有甚麼可以談、要談多深、談多久都需要底子，另外粗細的掌握非常重要，我一開始很有衝勁的想把所有東西都講很細很清楚，結果密碼學入門那裏就寫的太多導致壓縮到後面的內容與空間。內容的掌握與安排真是一項藝術呀。</p>
<p>除了入門教學的系列外，鐵人賽可以看作是一年來的學習成果與加深，會選區塊鏈這個題目也是因為過去一兩年來對這個領域接觸比較多，除了強迫自己歸納與統整這段日子的所學外，也可以順便透過查詢資料與規劃內容的過程知道自己有哪些方面的知識有所不足並且可以趁機加以填補。</p>
<h2 id="強迫自己閱讀與真正理解"><a class="header" href="#強迫自己閱讀與真正理解">強迫自己閱讀與真正理解</a></h2>
<p>寫文章的好處是強迫自己真正理解一個領域，而不是只有處在一知半解的狀態。但寫文章難的部分是要怎麼樣有動力去扎扎實實地寫好一個系列......而鐵人賽就給了一個強烈的動機去完成。此外是對寫作能量的提升，以我為例這30天內寫了7萬個字左右，從第一天的舉筆不定到後來可以流暢地直接打完一整段文字自己的感覺最深刻。</p>
<h2 id="時限壓力"><a class="header" href="#時限壓力">時限壓力</a></h2>
<p>與平常工作或Side Project相比，鐵人賽有每天要完成一定工作的時間壓力，在壓力賀爾蒙的協助下可以大幅度的提升工作表現與治療拖延病，但偶爾一個月這樣可以，太久就會有點傷身了。</p>
<p>這次大約用了一個半月的空閒時間產出了30篇文章，說真的CP值還蠻高的，明年見習時或許可以再來挑戰看看，至於要寫甚麼就看未來這一年會學到甚麼了。</p>
<p>到目前為止的文章都會放置在<a href="https://github.com/lkm543/it_iron_man_2019">Github</a>上。</p>
<h1 id="ref-28"><a class="header" href="#ref-28">Ref:</a></h1>
<ul>
<li><a href="https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html">Contract ABI Specification</a></li>
<li><a href="https://medium.com/taipei-ethereum-meetup/ethereum-%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98-%E6%B7%B1%E5%85%A5%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84-abi-268ececb70ae">【Ethereum 智能合約開發筆記】深入智能合約 ABI</a></li>
<li><a href="https://medium.com/@twedusuck/%E5%9C%A8%E5%8D%80%E5%A1%8A%E9%8F%88%E4%B8%8A%E5%BB%BA%E7%AB%8B%E5%8F%AF%E6%9B%B4%E6%96%B0%E7%9A%84%E6%99%BA%E6%85%A7%E5%90%88%E7%B4%84-%E4%BA%8C-24f07206d033">在區塊鏈上建立可更新的智慧合約(二)</a></li>
<li><a href="https://medium.com/@ksin751119/ethereum-dapp%E5%88%9D%E5%BF%83%E8%80%85%E4%B9%8B%E8%B7%AF-5-%E7%B0%A1%E4%BB%8Bweb3-javascript-api%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C-253c468450c0">Ethereum Dapp初心者之路(5): 簡介Web3 Javascript API及常用操作</a></li>
<li><a href="https://truffle.tryblockchain.org/truffle3.0-integrate-nodejs.html">Truffle - 以太坊Solidity编程语言开发框架</a></li>
<li><a href="https://medium.com/taipei-ethereum-meetup/%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8A%A0%E9%80%9Fdapp%E5%BB%BA%E7%BD%AE%E5%92%8C%E6%B8%AC%E8%A9%A6-fb08e77f208e">利用工具加速Dapp建置和測試</a></li>
<li><a href="https://blog.bigchaindb.com/the-dcs-triangle-5ce0e9e0f1dc">The DCS Triangle</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
